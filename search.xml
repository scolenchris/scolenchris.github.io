<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hello1</title>
      <link href="/posts/8731d904.html"/>
      <url>/posts/8731d904.html</url>
      
        <content type="html"><![CDATA[<p>公式 ce’sces</p><p>$$ G ( s ) !=! \frac{Y ( s )} {U ( s )} !=! \frac{b*{m} s^{m}+b*{m-1} s^{m-1}+\cdots+b*{1} s+b*{0}} {a*{n} s^{n}+a*{n-1} s^{n-1}+\cdots+a*{1} s+a*{0}} $$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git知识总结</title>
      <link href="/posts/feefa20.html"/>
      <url>/posts/feefa20.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2024-07-03</h1><ul><li>Time:15:19</li><li>Subject: CS</li><li>Tags: #git<br>[[2024-07]]</li></ul><hr><h2 id="交叉内容">交叉内容</h2><p>[[git命令#- Date 2024-07-03]]</p><h2 id="git工作区域与文件状态">git工作区域与文件状态</h2><h3 id="三个区域">三个区域</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407031520964.png" alt="image.png|600"></p><h4 id="工作区">工作区</h4><ul><li>工作区提交后回到暂存区，确实就是文件管理器看到的，编辑的区域，正常使用（操作）的区域</li></ul><h4 id="暂存区">暂存区</h4><ul><li>保存即将提交到git仓库的内容，临时存储</li><li>可以先修改一部分，放到暂存区钟，再统一提交commit</li></ul><h4 id="本地仓库">本地仓库</h4><ul><li>git init 的仓库，保存了项目历史</li></ul><h3 id="文件状态">文件状态</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407031526681.png" alt="image.png|600"></p><ul><li>未跟踪，新创建，git还没管理，</li><li>未修改，管理起来的，但是没有修改的文件</li><li>已修改，已经修改了的，没暂存</li><li>已暂存，放到暂存区的文件</li></ul><h2 id="gitignore-忽略文件">.gitignore 忽略文件</h2><ul><li>把文件加入到里面，那么就会忽略这个文件</li><li>假如已经加到版本库中，那这个文件就不起作用了，需要先从版本库删除中删除 <code>git rm --catched</code> 本地不删除，但是暂存和版本库都删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*.txt ， *.xls  表示过滤某种类型的文件</span><br><span class="line">target/ ：表示过滤这个文件夹下的所有文件</span><br><span class="line">/test/a.txt ，/test/b.xls  表示指定过滤某个文件下具体文件</span><br><span class="line">!*.java , !/dir/test/     !开头表示不过滤</span><br><span class="line">*.[ab]    支持通配符：过滤所有以.a或者.b为扩展名的文件</span><br><span class="line">/test  仅仅忽略项目根目录下的 test 文件，不包括 child/test等非根目录的test目录</span><br></pre></td></tr></table></figure><h2 id="分支">分支</h2><ul><li>十分重要</li><li><code>git branch &lt;分支名&gt;</code> 创建分支</li><li><code>git checkout &lt;分支名&gt;</code> 切换到分支（恢复文件），可能会有歧义</li><li><code>git switch &lt;分支名&gt;</code> 专门用来切换分支</li><li><code>git merge &lt;被合并的分支1&gt; &lt;目标分支2&gt;</code> 会将1合并到2中</li><li><code>git branch -d &lt;删除的分支&gt;</code> 合并后可以删除，如果没合并就想删除，那得用 <code>-D</code></li></ul><h3 id="冲突解决">冲突解决</h3><ul><li>如果两个分支对同一行都修改了，那就不知道怎么修改了，会有冲突；但是只有一者修改了，那就可以合并</li><li><code>git merge --abort</code> 终止合并</li></ul><h3 id="分支命名">分支命名</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407041152476.png" alt="image.png|600"></p><ul><li>feat——feature，功能开发</li><li>main——分支，稳定版本代码，可以随时发布的，不能直接修改，得用merge来改，用tag标记版本号</li><li>hotfix——问题修复分支，用于合并</li><li>develop——开发版本</li></ul><h3 id="变基rebase">变基rebase</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407041130339.png" alt="image.png|600"></p><ul><li>嫁接移植的感觉</li><li>先switch到要移动的分支dev上，然后用 <code>git rebawse &lt;基的名字，branch名字&gt;</code>，然后就把dev移动到main上了，</li><li>优点：不会有额外提交记录，线性的，直观简洁</li><li>缺点：会改变提交记录，改变branch out的节点，避免在共享分支上使用</li></ul><blockquote><p>[!note]<br>在使用 Git 的 <code>rebase</code> 时，如果两个不同的分支对同一行代码进行了不同的修改，<strong>也会像merge那样产生冲突</strong>,这种冲突需要手动解决。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/posts/341ecd43.html"/>
      <url>/posts/341ecd43.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2024-07-03</h1><ul><li>Time:15:35</li><li>Subject: CS</li><li>Tags: #git<br>[[2024-07]]</li></ul><hr><h2 id="添加和提交文件">添加和提交文件</h2><ul><li><code>git status</code> 查看文件状态</li><li><code>git add xxx</code> 文件移动到暂存区，可以加上通配符，文件夹，如文件夹所有 <code>.</code></li><li><code>git commit -m &quot;xxx&quot;</code> 文件提交到仓库</li><li><code>git log</code> 查看提交记录 <code>--oneline</code> 简单版显示记录</li></ul><h2 id="回退reset">回退reset</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407031535611.png" alt="image.png|600"></p><ul><li>参数的区别</li><li><code>git reset --soft xxxx</code> xxx为版本id</li></ul><h2 id="查看差异git-diff">查看差异git diff</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407031546380.png" alt="image.png|600"></p><ul><li>可用于查看版本之间差异，各个区之间差异，或者分支之间差异</li><li><code>HEAD</code> 表示最新的版本</li><li><code>~</code> 或者 <code>^</code> 表示为上一个版本，如 <code>HEAD~2</code> 前两个版本</li></ul><h2 id="删除文件">删除文件</h2><ul><li>rm之后，还需要在暂存区删除，也就是再add一次</li></ul><h2 id="推送-拉取">推送-拉取</h2><ul><li><code>push</code> <code>pull</code> 拉去和推送，对于原创仓库的</li></ul><h2 id="连接远程仓库">连接远程仓库</h2><ul><li><code>git remote add &lt;仓库别名&gt; &lt;远程仓库地址&gt;</code></li><li><code>git remote -v</code> 查看别名</li><li><code>git push -u &lt;远程仓库名&gt; &lt;分支名&gt;:&lt;分支名&gt;</code> 关联远程和本地，把本地的main推送到远程的main分支，</li><li>拉取远程仓库 <code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-c语言复习</title>
      <link href="/posts/46909ac5.html"/>
      <url>/posts/46909ac5.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-06-05</h1><ul><li>Time:17:08</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-06]]</li></ul><hr><h2 id="printf函数输出流程">printf函数输出流程</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945863.png" alt="Pasted image 20230605171222|600"></p><h2 id="printf的使用">printf的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;字符串\r\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;输出控制符&quot;，输出参数);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, temp);          <span class="comment">/* %d是输出控制符，temp是输出参数 */</span></span><br></pre></td></tr></table></figure><h3 id="常用输出控制符表">常用输出控制符表</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945864.png" alt="Pasted image 20230605172851|600"></p><h3 id="常用转义字符表">常用转义字符表</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945865.png" alt="Pasted image 20230605172915|600"></p><h3 id="例子">例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;输出控制符1输出控制符2…&quot;，输出参数1，输出参数2，…);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp1 = <span class="number">5</span>;   </span><br><span class="line"><span class="type">uint32_t</span>  temp2 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%x \r \n&quot;</span>, temp1,temp2);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;非输出控制符 输出控制符 非输出控制符&quot;，输出参数);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp = <span class="number">10</span>;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;temp=  %d  收到over\r\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何输出%、\和双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%% \r\n&quot;</span>);<span class="comment">// %</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\\\r\n&quot;</span>);<span class="comment">// \</span></span><br><span class="line"><span class="comment">printf(&quot;\&quot;\&quot;\r\n&quot;);// &quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="printf函数支持">printf函数支持</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945866.png" alt="Pasted image 20230605173458|600"></p><h3 id="半主机模式简介">半主机模式简介</h3><p>用于 ARM 目标的一种机制，可将来自应用程序代码的输入/输出请求传送至运行调试器的主机<br>简单说：就是通过仿真器实现开发板在电脑上的输入和输出<br>一般我们：不使用半主机模式！！！</p><h3 id="方法一：微库法">方法一：微库法</h3><p>在魔术棒-&gt;Target选项卡，勾选：Use Micro LIB，即可避免半主机模式<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945867.png" alt="Pasted image 20230605173808|600"></p><h3 id="方法二：代码法">方法二：代码法</h3><p>1个预处理、 2个定义、3个函数，会用就行</p><ol><li><h2 id="pragma-import-use-no-semihosting-，确保不从C库中使用半主机函数">pragma import(__use_no_semihosting)，确保不从C库中使用半主机函数</h2></li><li>定义：__ FILE结构体，避免HAL库某些情况下报错</li><li>定义： FILE __ stdout，避免编译报错</li><li>实现：_ ttywrch、_ sys_exit和_sys_command_string等三个函数<br><font color="#ff0000">在历程（uart.c）中已经实现了</font><br><font color="#ff0000">到时候拷贝就好</font></li></ol><h3 id="微库法-VS-代码法">微库法 VS 代码法</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945868.png" alt="Pasted image 20230605174027|600"></p><h2 id="实现fputc函数">实现fputc函数</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945869.png" alt="Pasted image 20230605175055|600"><br>也不需要怎么知道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-system文件夹</title>
      <link href="/posts/3b21df78.html"/>
      <url>/posts/3b21df78.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-06-05</h1><ul><li>Time:15:31</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-06]]</li></ul><hr><h2 id="sys文件夹介绍">sys文件夹介绍</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945185.png" alt="Pasted image 20230605153158|600"></p><h2 id="deley文件夹介绍">deley文件夹介绍</h2><h3 id="deley文件夹函数简介">deley文件夹函数简介</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945186.png" alt="Pasted image 20230605154243|600"></p><h3 id="SysTick工作原理">SysTick工作原理</h3><p>SysTick，即系统滴答[[定时器]]，包含在M3/4/7内核里面，核心是一个24位的递减计数器(2的24次方，来一个脉冲就递减)<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945187.png" alt="Pasted image 20230605154419|600"><br><font color="#ff0000">每次VAL到0时，VAL自动从LOAD重载！开始新一轮递减计数！</font></p><h3 id="SysTick寄存器介绍">SysTick寄存器介绍</h3><h4 id="SysTick控制及状态寄存器-CTRL">SysTick控制及状态寄存器(CTRL)</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945188.png" alt="Pasted image 20230605155740|600"></p><h4 id="SysTick重装载数值寄存器-LOAD">SysTick重装载数值寄存器(LOAD)</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945189.png" alt="Pasted image 20230605155836|600"></p><h4 id="SysTick当前数值寄存器-VAL">SysTick当前数值寄存器(VAL)</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945190.png" alt="Pasted image 20230605160021|600"></p><h3 id="delay-init-函数-f1">delay_init()函数(f1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">(<span class="type">uint16_t</span> sysclk)</span><span class="comment">//传入72（mhz）</span></span><br><span class="line">&#123;</span><br><span class="line">  SysTick-&gt;CTRL = <span class="number">0</span>;<span class="comment">//hal库清空，再配置</span></span><br><span class="line">  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK_DIV8);<span class="comment">//八分频，所以是72/8=9，计数频率是9mhz</span></span><br><span class="line">  g_fac_us = sysclk / <span class="number">8</span>;<span class="comment">//1us时机的来源</span></span><br><span class="line">  <span class="comment">//自动重装装载值，上面写的72/8=9，我们需要9，传入的是72，所以要处理，</span></span><br><span class="line">  <span class="comment">//1us是1/1000000s，频率f=9mzh，也就是T=1/9mhz=1/9000000s，因此乘以9，在这个计数频率的情况下，数九次才算1us</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delay-us-函数-f1">delay_us()函数(f1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint32_t</span> nus)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">uint32_t</span> temp; </span><br><span class="line">SysTick-&gt;LOAD = nus * g_fac_us; <span class="comment">/* 时间加载 */</span> <span class="comment">//与上面的init照应，乘以9，</span></span><br><span class="line">SysTick-&gt;VAL = <span class="number">0x00</span>; <span class="comment">/* 清空计数器 */</span> </span><br><span class="line">SysTick-&gt;CTRL |= <span class="number">1</span> &lt;&lt; <span class="number">0</span> ; <span class="comment">/* 开始倒数 */</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123; </span><br><span class="line">temp = SysTick-&gt;CTRL; </span><br><span class="line">&#125; <span class="keyword">while</span> ((temp &amp; <span class="number">0x01</span>) &amp;&amp; !(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))); <span class="comment">/* CTRL.ENABLE位必须为1, 并等待时间到达 */</span> <span class="comment">//1000000000000000(2)==2^16==65536</span></span><br><span class="line">SysTick-&gt;CTRL &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>) ; <span class="comment">/* 关闭SYSTICK */</span> </span><br><span class="line">SysTick-&gt;VAL = <span class="number">0X00</span>; <span class="comment">/* 清空计数器 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="delay-ms-函数-f1">delay_ms()函数(f1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用微秒延时函数实现</span></span><br><span class="line"><span class="comment">//us最多可以计数记多少秒：1/9000000*2^24=1s左右</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint16_t</span> nms)</span> <span class="comment">//传入要延时多少毫秒</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">uint32_t</span> repeat = nms / <span class="number">1000</span>;<span class="comment">/* 这里用1000,是考虑到可能有超频应用, </span></span><br><span class="line"><span class="comment">//取大于1000部分     * 比如128Mhz的时候, delay_us最大只能延时1048576us 约为1s</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">uint32_t</span> remain = nms % <span class="number">1000</span>; <span class="comment">//取小于1000部分</span></span><br><span class="line"><span class="keyword">while</span> (repeat) </span><br><span class="line">&#123; </span><br><span class="line">delay_us(<span class="number">1000</span> * <span class="number">1000</span>); <span class="comment">/* 利用delay_us 实现 1000ms 延时 */</span> 也即是<span class="number">1</span>s</span><br><span class="line">repeat--; <span class="comment">//把1000整数倍部分完成</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (remain) </span><br><span class="line">&#123; </span><br><span class="line">delay_us(remain * <span class="number">1000</span>); <span class="comment">/* 利用delay_us, 把尾数延时(remain ms)给做了 */</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>- Date:2023-06-05</h1><ul><li>Time:17:08</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-06]]</li></ul><hr><h2 id="printf函数输出流程">printf函数输出流程</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945863.png" alt="Pasted image 20230605171222|600"></p><h2 id="printf的使用">printf的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;字符串\r\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;输出控制符&quot;，输出参数);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, temp);          <span class="comment">/* %d是输出控制符，temp是输出参数 */</span></span><br></pre></td></tr></table></figure><h3 id="常用输出控制符表">常用输出控制符表</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945864.png" alt="Pasted image 20230605172851|600"></p><h3 id="常用转义字符表">常用转义字符表</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945865.png" alt="Pasted image 20230605172915|600"></p><h3 id="例子">例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;输出控制符1输出控制符2…&quot;，输出参数1，输出参数2，…);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp1 = <span class="number">5</span>;   </span><br><span class="line"><span class="type">uint32_t</span>  temp2 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%x \r \n&quot;</span>, temp1,temp2);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;非输出控制符 输出控制符 非输出控制符&quot;，输出参数);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp = <span class="number">10</span>;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;temp=  %d  收到over\r\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何输出%、\和双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%% \r\n&quot;</span>);<span class="comment">// %</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\\\r\n&quot;</span>);<span class="comment">// \</span></span><br><span class="line"><span class="comment">printf(&quot;\&quot;\&quot;\r\n&quot;);// &quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="printf函数支持">printf函数支持</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945866.png" alt="Pasted image 20230605173458|600"></p><h3 id="半主机模式简介">半主机模式简介</h3><p>用于 ARM 目标的一种机制，可将来自应用程序代码的输入/输出请求传送至运行调试器的主机<br>简单说：就是通过仿真器实现开发板在电脑上的输入和输出<br>一般我们：不使用半主机模式！！！</p><h3 id="方法一：微库法">方法一：微库法</h3><p>在魔术棒-&gt;Target选项卡，勾选：Use Micro LIB，即可避免半主机模式<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945867.png" alt="Pasted image 20230605173808|600"></p><h3 id="方法二：代码法">方法二：代码法</h3><p>1个预处理、 2个定义、3个函数，会用就行</p><ol><li><h2 id="pragma-import-use-no-semihosting-，确保不从C库中使用半主机函数">pragma import(__use_no_semihosting)，确保不从C库中使用半主机函数</h2></li><li>定义：__ FILE结构体，避免HAL库某些情况下报错</li><li>定义： FILE __ stdout，避免编译报错</li><li>实现：_ ttywrch、_ sys_exit和_sys_command_string等三个函数<br><font color="#ff0000">在历程（uart.c）中已经实现了</font><br><font color="#ff0000">到时候拷贝就好</font></li></ol><h3 id="微库法-VS-代码法">微库法 VS 代码法</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945868.png" alt="Pasted image 20230605174027|600"></p><h2 id="实现fputc函数">实现fputc函数</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945869.png" alt="Pasted image 20230605175055|600"><br>也不需要怎么知道</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-基础知识</title>
      <link href="/posts/1bce3e80.html"/>
      <url>/posts/1bce3e80.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-05-22</h1><ul><li>Time:22:55</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="存储器映射">存储器映射</h2><ol><li>存储器指可以存储数据的设备，本身没有地址信息，对存储器分配地址的过程称为存储器映射</li><li>19根地址线：A0-A18   16根数据线：D0-D15</li><li>地址范围：0 - 512K<ol><li>映射1：0 - 512K</li><li>映射2：1 – 512K + 1</li><li>映射3：100K – 612K</li><li>映射4：512K – 1024K</li></ol></li><li>F1为例子<ol><li>ST将4GB（2^32）地址空间分成8个块<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945405.png" alt="Pasted image 20230522230107|600"></li></ol></li><li>Block0（FLASH）功能划分<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945406.png" alt="Pasted image 20230522231205|600"></li></ol></li><li>Block1（SRAM）功能划分<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945407.png" alt="Pasted image 20230522231229|600"></li></ol></li><li>Block2（外设）功能划分<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945408.png" alt="Pasted image 20230522231356|600"></li></ol></li></ol></li></ol><h3 id="寄存器映射">寄存器映射</h3><ol><li>寄存器是单片机内部一种特殊的内存，可以实现对单片机各个功能的控制</li><li>简单来说：寄存器就是单片机内部的控制机构<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945409.png" alt="Pasted image 20230522231543|600"></li></ol></li><li>STM32寄存器分类<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945410.png" alt="Pasted image 20230522231558|600"></li></ol></li></ol><h3 id="F1为例">F1为例</h3><ol><li>寄存器是特殊的存储器，给寄存器地址命名的过程，就叫寄存器映射<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945411.png" alt="Pasted image 20230522232415|600"></li></ol></li><li>寄存器描述解读<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945412.png" alt="Pasted image 20230522232618|600"><ol><li>① 寄存器名字</li><li>② 偏移量及复位值</li><li>③ 寄存器位表</li><li>④ 位功能描述</li></ol></li><li>直接操作寄存器地址：</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x4001</span> <span class="number">080</span>C) = <span class="number">0XFFFF</span>;</span><br><span class="line"><span class="comment">//强转unsigned int *,再取地址的值，然后进行操作</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名字后再操作：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    GPIOA_ODR    *(unsigned int *)(0x4001 080C)</span></span><br><span class="line">GPIOA_ODR = <span class="number">0XFFFF</span>；</span><br></pre></td></tr></table></figure><ol start="3"><li>寄存器地址计算<ol><li>为了方便编写代码及使用，我们将寄存器地址分为三个部分：<ol><li>总线基地址（BUS_BASE_ADDR）（对应总线表格中最下面的那个地址）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945413.png" alt="Pasted image 20230525091736|600"></li><li>APB1总线的基地址，也叫外设基地址（PERIPH_BASE）</li><li>此表的偏移量：是相对外设基地址（PERIPH_BASE）来说的</li></ol></li><li>外设基于总线基地址的偏移量（PERIPH_OFFSET）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945414.png" alt="Pasted image 20230525091902|600"></li><li>apb2为例子</li><li>此表的偏移量：是相对APB2外设基地址（APB2PERIPH_BASE）来说的</li><li>这是外设的基地址，上面是总线的基地址</li></ol></li><li>寄存器相对外设基地址的偏移量（REG_OFFSET）（对应8.24图的地址偏移0Ch）<ol><li>以GPIOA外设为例子</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945415.png" alt="Pasted image 20230525092031|600"></li><li>此表的偏移量：是相对GPIOA外设基地址（GPIOA_BASE（上图））来说的</li></ol></li></ol></li><li>例子计算过程（GPIOA_ODR寄存器地址计算过程）<ol><li>获取外设挂在哪个总线上面？查：系统结构图（同时得知道是哪个外设USART1_xx，那就是usart1）</li><li>获取总线基地址，APB2总线基地址：0X4001 0000</li><li>获取外设地址偏移量，GPIOA相对APB2总线偏移量是：0X800（一般可以直接找到外设地址）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945416.png" alt="Pasted image 20230525092659|600"></li></ol></li><li>获取寄存器地址偏移量，ODR相对GPIOA外设基地址的偏移量是：0X0C<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945417.png" alt="Pasted image 20230525092528|600"></li><li>在手册中找</li></ol></li><li>寄存器地址 = <font color="#ff0000">BUS_BASE_ADDR +  PERIPH_OFFSET + REG_OFFSET</font></li><li>GPIOA_ODR = 0X4001 0000 + 0X800 + 0X0C = 0X4001 080C</li></ol></li></ol></li><li>寄存器映射实现</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CRL;</span><br><span class="line">  __IO <span class="type">uint32_t</span> CRH;</span><br><span class="line">  __IO <span class="type">uint32_t</span> IDR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> ODR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> BSRR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> BRR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LCKR;</span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line">GPIOA_BASE： <span class="number">0X4001</span> <span class="number">0800</span></span><br></pre></td></tr></table></figure><pre><code>1. 使用结构体，可以很方便的完成对寄存器的映射：2. 一次性把7个寄存器映射完毕，可对比上面的对一个寄存器映射3. 由于刚好结构体每个地址差4个字节，每个寄存器基地址之间差4个字节</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>   GPIOA     ((GPIO_TypeDef *)GPIOA_BASE)</span></span><br><span class="line"><span class="comment">//强转GPIOA_BASE为结构体的地址</span></span><br><span class="line">&amp;GPIOA-&gt;CRL： <span class="number">0X4001</span> <span class="number">0800</span></span><br><span class="line">&amp;GPIOA-&gt;CRH： <span class="number">0X4001</span> <span class="number">0804</span></span><br><span class="line">&amp;GPIOA-&gt;IDR：  <span class="number">0X4001</span> <span class="number">0808</span></span><br><span class="line">&amp;GPIOA-&gt;ODR： <span class="number">0X4001</span> <span class="number">080</span>C</span><br><span class="line">实际应用：</span><br><span class="line"><span class="comment">//对地址的所指的位置赋值</span></span><br><span class="line"><span class="comment">//与前面单独对寄存器操作对比，方便了</span></span><br><span class="line">GPIOA-&gt; ODR = <span class="number">0XFFFF</span>；</span><br><span class="line">详见：stm32f103xe.h，<span class="number">725</span>行开始</span><br></pre></td></tr></table></figure><ol start="5"><li>stm32f103xe.h主要组成部分<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945418.png" alt="Pasted image 20230525094311|600"></li></ol></li></ol><h1>- Date:2023-05-25</h1><ul><li>Time:09:48</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="英文缩写部分">英文缩写部分</h2><h3 id="A：">A：</h3><p>ADC--------Analog-to-Digital Converter—模/数转换器，模数转换器<br>AFIO-------alternate function IO—复用 IO 端口<br>AHB--------先进高性能总线<br>AHB-AP----AHB访问端口<br>Arg---------argument—自变量<br>APB--------先进外设总线<br>API---------Application Programming Interface—应用程序编程接口</p><h3 id="B：">B：</h3><p>BKP------后备寄存器<br>BSP------Board Support Package—板级支持包<br>BYP------Bypass—旁路<br>BYP------backup—备份</p><h3 id="C：">C：</h3><p>CAN-----Controller area network—控制器局域网<br>Calc-----Calculate—计算<br>CM------CMSIS标准—Cortex Microcontroller Software Interface Standard—Cortex微控制器软件接口标准<br>Cmd-----command—[kəˈmɑ:nd]—命令、使能<br>CLK------Clock—时钟<br>Conf-----Config—配置<br>CPI-------每条指令的周期数<br>CRC------Cyclic Redundancy Check—循环冗余校验<br>CSR------clock control/status register—时钟控制/状态寄存器<br>Ctrl— —control—控制</p><h3 id="D：">D：</h3><p>DAC-----Digital to analog converter—数/模转换器，数字模拟转换器<br>DAP-----调试访问端口<br>DBG-----debug—调试<br>def ------Define—定义<br>DMA----Direct Memory Access—存储器直接访问<br>doc------Document—文件<br>DSP-----数字信号处理器/数字信号处理<br>DWT----数据观察点及跟踪</p><h3 id="E：">E：</h3><p>ETM------<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&amp;spm=1001.2101.3001.7020">嵌入式</a>跟踪宏单元<br>Eval-------Evaluate—评估<br>EXTI-------External Interrupts—外部中断</p><h3 id="F：">F：</h3><p>FLITF-----The Flash memory interface—闪存存储器接口<br>FPB-------闪存地址重载及断点<br>FPGA-----Field-Programmable Gate Array—现场可编程门阵列<br>FSMC-----Flexible static memory controller—可变静态存储控制器<br>FSR--------Fault状态寄存器<br>FwLib-----Firmware Library—固件库</p><h3 id="G：">G：</h3><p>GPIO------general purpose input/output—通用 IO 端口<br>H：<br>HSE-----------High Speed External oscillator—高速外部时钟<br>HSI------------High Speed Internal oscillator—高速内部时钟<br>HTM----------CoreSight AHB跟踪宏单元</p><h3 id="I：">I：</h3><p>ICE--------in circuit emulator—在线仿真器<br>IDE--------integrated development environment—集成开发环境<br>inc--------Include—包括<br>INT -------it—Interrupt—中断<br>Init -------Initialize—[ɪˈnɪʃəlaɪz]—初始化<br>I2C--------IIC—Inter-integrated circuit—微集成电路<br>I2S--------IIS—integrate interface of sound—集成音频接口<br>IRQ-------中断请求(通常是指外部中断的请求)<br>IRQn-----中断级<br>ISA-------指令系统架构<br>ISR--------Interrupt Service Routines—中断服务程序<br>ITM-------指令跟踪宏单元<br>IWDG----independent watchdog—独立看门狗</p><h3 id="J：">J：</h3><p>JTAG---------连结点测试行动组(一个关于测试和调试接口的标准)<br>JTAG-DP----JTAG调试端口</p><h3 id="L：">L：</h3><p>Lib------lib—Library—库<br>LP------Low Power—低功耗<br>LR------link register—链接寄存器<br>LSB-----最低有效位<br>LSE-----Low Speed External oscillator—低速外部时钟<br>LSI------Low Speed Internal oscillator—低速内部时钟<br>LSU-----加载/存储单元</p><h3 id="M：">M：</h3><p>MCU—微控制器单元(俗称单片机)<br>MIPS—million instructions per second—每秒能执行的百万条指令的条数<br>MPU—Memory Protection Unit—存储器保护单元<br>MSB----最高有效位<br>MSP----main stack pointer—主堆栈指针</p><h3 id="N：">N：</h3><p>NVIC— Nested Vectored Interrupt Controller—嵌套向量中断控制器<br>NMI----不可屏蔽中断</p><h3 id="O：">O：</h3><p>OS------------操作系统<br>OTG----------On The Go—数据交换</p><h3 id="P：">P：</h3><p>PC--------------program counter—程序计数器<br>Periph---------Peripherals—[pəˈrɪfərəlz]—外设<br>PLL--------------Phase Locked Loop—锁相环\倍频器<br>PSP------------process stack pointer—进程堆栈指针<br>POR/PDR—上电/掉电复位<br>PPB-----------私有外设总线<br>PWR----------电源控制</p><h3 id="R：">R：</h3><p>RCC--------------------Reset and clock control—复位和时钟控制<br>Retval----------------Return value—返回值<br>RTC-------------------Real-Time Clock—实时时钟</p><h3 id="S：">S：</h3><p>SCB-------System control block<br>SDIO-----SD I/O—Secure Digital Input and Output—安全数字输入输出卡<br>SRAM----Static Random-Access Memory—静态随机存取存储器<br>SP---------stack pointer—堆栈指针<br>SPI--------Serial Peripheral Interface—串行外围设备接口<br>src--------Source—源码<br>std--------Standard—[ˈstændəd]—标准<br>STK-------SysTick timer<br>SW----- --Software—软件</p><h3 id="T：">T：</h3><p>Tab-----table—表<br>TIM-----timer—定时器</p><h3 id="U：">U：</h3><p>UART------Universal Asynch. Receiver Transmitter—通用异步接收/发送装置<br>USART-----Universal Synchronou/Asynchronous Receiver/Transmitter—通用同步/异步串行接收/发送器<br>USB--------Universal Serial Bus—通用串行总线<br>USBPRE—USB prescaler----USB预分频</p><h3 id="W：">W：</h3><p>WWDG—Window watchdog—窗口看门狗</p><h2 id="词汇部分">词汇部分</h2><h3 id="A：-2">A：</h3><p>Acceleration—[əkˌseləˈreɪʃn]—加速度<br>Access—[ˈækses]—访问、进入<br>Accordingly—相应地<br>Activate—[ˈæktɪveɪt]—激活<br>add-on—附加物<br>address offset—地址偏移量<br>Alias—[ˈeɪliəs]—别名<br>Align—[əˈlaɪn]—校准，使一致<br>Alternate—[ˈɔ:ltərnət]—替代、备用<br>Arbitration—[ˌɑ:bɪˈtreɪʃn]—仲裁<br>Argument—[ˈɑ:ɡjumənt]—自变量<br>Array—[əˈreɪ]—数组<br>Assembler—[əˈsemblə®]—汇编器<br>Assert—[əˈsɜ:t]—断言</p><h3 id="B：-2">B：</h3><p>Backslash—[ˈbækslæʃ]—(计算机符号)反斜线<br>Backup—备份<br>Brief—[bri:f]—任务简介<br>Buffer—[ˈbʌfə®]—缓存器，缓冲存储区</p><h3 id="C：-2">C：</h3><p>Calibration—[ˌkælɪˈbreɪʃn]—校准<br>Call—调用<br>Capture—[ˈkæptʃə®]—捕获<br>Code—代码<br>Comments—注释<br>Compute—计算<br>Configure—[kənˈfɪɡə®]—配置<br>Constant—[ˈkɒnstənt]—常数<br>Counter—[ˈkaʊntə®]—计数器<br>Channel—[ˈtʃænl]—通道、源<br>Crystal—[ˈkrɪstl]—晶体</p><h3 id="D：-2">D：</h3><p>Decode—[ˌdi:ˈkəʊd]—译码、解码<br>Decrement—[ˈdɛkrɪmənt]—减量，消耗<br>Default value—默认值<br>Depend on—根据<br>dependent variable–[dɪˌpendənt ˈveəriəbl]-因变量<br>Determine—[dɪˈtɜ:mɪn]—测定，查明<br>Differential—[ˌdɪfəˈrenʃl]—微分<br>Disassembly—反汇编</p><h3 id="E：-2">E：</h3><p>Emulator—[ˈemjuleɪtə®]—仿真器<br>Enable—使能、启用<br>Entry—[ˈentri]—进入<br>Enumeration—[ɪˌnju:məˈreɪʃn]—枚举<br>Even—偶<br>Exceed—超过<br>Exception—[ɪkˈsepʃn]—异常<br>Execute—[ˈeksɪkju:t]—执行<br>Expanse—[ɪkˈspæns]—扩展<br>Export—[ɪkˈspɔ:t , ˈekspɔ:t]—输出、导出</p><h3 id="F：-2">F：</h3><p>Falling edge—下降沿<br>Force—[fɔ:s]—强制<br>Frequency—[ˈfri:kwənsi]—频率</p><h3 id="G：-2">G：</h3><p>Global variable—全局变量<br>Gyroscope—[ˈdʒaɪrəskəʊp]—陀螺仪</p><h3 id="H：">H：</h3><p>Halt—[hɔ:lt]—(使)停止<br>Handler—[ˈhændlə®]—处理程序<br>Hard Fault—硬件故障，硬故障<br>Hardware—硬件<br>Heap—[hi:p]—堆<br>Hint—[hɪnt]—提示</p><h3 id="I：-2">I：</h3><p>Implement—[ˈɪmplɪments]—执行、工具<br>Indicate—[ˈɪndɪkeɪt]—表明<br>Infinite—[ˈɪnfɪnət]—无限的<br>Initial—[ɪˈnɪʃl]—最初的<br>Instructions—[ɪnˈstrʌkʃənz]—指令<br>Integral—[ˈɪntɪɡrəl]—积分<br>Interface—[ˈɪntəfeɪs]—接口</p><h3 id="L：-2">L：</h3><p>Legacy—[ˈleɡəsi]—遗留<br>Local variable—局部变量<br>Loop—[lu:p]—循环</p><h3 id="M：-2">M：</h3><p>Macro—宏，宏指令<br>Mapping—映射<br>Mask—屏蔽<br>Memory—[ˈmeməri]—存储器<br>Memory Manage—内存管理<br>Modify—[ˈmɒdɪfaɪɪŋ]—修改<br>Module—[ˈmɒdju:l]—模块<br>Mount on—安装</p><h3 id="N：-2">N：</h3><p>Numeric—[nju(:)ˈmɛrɪk]—数（字，值）<br>Newline—换行符、新的一行</p><h3 id="O：-2">O：</h3><p>Odd—奇<br>Offset—[ˈɒfset]—补偿<br>Operation—[ˌɒpəˈreɪʃn]—操作、运行<br>Oscillator—[ˈɒsɪleɪtə®]—振荡器</p><h3 id="P：-2">P：</h3><p>Parallel—[ˈpærəlel]—并行<br>Parameter—[pəˈræmɪtə®]—参数<br>Parity—奇偶性<br>Perform—[pəˈfɔ:m]—执行<br>Permissions—[pəˈmɪʃənz]—权限<br>Preemption—[ˌpri:ˈempʃn]—抢占<br>Presentation—[ˌpreznˈteɪʃn]—显示、出示、演示<br>Priority Levels—[praɪˈɒrəti ˈlevlz]—优先级<br>Processor—[ˈprəʊsesə®]—处理器<br>Proportion—[prəˈpɔ:ʃn]—比例<br>Prototype—[ˈprəʊtətaɪp]—原型</p><h3 id="R：-2">R：</h3><p>Recursive—[rɪˈkɜ:sɪv]—递归的、循环的<br>refer to—参阅<br>Remap—重新映射<br>Reset—重置<br>Rising edge—上升沿</p><h3 id="S：-2">S：</h3><p>Schmitt Trigger—[ʃmɪt ˈtrɪɡər]—施密特触发器<br>Section—[ˈsekʃn]—部分，节<br>Select—[sɪˈlekt]—选择<br>Serial—[ˈsɪəriəl]—串行<br>service routine—服务程序<br>Setup—(软件或硬件的)安装，设置<br>Simplify—[ˈsɪmplɪfaɪ]—简化<br>Specified—[ˈspesɪfaɪd]—明确规定<br>Specifies—[ˈspesɪfaɪz]—指定<br>Suppression—[səˈpreʃn]—抑制<br>Stack—[stæk]—堆栈<br>Startup—启动<br>Stray—[streɪ]—孤立的、杂散的<br>Symbolic—[sɪmˈbɒlɪk]—象征性的</p><h3 id="T：-2">T：</h3><p>Table—表<br>Tailor—[ˈteɪlə®]—专门制作，定做<br>Temperature—[ˈtemprətʃə®]—温度<br>Template—[ˈtempleɪt]—模板<br>Toggle—[ˈtɒɡl]—切换<br>Trigger—[ˈtrɪɡə®]—触发</p><h3 id="U：-2">U：</h3><p>Uncomment—取消批注<br>Unique—[juˈni:k]—唯一的<br>Usage—[ˈju:sɪdʒ]—使用<br>Usart—通用同步异步收发器<br>Use—用途、使用</p><h3 id="V：">V：</h3><p>Vector—[ˈvektə®]—矢量<br>Velocity—速度<br>Voltage—[ˈvəʊltɪdʒ]—电压</p><h1>- Date:2023-05-22</h1><ul><li>Time:22:39</li><li>Subject:</li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="Cortex-M内核-芯片">Cortex M内核 &amp; 芯片</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945058.png" alt="Pasted image 20230522224008|600"></li></ol><h2 id="F1系统架构">F1系统架构</h2><ol><li>4个主动单元 + 4个被动单元</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945059.png" alt="Pasted image 20230522224227|600"><ol><li>AHB：高级高性能总线</li><li>APB：高级外围总线</li></ol></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945060.png" alt="Pasted image 20230522224605|600"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-hal</title>
      <link href="/posts/982d5dfa.html"/>
      <url>/posts/982d5dfa.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-05-25</h1><ul><li>Time:15:57</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="基于CMSIS应用程序文件描述">基于CMSIS应用程序文件描述</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030944008.png" alt="Pasted image 20230604222756|600"></li></ol><h2 id="STM32开发文件结构分布">STM32开发文件结构分布</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030944009.png" alt="Pasted image 20230604222818|600"></li></ol><h2 id="HAL库的用户配置文件（stm32f1xx-hal-conf-h）">HAL库的用户配置文件（stm32f1xx_hal_conf.h）</h2><ol><li>裁剪HAL库外设驱动源码（不进行编译）<ol><li>/#ifdef /#endif 的使用</li></ol></li><li>设置外部高速晶振频率（HSF）（根据开发板实际情况设置）</li><li>设置外部低速晶振频率（根据开发板实际情况设置）</li></ol><h2 id="HAL库使用注意事项">HAL库使用注意事项</h2><ol><li>使用HAL库出现问题，还是得通过参考手册检查是否硬件操作是否有问题</li><li>尽量不通过修改库源码实现功能，这样不方便库更新</li><li>HAL库可能会存在错误，要有质疑精神</li><li>有些HAL库API函数执行效率偏低，我们可能会直接通过操作寄存器的方式代替</li></ol><h1>- Date:2023-05-25</h1><ul><li>Time:12:53</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="CMSIS简介">CMSIS简介</h2><ol><li>CMSIS (微控制器软件接口标准)：Cortex Microcontroller Software Interface Standard，是由ARM和与其合作的芯片厂商、软件工具厂商，共同制定的标准<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945752.png" alt="Pasted image 20230525151257|600"></li></ol></li></ol><h2 id="HAL库简介">HAL库简介</h2><ol><li>ST 为了方便用户开发 STM32芯片开发提供了三种库：<ol><li>标准外设库 (Standard Peripheral Libraries)<ol><li>F0/F1/F3/F2/F4/L1</li><li>目前已停止维护</li></ol></li><li>HAL库(硬件抽象层)：Hardware Abstraction Layer<ol><li>全系列兼容</li><li>ST目前主推的库</li><li>兼容性、易移植性</li><li>效率低</li></ol></li><li>LL库：Low Layer<ol><li>全系列兼容</li><li>与HAL库捆绑发布</li><li>轻量级、效率高</li><li>不匹配部分复杂外设</li></ol></li></ol></li></ol><h2 id="STM32Cube固件包浅析">STM32Cube固件包浅析</h2><h3 id="STM32Cube固件包文件夹简介">STM32Cube固件包文件夹简介</h3><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945753.png" alt="Pasted image 20230525151957|600"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945754.png" alt="Pasted image 20230525152058|600"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945755.png" alt="Pasted image 20230525152106|600"></li></ol><h3 id="CMSIS文件夹关键文件">CMSIS文件夹关键文件</h3><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945756.png" alt="Pasted image 20230525152122|600"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945757.png" alt="Pasted image 20230525152258|600"></li></ol><h4 id="Device和Include文件夹的关键文件介绍">Device和Include文件夹的关键文件介绍</h4><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945758.png" alt="Pasted image 20230525152330|600"></li><li>可以从cube固件包里面找</li></ol><h2 id="HAL库框架结构">HAL库框架结构</h2><h3 id="HAL库文件夹结构">HAL库文件夹结构</h3><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945759.png" alt="Pasted image 20230525153514|600"><ol><li>Src(Source)：外设驱动源码</li><li>Inc(Include)：外设驱动源码头文件</li></ol></li></ol><h3 id="HAL库文件介绍">HAL库文件介绍</h3><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945760.png" alt="Pasted image 20230525153656|600"></li></ol><h3 id="HAL库API函数和变量命名规则">HAL库API函数和变量命名规则</h3><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945761.png" alt="Pasted image 20230525153716|600"><ol><li>初始化/反初始化函数:HAL_PPP_Init(),   HAL_PPP_DeInit()</li><li>外设读写函数:HAL_PPP_Read(),   HAL_PPP_Write(),   HAL_PPP_Transmit(),    HAL_PPP_Receive()</li><li>控制函数:HAL_PPP_Set (),     HAL_PPP_Get ()</li><li>状态和错误:HAL_PPP_GetState (),    HAL_PPP_GetError ()</li></ol></li></ol><h3 id="HAL库对寄存器位操作的相关宏定义">HAL库对寄存器位操作的相关宏定义</h3><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945762.png" alt="Pasted image 20230525154333|600"></li></ol><h3 id="HAL库回调函数">HAL库回调函数</h3><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945763.png" alt="Pasted image 20230525154615|600"><ol><li>此类函数通常被_weak修饰（弱函数），允许用户重新定义该函数</li></ol></li></ol><h1>- Date:2023-06-04</h1><ul><li>Time:22:41</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-06]]</li></ul><hr><h2 id="MAP文件浅析">MAP文件浅析</h2><ol><li>MDK编译过程文件（11种）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945918.png" alt="Pasted image 20230604224248|600"></li></ol></li><li>MAP文件概念和作用<ol><li>MAP文件是MDK编译代码后，产生的集程序、数据及IO空间的一种映射列表文件</li><li>简单说就是包括了：各种.c文件、函数、符号等的地址、大小、引用关系等信息</li><li><font color="#ff0000">分析各.c文件占用FLASH 和 RAM的大小，方便优化代码</font></li></ol></li><li>MAP文件组成<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945919.png" alt="Pasted image 20230604224449|600"></li></ol></li></ol><h2 id="STM32启动过程">STM32启动过程</h2><ol><li>STM32启动模式（F1/F4/F7/H7）（也称自举模式）<ol><li>M3/M4/M7等内核复位后，做的第一件事：<ol><li>从地址 0x0000 0000 处取出堆栈指针 MSP 的初始值，该值就是栈顶地址</li><li>从地址 0x0000 0004 处取出程序计数器指针 PC 的初始值，该值是复位向量</li></ol></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945920.png" alt="Pasted image 20230604225747|600"></li></ol></li><li>STM32启动模式（F1）<ol><li>在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945921.png" alt="Pasted image 20230604225826|600"></li></ol></li><li>STM32启动过程(内部FLASH启动为例)<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945922.png" alt="Pasted image 20230604230440|600"></li><li>.s启动文件介绍<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945923.png" alt="Pasted image 20230604230828|600"></li></ol></li><li>Reset_Handler函数介绍(汇编)</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler   [WEAK]</span><br><span class="line">                IMPORT  __main</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                LDR   R0, =SystemInit</span><br><span class="line">                BLX   R0              </span><br><span class="line">                LDR   R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure><pre><code>1. EXPORT：标明全局属性，可被外部调用2. IMPORT：申明来自外部文件，类extern3. PROC：定义子程序4. ENDP：表示子程序结束5. WEAK：弱定义</code></pre><ol><li>堆栈简介<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945924.png" alt="Pasted image 20230604231214|600"></li><li>函数局部变量较多，嵌套关系复杂时，需加大栈大小（Stack_Size）！</li></ol></li></ol><h2 id="32启动过程图解">32启动过程图解</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945925.png" alt="Pasted image 20230604231507|600"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-gpio</title>
      <link href="/posts/6a0f884f.html"/>
      <url>/posts/6a0f884f.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-06-08</h1><ul><li>Time:20:49</li><li>Subject: none</li><li>Tags: #stm32 #GPIO<br>[[2023-06]]</li></ul><hr><h2 id="通用外设驱动模型（四步法）">通用外设驱动模型（四步法）</h2><ol><li>初始化<ol><li>时钟设置：选择时钟源，启动时钟</li><li>参数设置：gpio工作方式</li><li>io设置：除了gpio，如串口usart，</li><li>中断设置：开启，设置NVIC</li></ol></li><li>读函数（可选）<ol><li>从外设读取数据</li></ol></li><li>写函数（可选）<ol><li>往外设写入数据</li></ol></li><li>中断服务函数（可选）<ol><li>根据中断标志，处理外设各种中断事务</li></ol></li></ol><h2 id="GPIO配置步骤">GPIO配置步骤</h2><p>#配置</p><h3 id="使能时钟">使能时钟</h3><p><font color="#ff0000">__HAL_RCC_GPIOx_CLK_ENABLE()</font><br>主要寄存器：<br>F1：RCC_APB2ENR //APB2总线上的<br>F4：RCC_AHB1ENR<br>F7：RCC_AHB1ENR<br>H7：RCC_AHB4ENR<br>开启GPIO时钟</p><h3 id="设置工作模式">设置工作模式</h3><p><font color="#ff0000">HAL_GPIO_Init()</font><br>主要寄存器：<br>F1：CRL、CRH、ODR<br>F4/F7/H7：MODER、OTYPER、OSPEEDR、PUPDR<br>初始化GPIO</p><h3 id="设置输出状态（可选）">设置输出状态（可选）</h3><p><font color="#ff0000">HAL_GPIO_WritePin()</font><br><font color="#ff0000">HAL_GPIO_TogglePin()</font><br>主要寄存器：<br>BSRR，控制IO输出高/低电平；BSRR，每次调用IO输出电平翻转一次</p><h3 id="读取输入状态（可选）">读取输入状态（可选）</h3><p><font color="#ff0000">HAL_GPIO_ReadPin()</font><br>主要寄存器：<br>IDR，读取IO电平</p><h3 id="关键结构体简介">关键结构体简介</h3><p>F1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> Pin;        <span class="comment">/* 引脚号 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Mode;   <span class="comment">/* 模式设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Pull;       <span class="comment">/* 上拉下拉设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Speed;  <span class="comment">/* 速度设置 */</span></span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure><p>F4/F7/H7</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> Pin;              <span class="comment">/* 引脚号 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Mode;         <span class="comment">/* 模式设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Pull;            <span class="comment">/* 上拉下拉设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Speed;       <span class="comment">/* 速度设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Alternate; <span class="comment">/* 复用功能 */</span></span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure><h1>- Date:2023-06-08</h1><ul><li>Time:19:32</li><li>Subject: none</li><li>Tags: #stm32 #GPIO<br>[[2023-06]]</li></ul><hr><h2 id="GPIO寄存器介绍">GPIO寄存器介绍</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939351.png" alt="Pasted image 20230608193627|600"><br>x：A B…<br>yyy：寄存器简写</p><h3 id="端口配置-font-color-ff0000-低-font-寄存器（CRL）-F1">端口配置 <font color="#ff0000">低</font> 寄存器（CRL）- F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939352.png" alt="Pasted image 20230608195953|600"><br>需要上下表格同时看，3 2 1 0 控制一个io口，4bit控制一个io口，</p><h3 id="端口配置-font-color-ff0000-高-font-寄存器（CRH）-F1">端口配置 <font color="#ff0000">高</font> 寄存器（CRH）- F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939353.png" alt="Pasted image 20230608200615|600"><br>上面两个加起来控制16个io口，都起配置作用；每组 GPIO 下有 16 个 IO 口，一个寄存器共 32 位，每 4 个位控制 1 个 IO，所以才需要两个寄存器完成。</p><h3 id="工作模式配置补充-–-F1">工作模式配置补充 – F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939354.png" alt="Pasted image 20230608201001|600"><br>补充的原因：cnf1 cnf0位置配置上下拉输入，但是不确定，需要在odr寄存器中再设置</p><h3 id="端口输出数据寄存器（ODR）–-F1">端口输出数据寄存器（ODR）– F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939355.png" alt="Pasted image 20230608201200|600"><br>用于设置IO引脚输出的电平<br>PA10对应ODR10，设置功能对应的值看上图</p><h3 id="端口输入数据寄存器（IDR）–-F1">端口输入数据寄存器（IDR）– F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939356.png" alt="Pasted image 20230608202245|600"><br>用于判断IO引脚的电平，用于读取的外部输入的是高还是低的寄存器</p><h3 id="端口位设置-清除寄存器（BSRR）–-F1">端口位设置/清除寄存器（BSRR）– F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939357.png" alt="Pasted image 20230608202716|600"><br>比如再BS10设置为1，则ODR10位就输出高电平</p><h3 id="F4-F7-H7系列的GPIO相关寄存器略（看ppt">F4/F7/H7系列的GPIO相关寄存器略（看ppt</h3><h3 id="ODR和BSRR寄存器控制输出有什么区别？">ODR和BSRR寄存器控制输出有什么区别？</h3><p>ST官方给的答案：使用ODR，在读和修改访问之间产生中断时，可能会发生风险；BSRR则无风险。<br>BSRR  VS  ODR：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPIOB-&gt;ODR |= <span class="number">1</span> &lt;&lt; <span class="number">3</span>;           <span class="comment">/* PB3 = 1 */</span></span><br><span class="line">相当于ODR=ODR|(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)，先读取了原来的值，再进行操作</span><br><span class="line"></span><br><span class="line">GPIOB-&gt;BSRR = <span class="number">0x00000008</span>;      <span class="comment">/* PB3 = 1 */</span></span><br></pre></td></tr></table></figure><p>ODR修改：读-&gt;改-&gt;写<br>BSRR修改：              写<br>可能在 读改 或者 改写 的过程中有中断，发生问题<br>建议大家使用BSRR寄存器控制输出</p><h1>- Date:2023-06-08</h1><ul><li>Time:11:03</li><li>Subject:</li><li>Tags: #stm32 #GPIO<br>[[2023-06]]</li></ul><hr><h2 id="IO端口基本结构介绍">IO端口基本结构介绍</h2><h3 id="F1的IO结构图">F1的IO结构图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939773.png" alt="Pasted image 20230608110438|600"></p><h3 id="F4-F7-H7的IO结构图">F4/F7/H7的IO结构图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939775.png" alt="Pasted image 20230608110411|600"></p><h3 id="施密特触发器简介">施密特触发器简介</h3><p>施密特触发器就是一种整形电路，可以将非标准方波，整形成方波<br>特点：</p><ol><li>当输入电压高于正向阈值电压，输出为高；</li><li>当输入电压低于负向阈值电压，输出为低；</li><li>当输入在正负向阈值电压之间，输出不改变。<br>效果：整形！如正弦波转方波<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939776.png" alt="Pasted image 20230608111057|600"></li></ol><h3 id="P-MOS-N-MOS管简介">P-MOS &amp; N-MOS管简介</h3><p>MOS管是压控型元件，通过控制栅源电压（ Vgs ）来实现导通或关闭。<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939777.png" alt="Pasted image 20230608112257|600"><br>Vgs=Vg-Vs，用1，0的逻辑来看也可以的<br>P是G接入高电平不导通，相当于两个1不导通<br>N则是两个0不导通，G接入高电平导通</p><h2 id="GPIO的八种模式分析">GPIO的八种模式分析</h2><p><strong>从stm32f103参考手册中的章节可以找出来</strong><br>四个输入，四个输出<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939778.png" alt="Pasted image 20230608112801|600"></p><h3 id="GPIO工作模式：输入浮空">GPIO工作模式：输入浮空</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939779.png" alt="Pasted image 20230608112900|600"><br>外部高阻态的时候</p><h3 id="GPIO工作模式：输入上拉">GPIO工作模式：输入上拉</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939780.png" alt="Pasted image 20230608113146|600"></p><h3 id="GPIO工作模式：输入下拉">GPIO工作模式：输入下拉</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939781.png" alt="Pasted image 20230608113208|600"></p><h3 id="GPIO工作模式：模拟功能">GPIO工作模式：模拟功能</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939782.png" alt="Pasted image 20230608113310|600"></p><h3 id="GPIO工作模式：开漏输出">GPIO工作模式：开漏输出</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939783.png" alt="Pasted image 20230608113316|600"><br>P-MOS的G端一直高电平，一直不导通，N端受输出控制控制，ODR给0，则输出控制高（<font color="#ff0000">输出控制的地方相当于对信号进行了取反操作</font>），mos导通（<font color="#ff0000">把VSS的低电平输出出去了</font>），给1则输出低，mos不导通（形成高阻态，没有意义，但是看后面），这样让N-MOS开或者关，<font color="#ff0000">同时外面I/O引脚处有个上拉电阻（必须），那么则会输出上拉电阻处的高电平，高阻态则可忽略掉，让整个引脚的电压情况随着N-MOS的情况改变</font><br>相当于这样：<img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939784.png" alt="Pasted image 20230608191400|600"><br>f1是要自己搞外部上拉，其他的自带内部，可看前面的图<br>允许输入，ttl肖特基触发器接通了<br>ODR是输出数据寄存器，IDR就是上面输入的那个</p><h3 id="GPIO工作模式：开漏式复用功能">GPIO工作模式：开漏式复用功能</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939785.png" alt="Pasted image 20230608113411|600"><br>片上外设控制，仍让需要外部上拉</p><h3 id="GPIO工作模式：推挽输出">GPIO工作模式：推挽输出</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939786.png" alt="Pasted image 20230608113422|600"><br>与开漏有区别，两个mos分别在ODR 的0/1的时候作用</p><h3 id="GPIO工作模式：推挽式复用功能">GPIO工作模式：推挽式复用功能</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939787.png" alt="Pasted image 20230608113433|600"></p><h1>- Date:2023-06-08</h1><ul><li>Time:10:50</li><li>Subject:</li><li>Tags: #stm32 #GPIO<br>[[2023-06]]</li></ul><hr><h2 id="什么是GPIO">什么是GPIO</h2><p>General Purpose Input Output，即通用输入输出端口，简称GPIO<br>作用：负责采集外部器件的信息或者控制外部器件工作，即输入输出<br>例子：<img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939457.png" alt="Pasted image 20230608105342|600"></p><h2 id="STM32-GPIO简介">STM32 GPIO简介</h2><h3 id="GPIO特点">GPIO特点</h3><ol><li>不同型号，IO口数量可能不一样，可通过选型手册快速查询</li><li>快速翻转，每次翻转最快只需要两个时钟周期（F1最高速度可以到50Mhz）</li><li>每个IO口都可以做中断</li><li>支持8种工作模式</li></ol><h3 id="GPIO电器特性">GPIO电器特性</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939458.png" alt="Pasted image 20230608105512|600"><br>TTL端口：标识FT，5v-3.3v<br>为什么是-0.3和3.6，因为有保护二极管，钳位，有压降和压升</p><h3 id="GPIO引脚分布">GPIO引脚分布</h3><h4 id="STM32引脚类型：">STM32引脚类型：</h4><ol><li>电源引脚（v开头）、晶振引脚（低速标32，高速不确定）、复位引脚（nrst）、下载引脚、BOOT引脚（boot0 boot1）、GPIO引脚（p开头）</li></ol><h4 id="不同芯片引脚分布情况">不同芯片引脚分布情况</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939459.png" alt="Pasted image 20230608105642|600"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-cubemx</title>
      <link href="/posts/d231037d.html"/>
      <url>/posts/d231037d.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-06-04</h1><ul><li>Time:23:37</li><li>Subject: none</li><li>Tags: #stm32 #配置<br>[[2023-06]]</li></ul><hr><h1>STM32CubeMX简介</h1><ol><li>STM32CubeMX是ST开发的一款图形配置工具，可通过配置自动生成初始化代码</li><li>一个图形配置工具，搭配不同系列的STM32Cube固件包，即可支持不同系列的STM32芯片</li></ol><h1>新建STM32CubeMX工程步骤</h1><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939841.png" alt="Pasted image 20230604234829|600"></p><h2 id="一个小细节">一个小细节</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939842.png" alt="Pasted image 20230604234855|600"><br>选用basic，详细的配置看视频吧<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939843.png" alt="Pasted image 20230605143431|600"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-中断</title>
      <link href="/posts/cad4ed3.html"/>
      <url>/posts/cad4ed3.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-06-10</h1><ul><li>Time:09:07</li><li>Subject: none</li><li>Tags: #stm32 #中断<br>[[2023-06]]</li></ul><hr><h2 id="什么是中断">什么是中断</h2><p>打断CPU执行正常的程序，转而处理紧急程序，然后返回原暂停的程序继续运行，就叫中断<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938710.png" alt="Pasted image 20230610090837|600"></p><h3 id="中断的作用和意义">中断的作用和意义</h3><ol><li>实时控制：在确定时间内对相应事件作出响应，如：温度监控</li><li>故障处理：检测到故障，需要第一时间处理，如：电梯门夹人了</li><li>数据传输：不确定数据何时会来，如：串口数据接收<br>中断的意义：高效处理紧急程序，<font color="#ff0000">不会一直占用CPU资源</font></li></ol><h3 id="STM32-GPIO外部中断简图">STM32 GPIO外部中断简图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938711.png" alt="Pasted image 20230610091024|600"></p><h1>- Date:2023-06-10</h1><ul><li>Time:09:12</li><li>Subject: none</li><li>Tags: #stm32 #NVIC #中断<br>[[2023-06]]</li></ul><hr><h2 id="NVIC基本概念">NVIC基本概念</h2><p>Nested vectored interrupt controller，嵌套向量中断控制器，属于内核（M3/4/7）<br>NVIC支持：256个中断（16内核 + 240外部），支持：256个优先级，允许裁剪！<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938136.png" alt="Pasted image 20230610091507|600"></p><h3 id="什么是中断向量表？">什么是中断向量表？</h3><p>定义一块固定的内存，以4字节对齐，存放各个中断服务函数程序的首地址<br>中断向量表定义在启动文件，当发生中断，CPU会自动执行对应的中断服务函数<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938137.png" alt="Pasted image 20230610091612|600"></p><h2 id="NVIC相关寄存器介绍">NVIC相关寄存器介绍</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938138.png" alt="Pasted image 20230610092001|600"></p><h2 id="NVIC工作原理">NVIC工作原理</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938139.png" alt="Pasted image 20230610092200|600"></p><h2 id="STM32中断优先级基本概念">STM32中断优先级基本概念</h2><ol><li><font color="#ff0000">抢占优先级</font>(pre)：高抢占优先级可以打断正在执行的低抢占优先级中断（这个优先考虑）</li><li><font color="#ff0000">响应优先级</font>(sub)：(子优先级)当抢占优先级相同时，响应优先级高的先执行，但是不能<font color="#ff0000">互相打断</font>，就是不能在别人执行的时候插进去，按谁先的顺序</li><li>抢占和响应都相同的情况下，<font color="#ff0000">自然优先级</font>越高的，先执行</li><li>自然优先级：中断向量表的优先级</li><li>数值越小，表示优先级越高</li></ol><h2 id="STM32中断优先级分组">STM32中断优先级分组</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938140.png" alt="Pasted image 20230610110350|600"><br>几位表示有2的几次方个优先级可使用<br><font color="#ff0000">特别提示：一个工程中，一般只设置一次中断优先级分组。</font><br>参考：STM32F10xxx编程手册（英文版）.pdf，4.4.5节</p><h3 id="例子">例子</h3><p>假设分组为2<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938141.png" alt="Pasted image 20230610110730|600"><br>EXTI1和RTC可以打断：EXTI0和Systick的中断，获得优先执行！</p><h2 id="STM32-NVIC的使用">STM32 NVIC的使用</h2><h3 id="设置中断分组">设置中断分组</h3><p>寄存器：AIRCR[10:8]，<br>HAL_NVIC_SetPriorityGrouping</p><h3 id="设置中断优先级">设置中断优先级</h3><p>寄存器：IPRx bit[7:4]，<br>HAL_NVIC_SetPriority</p><h3 id="使能中断">使能中断</h3><p>寄存器：ISERx，<br>HAL_NVIC_EnableIRQ<br>特别提醒：例程中，中断分组已经在HAL_Init()函数中设置了分组2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);</span><br></pre></td></tr></table></figure><h2 id="EXTI">EXTI</h2><p>#EXTI</p><h3 id="基本概念">基本概念</h3><p>External(Extended) interrupt/event Controller，外部(扩展)中断事件控制器<br>包含20个产生事件/中断请求的边沿检测器，即总共：20条EXTI线（F1）</p><h4 id="中断和事件的理解：">中断和事件的理解：</h4><p>中断：要进入NVIC，有相应的中断服务函数，需要CPU处理<br>事件：不进入NVIC，仅用于内部硬件自动控制的，如：TIM、DMA、ADC</p><h4 id="EXTI支持的外部中断-事件请求">EXTI支持的外部中断/事件请求</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938142.png" alt="Pasted image 20230610114128|600"></p><h3 id="EXTI主要特性">EXTI主要特性</h3><p>F1/F4/F7系列<br>每条EXTI线都可以单独配置：选择类型（中断或者事件）、触发方式（上升沿，下降沿或者双边沿触发）、支持软件触发、开启/屏蔽、有挂起状态位</p><h3 id="EXTI工作原理（F1-F4-F7系列）">EXTI工作原理（F1/F4/F7系列）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938143.png" alt="Pasted image 20230610115021|600"><br>注：</p><ol><li>/20 是f1有20条exit线，虽然32位，但是只有20条有效<br>①，边沿检测，检测输入信号变换<br>②，软件触发，swier置1，那么是软件触发，此处是或门，一个1就能过，置0则硬件触发<br>③，中断屏蔽/清除，都置1才可到nvic（与门）<br>④，事件屏蔽，都置1，给外设产生事件（少用）<br>了解寄存器：</li><li>EXTI_FTSR 下降沿</li><li>EXTI_RTSR 上升沿</li><li>EXTI_IMR 中断屏蔽</li><li>EXTI_PR 挂起</li></ol><h2 id="EXTI和IO映射关系">EXTI和IO映射关系</h2><h3 id="AFIO简介（F1）">AFIO简介（F1）</h3><p>Alternate Function IO，即复用功能IO，主要用于重映射和外部中断映射配置</p><ol><li>调试io配置  AFIO_MAPR[26:24]，配置JTAG/SWD的开关状态</li><li>重映射配置 AFIO_MAPR，部分外设IO重映射配置</li><li>（重点）外部中断配置 AFIO_EXTICR1~4，配置EXTI中断线0~15对应具体哪个IO口<br>特别注意：配置AFIO寄存器之前要使能AFIO时钟，方法如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__HAL_RCC_AFIO_CLK_ENABLE();      对应RCC_APB2ENR寄存器 位<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="EXTI-与-IO对应关系">EXTI 与 IO对应关系</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938144.png" alt="Pasted image 20230610140831|600"><br>AFIO_EXTICR1的 EXTI0[3:0]位控制（4个位）（F1）<br>配置好一个，如PG0，其他的Px0用不上了，是一一对应关系的<br>SYSCFG_EXTICR1的 EXTI0[3:0]位控制（F4/F7/H7）<br>注：图上的一列0为引脚号，abc…为分组号，x可为abc…<br>Px0映射到EXTI0<br>Px1映射到EXTI1<br>…<br>Px14映射到EXTI14<br>Px15映射到EXTI15</p><h2 id="如何使用中断">如何使用中断</h2><h3 id="STM32-EXTI的配置步骤（外部中断）">STM32 EXTI的配置步骤（外部中断）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938145.png" alt="Pasted image 20230610153315|600"><br>其他外设可以直接进入EXTI</p><h3 id="STM32-EXTI的设置步骤（外部中断）">STM32 EXTI的设置步骤（外部中断）</h3><p>#配置</p><ol><li>使能GPIO时钟<ol><li>使能GPIO时钟</li></ol></li><li>设置GPIO输入模式<ol><li>上/下拉/浮空输入</li></ol></li><li>使能AFIO/SYSCFG时钟<ol><li>设置AFIO/SYSCFG时钟开启寄存器</li></ol></li><li>设置EXTI和IO对应关系<ol><li>选择PA~PK到底哪组IO对应EXTI输入线，AFIO_EXTICR/ SYSCFG_EXTICR</li></ol></li><li>设置EXTI屏蔽，上/下沿<ol><li>设置EXTI对应通道的屏蔽和上升沿/下降沿触发，IMR、 RTSR/FTSR</li></ol></li><li>设置NVIC<ol><li>分3步，见前面内容，即：设置优先级分组、设置优先级、使能中断</li></ol></li><li>设计中断服务函数<ol><li>编写对应中断的中断服务函数！清中断标志！<br>注意：步骤2 - 5  使用HAL_GPIO_Init<font color="#ff0000">一步到位</font></li></ol></li></ol><h3 id="STM32-EXTI的-font-color-ff0000-HAL-font-库设置步骤（外部中断）">STM32 EXTI的<font color="#ff0000">HAL</font>库设置步骤（外部中断）</h3><ol><li>使能GPIO时钟<ol><li>__ HAL_RCC_GPIOx_CLK_ENABLE</li></ol></li><li>GPIO/AFIO(SYSCFG)/EXTI<ol><li>HAL_GPIO_Init  ，一步到位</li></ol></li><li>设置中断分组<ol><li>HAL_NVIC_SetPriorityGrouping，此函数仅需设置一次！</li></ol></li><li>设置中断优先级<ol><li>HAL_NVIC_SetPriority</li></ol></li><li>使能中断<ol><li>HAL_NVIC_EnableIRQ</li></ol></li><li>设计中断服务函数<ol><li>EXTIx_IRQHandler，中断服务函数，清中断标志！<font color="#ff0000">得去.s 文件里面找</font></li><li>STM32仅有：EXTI0~4、EXTI9_5(这个指5-9只有一个，后面同理)、EXTI15_10，7个外部中断服务函数</li></ol></li></ol><h3 id="通用外设驱动模型（四步法）">通用外设驱动模型（四步法）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938146.png" alt="Pasted image 20230613104503|600"></p><h3 id="HAL库中断回调处理机制介绍">HAL库中断回调处理机制介绍</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938147.png" alt="Pasted image 20230613112318|600"><br>公用函数在gpio里面找，HAL_GPIO_EXTI_IRQHandler</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-时钟系统</title>
      <link href="/posts/6bd75491.html"/>
      <url>/posts/6bd75491.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-06-05</h1><ul><li>Time:14:21</li><li>Subject: none</li><li>Tags: #stm32 #时钟<br>[[2023-06]]</li></ul><hr><h2 id="什么是时钟">什么是时钟</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938780.png" alt="Pasted image 20230605142235|600"></p><ol><li>简单来说，时钟是具有周期性的脉冲信号，最常用的是占空比50%的方波</li><li>时钟是单片机的脉搏，搞懂时钟走向及关系，对单片机使用至关重要！</li></ol><h2 id="认识时钟树（F1）">认识时钟树（F1）</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938781.png" alt="Pasted image 20230605142506|600"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938782.png" alt="Pasted image 20230605142425|600"><br>L：low<br>S：speed<br>I：internal<br>E：external<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938783.png" alt="Pasted image 20230605142543|600"></p><h3 id="时钟树简图">时钟树简图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938784.png" alt="Pasted image 20230605142739|600"></p><ol><li>PLL：锁相环，倍频系数：2~3（PLLCLK）</li><li>HSE分频可以说/1或者/2，HSI分频/2，再来到PLL倍频</li><li>HCLK前分频也用1，保持72mhz</li><li>APB1则分频/2，<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938785.png" alt="Pasted image 20230605143203|600"></li><li>低速晶振</li></ol><h3 id="HAL库内体现">HAL库内体现</h3><ol><li>时钟源、锁相环：HAL_RCC_OscConfig()</li><li>系统时钟、总线：HAL_RCC_ClockConfig()</li><li>使能外设时钟：_ _ HAL_RCC_PPP_CLK_ENABLE()   是一个宏定义，打开外设时使用时</li><li>扩展外设时钟(RTC/ADC/USB)：HAL_RCCEx_PeriphCLKConfig()</li></ol><h3 id="STM32CubeMX时钟树（F103）">STM32CubeMX时钟树（F103）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938786.png" alt="Pasted image 20230605143431|600"></p><h1>- Date:2023-06-05</h1><ul><li>Time:15:01</li><li>Subject: none</li><li>Tags: #stm32 #配置 #时钟<br>[[2023-06]]</li></ul><hr><h2 id="系统时钟配置步骤">系统时钟配置步骤</h2><ol><li>配置HSE_VALUE<ol><li>告诉HAL库外部晶振频率，stm32xxxx_hal_conf.h</li></ol></li><li>调用SystemInit()函数（可选）<ol><li>在启动文件中调用， 在system_stm32xxxx.c定义</li></ol></li><li>选择时钟源，配置PLL<ol><li>通过HAL_RCC_OscConfig()函数设置</li></ol></li><li>选择系统时钟源，配置总线分频器<ol><li>通过HAL_RCC_ClockConfig()函数设置</li></ol></li><li>配置扩展外设时钟（可选）<ol><li>通过HAL_RCCEx_PeriphCLKConfig()函数设置<br>注：<br>3 + 4 + 5 = sys_stm32_clock_init()   //正点原子配置</li></ol></li></ol><h2 id="外设时钟使能和失能">外设时钟使能和失能</h2><p><font color="#ff0000">我们要使用某个外设，必需先使能该外设时钟！！！</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL库使能某个外设时钟的方法，如：</span><br><span class="line">__HAL_RCC_GPIOA_CLK_ENABLE();        <span class="comment">/* 使能 GPIOA 时钟 */</span></span><br><span class="line">HAL库禁止某个外设时钟的方法，如：</span><br><span class="line">__HAL_RCC_GPIOA_CLK_DISABLE();        <span class="comment">/* 禁止 GPIOA 时钟 */</span></span><br></pre></td></tr></table></figure><h2 id="sys-stm32-clock-init-函数（F1）">sys_stm32_clock_init 函数（F1）</h2><p>结合上一个md的图表来看，是对对应位的配置</p><h3 id="HAL-RCC-OscConfig-函数">HAL_RCC_OscConfig()函数</h3><p>返回值：HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span>  OscillatorType;   <span class="comment">/* 选择需要配置的振荡器 */</span>  </span><br><span class="line">  <span class="type">uint32_t</span>  HSEState;   <span class="comment">/* HSE 状态 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  HSEPredivValue;   <span class="comment">/* HSE 预分频值 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  LSEState;   <span class="comment">/* LSE 状态 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  HSIState;   <span class="comment">/* HSI状态 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  HSICalibrationValue;   <span class="comment">/* HSI 校准值 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  LSIState;   <span class="comment">/* LSI 状态 */</span></span><br><span class="line">  RCC_PLLInitTypeDef  PLL;   <span class="comment">/* PLL 结构体 */</span></span><br><span class="line">&#125;RCC_OscInitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span>  PLLState;   <span class="comment">/* PLL 状态 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  PLLSource;   <span class="comment">/* PLL 时钟源 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  PLLMUL;   <span class="comment">/* PLL 倍频系数 */</span></span><br><span class="line">&#125;RCC_PLLInitTypeDef;</span><br></pre></td></tr></table></figure><h3 id="HAL-RCC-ClockConfig-函数">HAL_RCC_ClockConfig()函数</h3><p>返回值：HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span>  ClockType;   <span class="comment">/* 要配置的时钟（SYSCLK/HCLK/PCLK1/PCLK2） */</span></span><br><span class="line">  <span class="type">uint32_t</span>  SYSCLKSource;   <span class="comment">/* 系统时钟源 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  AHBCLKDivider;   <span class="comment">/* AHB  时钟预分频系数 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  APB1CLKDivider;   <span class="comment">/* APB1 时钟预分频系数 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  APB2CLKDivider;   <span class="comment">/* APB2 时钟预分频系数 */</span></span><br><span class="line">&#125;RCC_ClkInitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> FLatency</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  FLASH_LATENCY_0   0x00000000U   <span class="comment">/* FLASH 0个等待周期 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  FLASH_LATENCY_1   FLASH_ACR_LATENCY_0   <span class="comment">/* FLASH 1个等待周期 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  FLASH_LATENCY_2   FLASH_ACR_LATENCY_1   <span class="comment">/* FLASH 2个等待周期 */</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-定时器</title>
      <link href="/posts/1ba7a976.html"/>
      <url>/posts/1ba7a976.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-07-18</h1><ul><li>Time:19:32</li><li>Subject: none</li><li>Tags: #stm32 #定时器<br>[[2023-07]]</li></ul><hr><h2 id="软件定时原理">软件定时原理</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938046.png" alt="Pasted image 20230718193416|500"></p><h2 id="定时器定时原理">定时器定时原理</h2><p>定时器核心就是计数器<br>使用精准的时基，通过硬件的方式，实现定时功能<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938047.png" alt="Pasted image 20230718193624|500"></p><h2 id="STM32定时器分类">STM32定时器分类</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938048.png" alt="Pasted image 20230718193851|500"></p><h2 id="定时器特性表">定时器特性表</h2><h3 id="F1">F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938049.png" alt="Pasted image 20230718193908|500"><br>8个定时器，可以计数0-65535数，</p><h2 id="STM32基本，通用，高级功能整体区">STM32基本，通用，高级功能整体区</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938050.png" alt="Pasted image 20230718194641|500"></p><h2 id="Date-2023-07-18">- Date:2023-07-18</h2><ul><li>Time:19:47</li><li>Subject: none</li><li>Tags: #stm32 #定时器<br>[[2023-07]]</li></ul><hr><h2 id="基本定时器简介（了解）">基本定时器简介（了解）</h2><ol><li>基本定时器 TIM6 TIM7</li><li>16位递增计数器（计数值：0~65535）</li><li>16位预分频器（分频系数：1~65536）<ol><li>因此设置为0的时候为1分频，1为2分频</li></ol></li><li>可用于触发DAC</li><li>在更新事件（计数器溢出）时，会产生中断/DMA请求</li></ol><h2 id="基本定时器框图（熟悉）">基本定时器框图（熟悉）</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938042.png" alt="Pasted image 20230718195107|500"><br>经过psc得到计数器的工作频率，来一个时钟就加一<br>溢出条件，计数到影子寄存器里面的数字，psc和自动重转载寄存器都有影子，不能直接访问影子，但是起作用的就是影子，得产生一个事件的时候会把重装载值放到影子里面<br>u事件：update，更新事件，可以产生中断和mda（需要配置，默认不产生），默认产生更新事件，将预装载的寄存器值（psc，自动重装载寄存器）加载到影子，然后起作用</p><h2 id="定时器计数模式及溢出条件（熟悉）">定时器计数模式及溢出条件（熟悉）</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938043.png" alt="Pasted image 20230718205238|500"></p><h3 id="实例">实例</h3><h3 id="递增模式">递增模式</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938044.png" alt="Pasted image 20230718222029|500"><br>psc=1，arr=36</p><h3 id="递减模式">递减模式</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938045.png" alt="Pasted image 20230718223659|500"></p><h3 id="中心对齐模式">中心对齐模式</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938046.png" alt="Pasted image 20230718223715|500"><br>psc=0，arr=6<br>CNT=ARR-1=5、CNT=1<br>类似斯密特触发器的感觉<br>递增时溢出，上溢<br>递减时溢出，下溢</p><h2 id="定时器中断实验相关寄存器（了解）">定时器中断实验相关寄存器（了解）</h2><h3 id="TIM6-和TIM7-控制寄存器-1-TIMx-CR1">TIM6 和TIM7 控制寄存器 1(TIMx_CR1)</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938047.png" alt="Pasted image 20230718233653|500"><br>没有缓存，直接就改（减少操作寄存器的误差，需要一些时间）<br>有缓存，当触发事件的时候才会更改</p><h3 id="TIM6-和TIM7-DMA-中断使能寄存器-TIMx-DIER">TIM6 和TIM7 DMA/中断使能寄存器(TIMx_DIER)</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938048.png" alt="Pasted image 20230718234437|500"><br>用于使能更新中断</p><h3 id="TIM6-和TIM7-状态寄存器-TIMx-SR">TIM6 和TIM7 状态寄存器(TIMx_SR)</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938049.png" alt="Pasted image 20230718234511|500"><br>用于判断是否发生了更新中断，由硬件置1，软件清零</p><h3 id="TIM6-和TIM7-计数器-TIMx-CNT">TIM6 和TIM7 计数器(TIMx_CNT)</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938050.png" alt="Pasted image 20230718234535|500"><br>计数器实时数值，可用于设置计时器初始值，范围：0~65535</p><h3 id="TIM6-和TIM7-预分频器-TIMx-PSC">TIM6 和TIM7 预分频器(TIMx_PSC)</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938051.png" alt="Pasted image 20230718234555|500"><br>用于设置预分频系数，范围：0~65535，实际预分频系数等于PSC+1</p><h3 id="TIM6-和TIM7-自动重装载寄存器-TIMx-ARR">TIM6 和TIM7 自动重装载寄存器(TIMx_ARR)</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938052.png" alt="Pasted image 20230718234613|500"><br>用于设置自动重装载值，范围：0~65535</p><h2 id="font-color-ff0000-定时器溢出时间计算方法（掌握）-font"><font color="#ff0000"> 定时器溢出时间计算方法（掌握）</font></h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938053.png" alt="Pasted image 20230718234751|500"><br>T<sub>out</sub>是定时器溢出时间<br>F<sub>t</sub>是定时器的时钟源频率（未分频）<br>ARR是自动重装载寄存器的值<br>PSC是预分频器寄存器的值</p><h2 id="定时器中断实验配置步骤（掌握）">定时器中断实验配置步骤（掌握）</h2><p>#配置</p><ol><li>配置定时器基础工作参数<ol><li>HAL_TIM_Base_Init()</li></ol></li><li>定时器基础MSP初始化<ol><li>HAL_TIM_Base_MspInit()     配置NVIC、CLOCK等</li></ol></li><li>使能更新中断并启动计数器<ol><li>HAL_TIM_Base_Start_IT()放在init里面</li></ol></li><li>设置优先级，使能中断（msp_init里面写）<ol><li>HAL_NVIC_SetPriority()、 HAL_NVIC_EnableIRQ()</li></ol></li><li>编写中断服务函数<ol><li>TIMx_IRQHandler()  (.s文件里面找到)等-&gt;HAL_TIM_IRQHandler()</li></ol></li><li>编写定时器更新中断回调函数<ol><li>HAL_TIM_PeriodElapsedCallback()（空函数，自己去重定义）<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938054.png" alt="Pasted image 20230719090532|500"></li></ol></li></ol><h3 id="关键结构体介绍">关键结构体介绍</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TIM_TypeDef *Instance;            <span class="comment">/* 外设寄存器基地址 */</span></span><br><span class="line">    TIM_Base_InitTypeDef Init;     <span class="comment">/* 定时器初始化结构体*/</span></span><br><span class="line">     ...</span><br><span class="line">&#125;TIM_HandleTypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> Prescaler;                      <span class="comment">/* 预分频系数PSC */</span></span><br><span class="line">    <span class="type">uint32_t</span> CounterMode;             <span class="comment">/* 计数模式(基本定时器无效) */</span></span><br><span class="line">    <span class="type">uint32_t</span> Period;                           <span class="comment">/* 自动重载值 ARR */</span></span><br><span class="line">    <span class="type">uint32_t</span> ClockDivision;             <span class="comment">/* 时钟分频因子（基本定时器无效） */</span></span><br><span class="line">    <span class="type">uint32_t</span> RepetitionCounter;   <span class="comment">/* 重复计数器寄存器的值（高级才用用） */</span></span><br><span class="line">    <span class="type">uint32_t</span> AutoReloadPreload; <span class="comment">/* 自动重载预装载使能 */</span></span><br><span class="line">&#125; TIM_Base_InitTypeDef;</span><br></pre></td></tr></table></figure><h2 id="编程实战：定时器中断实验（掌握）">编程实战：定时器中断实验（掌握）</h2><h1>- Date:2023-07-19</h1><ul><li>Time:10:06</li><li>Subject: none</li><li>Tags: #stm32#定时器<br>[[2023-07]]</li></ul><hr><h2 id="通用定时器简介">通用定时器简介</h2><ol><li>TIM2/TIM3 /TIM4 /TIM5</li><li>特性<ol><li>16位递增、递减、中 心对齐计数器（计数值：0~65535）</li><li>16位预分频器（分频系数：1~65536）</li><li>可用于触发DAC、ADC</li><li>在更新事件、触发事件、输入捕获、输出比较时，会产生中断/DMA请求</li><li>4个独立通道，可用于：输入捕获、输出比较、输出PWM、单脉冲模式</li><li>使用外部信号控制定时器且可实现多个定时器互连的同步电路（级联）</li><li>支持编码器和霍尔传感器电路等</li></ol></li><li></li></ol><h2 id="通用定时器框图">通用定时器框图</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938178.png" alt="Pasted image 20230719105107|500"><br>触发时可到itr0的地方作为其他时钟的时钟源（级联）<br>输入捕获可以用于测量脉冲时间<br>写入比较值，计数器的值和影子的比较后，产生比较事件occ1l（也会有比较中断）<br>左右两边的ch通道是分时复用</p><h2 id="计数器时钟源">计数器时钟源</h2><p>#时钟<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938179.png" alt="Pasted image 20230720095902|500"><br>通道一是双边沿检测，上升和下降沿都检测，检测两个<br>TI1FP1/2经过边沿检测器，只能选择上升或者下降的，记一个数<br>ITR用于级联，其他触发的事件进而作为时钟源<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938180.png" alt="Pasted image 20230720103046|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938181.png" alt="Pasted image 20230720103054|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938182.png" alt="Pasted image 20230720103103|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938183.png" alt="Pasted image 20230720103257|500"></p><h2 id="通用定时器PWM输出">通用定时器PWM输出</h2><p>#pwm</p><h3 id="通用定时器输出比较部分框图介绍">通用定时器输出比较部分框图介绍</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938184.png" alt="Pasted image 20230720111001|500"></p><h4 id="捕获-比较通道1的主电路—输出部分">捕获/比较通道1的主电路—输出部分</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938185.png" alt="Pasted image 20230720111039|500"></p><h4 id="捕获-比较通道的输出部分（通道1）">捕获/比较通道的输出部分（通道1）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938186.png" alt="Pasted image 20230720111101|500"><br>不同的通道，可以输出不同占空比的pwm波，可以配置某个io口为通道1/2/3/4的输出输入口，从而达到效果</p><h3 id="通用定时器输出PWM原理">通用定时器输出PWM原理</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938187.png" alt="Pasted image 20230720111133|500"><br>假设：递增计数模式<br>ARR：自动重装载寄存器的值<br>CCRx：捕获/比较寄存器x的值<br>当CNT &lt; CCRx，IO输出0<br>当CNT &gt;= CCRx，IO输出1<br><font color="#ff0000">PWM波周期或频率由ARR决定，PWM波占空比由CCRx决定</font></p><h3 id="PWM模式">PWM模式</h3><h4 id="PWM模式1">PWM模式1</h4><p>递增：CNT &lt; CCRx，输出有效电平<br>          CNT &gt;= CCRx，输出无效电平<br>递减：CNT &gt; CCRx，输出无效电平<br>          CNT &lt;= CCRx，输出有效电平</p><h4 id="PWM模式2">PWM模式2</h4><p>递增：CNT &lt; CCRx，输出无效电平<br>          CNT &gt;= CCRx，输出有效电平<br>递减：CNT &gt; CCRx，输出有效电平<br>          CNT &lt;= CCRx，输出无效电平<br><font color="#ff0000">注：有/无效状态由TIMx_CCER决定</font><br>CCxP=0：OCx高电平有效（默认）<br>CCxP=1：Ocx低电平有效</p><h4 id="坐标图">坐标图</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938188.png" alt="Pasted image 20230720111824|500"></p><h3 id="通用定时器PWM输出实验配置步骤">通用定时器PWM输出实验配置步骤</h3><p>#配置</p><ol><li>配置定时器基础工作参数，初始化函数内（自己定义一个函数，然后把下面的函数放里面）<ol><li>HAL_TIM_PWM_Init()</li></ol></li><li>定时器PWM输出MSP初始化<ol><li>HAL_TIM_PWM_MspInit()     配置NVIC、CLOCK、GPIO等</li></ol></li><li>配置PWM模式/比较值等（这个主要来看）在初始化函数里面写<ol><li>HAL_TIM_PWM_ConfigChannel()</li></ol></li><li>使能输出并启动计数器 在初始化函数里面写<ol><li>HAL_TIM_PWM_Start()</li></ol></li><li>修改比较值控制占空比(可选)<ol><li>__ HAL_TIM_SET_COMPARE()（宏）</li></ol></li><li>使能通道预装载(可选)<ol><li>__ HAL_TIM_ENABLE_OCxPRELOAD()（宏）<br>设置句柄，定义句柄钟的初始化结构体和基地址，看基本的定时器<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938189.png" alt="Pasted image 20230720112341|500"></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">uint32_t</span> OCMode;     <span class="comment">/* 输出比较模式选择 8钟 */</span></span><br><span class="line">   <span class="type">uint32_t</span> Pulse;               <span class="comment">/* 设置比较值 CCRX */</span></span><br><span class="line">   <span class="type">uint32_t</span> OCPolarity;       <span class="comment">/* 设置输出比较极性 CCXP*/</span></span><br><span class="line">   <span class="type">uint32_t</span> OCNPolarity;    <span class="comment">/* 设置互补输出比较极性(高级定时器才有tim1 8) */</span></span><br><span class="line">   <span class="type">uint32_t</span> OCFastMode;   <span class="comment">/* 使能或失能输出比较快速模式（少用） */</span></span><br><span class="line">   <span class="type">uint32_t</span> OCIdleState;     <span class="comment">/* 空闲状态下OC1输出 （高级里的互补输出）*/</span></span><br><span class="line">   <span class="type">uint32_t</span> OCNIdleState;  <span class="comment">/* 空闲状态下OC1N输出 （高级里的互补输出） */</span></span><br><span class="line">&#125; TIM_OC_InitTypeDef;</span><br></pre></td></tr></table></figure><h2 id="通用定时器输入捕获实验">通用定时器输入捕获实验</h2><h3 id="通用定时器输入捕获部分框图介绍（熟悉）">通用定时器输入捕获部分框图介绍（熟悉）</h3><h4 id="捕获-比较通道的输入部分（通道1）">捕获/比较通道的输入部分（通道1）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938190.png" alt="Pasted image 20230722113040|500"></p><h4 id="捕获-比较通道1的主电路—输入部分">捕获/比较通道1的主电路—输入部分</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938191.png" alt="Pasted image 20230722113108|500"><br>cc1g软件产生捕获<br>cc1e硬件检测捕获</p><h3 id="通用定时器输入捕获脉宽测量原理">通用定时器输入捕获脉宽测量原理</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938192.png" alt="Pasted image 20230722113631|500"><br>以捕获测量高电平脉宽为例，纵坐标为计数器的值，横坐标事件<br>假设：递增计数模式<br>ARR：自动重装载寄存器的值<br>CCRx1：t1时间点CCRx的值（设置为上升沿，吧检测到的时间的计数存到ccrx，接着清零，然后设置下降沿检测）<br>CCRx2：t2时间点CCRx的值<br><font color="#ff0000">高电平期间，计时器计数的个数：N * (ARR+1) + CCRx2</font><br>先算出计数频率是F<sub>t</sub>/（psc+1）再取倒数为记一个数的时间，然后乘以上面的总个数即可</p><h3 id="通用定时器输入捕获实验配置步骤">通用定时器输入捕获实验配置步骤</h3><p>#配置</p><ol><li>配置定时器基础工作参数（在gtim_timx_cap_chy_init里，需要提前配置定时器句柄，外部设置<ol><li>HAL_TIM_IC_Init()</li></ol></li><li>定时器输入捕获MSP初始化（重定义HAL_TIM_IC_MspInit<ol><li>HAL_TIM_IC_MspInit()     配置NVIC、CLOCK、GPIO等</li></ol></li><li>配置输入通道映射、捕获边沿等（在gtim_timx_cap_chy_init里，在内设置ic通道句柄<ol><li>HAL_TIM_IC_ConfigChannel()</li></ol></li><li>设置优先级，使能中断（在msp里面<ol><li>HAL_NVIC_SetPriority()、 HAL_NVIC_EnableIRQ()</li></ol></li><li>使能定时器更新中断（宏）（在自己定义的gtim_timx_cap_chy_init里<ol><li>__ HAL_TIM_ENABLE_IT()</li></ol></li><li>使能捕获、捕获中断及计数器（在gtim_timx_cap_chy_init<ol><li>HAL_TIM_IC_Start_IT()</li></ol></li><li>编写中断服务函数（r如TIM5_IRQHandler（.s里面找），再把它define为GTIM_TIMX_CAP_IRQHandler<ol><li>TIMx_IRQHandler()等  -&gt; HAL_TIM_IRQHandler()</li></ol></li><li>编写更新中断和捕获回调函数（重新定义下面两个<ol><li>HAL_TIM_PeriodElapsedCallback() HAL_TIM_IC_CaptureCallback()</li></ol></li></ol><h4 id="相关HAL库函数介绍">相关HAL库函数介绍</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938193.png" alt="Pasted image 20230722115254|500"></p><h4 id="关键结构体-HAL-TIM-IC-ConfigChannel">关键结构体(HAL_TIM_IC_ConfigChannel)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ICPolarity;    <span class="comment">/* 输入捕获触发方式选择，比如上升、下降沿捕获 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ICSelection; <span class="comment">/* 输入捕获选择，用于设置映射关系 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ICPrescaler; <span class="comment">/* 输入捕获分频系数(几次上升沿触发一次捕获事件) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ICFilter;         <span class="comment">/* 输入捕获滤波器设置 */</span></span><br><span class="line">&#125; TIM_IC_InitTypeDef;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-串口</title>
      <link href="/posts/7a29335c.html"/>
      <url>/posts/7a29335c.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-06-13</h1><ul><li>Time:14:38</li><li>Subject: none</li><li>Tags: #stm32 #通信<br>[[2023-06]]</li></ul><hr><h2 id="数据通信的基础概念">数据通信的基础概念</h2><h3 id="串行-并行通信">串行/并行通信</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937743.png" alt="Pasted image 20230613144010|500"></p><h3 id="单工-半双工-全双工通信">单工/半双工/全双工通信</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937744.png" alt="Pasted image 20230613144034|500"></p><h3 id="同步-异步通信">同步/异步通信</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937745.png" alt="Pasted image 20230613144049|500"></p><h3 id="波特率">波特率</h3><ol><li>比特率：每秒钟传送的比特数，单位bit/s</li><li>波特率：每秒钟传送的码元数，单位Baud</li><li>比特率 = 波特率 * log2 M ，M表示每个码元承载的信息量</li><li>二进制系统中，波特率数值上等于比特率</li></ol><h3 id="常见的串行通信接口">常见的串行通信接口</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937746.png" alt="Pasted image 20230613144144|500"></p><h2 id="串口-RS-232">串口(RS-232)</h2><p>#串口</p><h3 id="什么是串口">什么是串口</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937747.png" alt="Pasted image 20230613144336|500"></p><h3 id="RS-232电平与COMS-TTL电平对比">RS-232电平与COMS/TTL电平对比</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937748.png" alt="Pasted image 20230613144510|500"></p><h3 id="设备间的RS-232通信示意图">设备间的RS-232通信示意图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937749.png" alt="Pasted image 20230613144531|500"></p><h3 id="STM32串口与电脑USB口通信示意图">STM32串口与电脑USB口通信示意图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937750.png" alt="Pasted image 20230613144651|500"></p><h3 id="RS-232异步通信协议">RS-232异步通信协议</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937751.png" alt="Pasted image 20230613144726|500"><br>lsb:最低有效位，位0<br>msb:最高有效位，位7</p><h2 id="STM32的USART">STM32的USART</h2><p>#usart</p><h3 id="STM32的USART简介">STM32的USART简介</h3><p>Universal synchronous asynchronous receiver transmitter，通用同步异步收发器usart<br>Universal asynchronous receiver transmitter，通用异步收发器uart<br>USART/UART都可以与外部设备进行全双工异步通信<br>USART，我们常用的也是异步通信</p><h3 id="STM32的USART主要特征">STM32的USART主要特征</h3><ol><li>全双工异步通信</li><li>单线半双工通信</li><li>单独的发送器和接收器使能位</li><li>可配置使用DMA的多缓冲器通信</li><li>多个带标志的中断源</li></ol><blockquote><p>参考：STM32xxxx参考手册（中文版）.pdf    USART相关章节</p></blockquote><h3 id="如何快速查看STM32某个外设的数量及其对应的引脚">如何快速查看STM32某个外设的数量及其对应的引脚?</h3><blockquote><p>参考：ST MCU 最新选型手册.pdf<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937752.png" alt="Pasted image 20230613145116|500"></p></blockquote><h3 id="STM32F1-F4-F7的USART框图">STM32F1/F4/F7的USART框图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937753.png" alt="Pasted image 20230613145320|500"><br>需要了解的点：<br>①，发送/接收数据的流程<br>②，相关寄存器作用<br>③，设置波特率</p><h3 id="STM32F1-F4-F7-H7的USART框图简化版">STM32F1/F4/F7/H7的USART框图简化版</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937754.png" alt="Pasted image 20230613145804|500"></p><h3 id="设置USART-UART波特率（F1）">设置USART/UART波特率（F1）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937755.png" alt="Pasted image 20230613151937|500"><br>波特率计算公式：baud=f<sub>ck</sub> /(16∗USARTDIV)，算出usartdiv就可以算出上面的div_mantissa(整数部分)，fraction就是小数部分，也可以算出来，然后写道寄存器里面去<br>其中&quot;f<sub>ck</sub>&quot;是串口的时钟，如：USART1的时钟是PCLK2,其他串口都是PCLK1（上图）</p><h3 id="如何使用寄存器操作的方式设置波特率-USART1为例">如何使用寄存器操作的方式设置波特率 - USART1为例</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937756.png" alt="Pasted image 20230615212901|500"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> mantissa;</span><br><span class="line"><span class="type">uint16_t</span> fraction;</span><br><span class="line">mantissa=<span class="number">39</span>;</span><br><span class="line">fraction=<span class="number">0.0625</span>*<span class="number">16</span>+<span class="number">0.5</span>=<span class="number">0x01</span>;          <span class="comment">/* USARTDIV = DIV_Mantissa + (DIV_Fraction/16) */</span></span><br><span class="line">USART1-&gt;BRR = (mantissa &lt;&lt; <span class="number">4</span>) + fraction;</span><br></pre></td></tr></table></figure><h3 id="波特率设置通用公式推演（F1）">波特率设置通用公式推演（F1）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937757.png" alt="Pasted image 20230615213037|500"></p><h3 id="USART寄存器介绍（F1）可略">USART寄存器介绍（F1）可略</h3><h4 id="控制寄存器1（CR1）">控制寄存器1（CR1）</h4><p>该寄存器需要完成的配置：<br>位13：使能USART<br>位12：配置8个数据位<br>位10：禁止检验控制<br>位5：使能接收缓冲区非空中断<br>位3：使能发送<br>位2：使能接收</p><h4 id="控制寄存器2（CR2）">控制寄存器2（CR2）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937758.png" alt="Pasted image 20230615213352|500"><br>该寄存器需要完成的配置：配置1个停止位</p><h4 id="控制寄存器3（CR3）">控制寄存器3（CR3）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937759.png" alt="Pasted image 20230615213533|500"><br>该寄存器需要完成的配置：配置不选择半双工模式</p><h4 id="数据寄存器（DR）">数据寄存器（DR）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937760.png" alt="Pasted image 20230615213555|500"><br>设置好控制和波特率寄存器后，往该寄存器写入数据即可发送，接收数据则读该寄存器</p><h4 id="状态寄存器（SR）">状态寄存器（SR）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937761.png" alt="Pasted image 20230615213623|500"><br>根据TC位可以知道能否发数据，根据RXNE位知道是否收到数据</p><h3 id="需要配置的时序总结（需要查看进行配置）">需要配置的时序总结（需要查看进行配置）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937762.png" alt="Pasted image 20230615213650|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937763.png" alt="Pasted image 20230615213658|500"></p><h3 id="HAL库外设初始化MSP回调机制（了解）">HAL库外设初始化MSP回调机制（了解）</h3><p>#MSP<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937764.png" alt="Pasted image 20230615214018|500"></p><h4 id="HAL库外设初始化MSP回调机制-USART为例">HAL库外设初始化MSP回调机制- USART为例</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937765.png" alt="Pasted image 20230615214206|500"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_MspInit</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef gpio_init_struct;</span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)                <span class="comment">/* 如果是串口1，进行串口1 MSP初始化 */</span></span><br><span class="line">    &#123;</span><br><span class="line">  <span class="comment">/* （1）使能USART1和对应IO时钟，（2）初始化IO，（3）使能USART1中断，设置优先级 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HAL库中断回调机制（了解）">HAL库中断回调机制（了解）</h3><p>#IRQ<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937766.png" alt="Pasted image 20230615214309|500"><br>中断服务函数在.s里面找到</p><h4 id="HAL库中断回调机制-USART为例（F1）">HAL库中断回调机制 - USART为例（F1）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937767.png" alt="Pasted image 20230615214329|500"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UART中断回调函数：</span><br><span class="line">HAL_UART_TxCpltCallback();                      <span class="comment">/* 发送完成回调函数 */</span></span><br><span class="line">HAL_UART_TxHalfCpltCallback();                  <span class="comment">/* 半发送完成回调函数 */</span></span><br><span class="line">HAL_UART_RxCpltCallback();                      <span class="comment">/* 接收完成回调函数（这个多用） */</span></span><br><span class="line">HAL_UART_RxHalfCpltCallback();                  <span class="comment">/* 半接收完成回调函数 */</span></span><br><span class="line">HAL_UART_ErrorCallback();                       <span class="comment">/* UART错误回调函数 */</span></span><br><span class="line">HAL_UART_AbortCpltCallback();                   <span class="comment">/* UART中止回调函数 */</span></span><br><span class="line">HAL_UART_AbortTransmitCpltCallback();           <span class="comment">/* UART发送中止回调函数 */</span></span><br><span class="line">HAL_UART_AbortReceiveCpltCallback();            <span class="comment">/* UART接收中止回调函数 */</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937768.png" alt="Pasted image 20230615214502|500"></p><h1>- Date:2023-06-18</h1><ul><li>Time:20:26</li><li>Subject: none</li><li>Tags: #stm32 #配置<br>[[2023-06]]</li></ul><hr><h2 id="USART-UART异步通信配置步骤（掌握）">USART/UART异步通信配置步骤（掌握）</h2><ol><li>配置串口工作参数<br>2. HAL_UART_Init()</li><li>串口底层初始化<ol><li>HAL_UART_MspInit()    配置GPIO、NVIC、CLOCK等 <font color="#ff0000">上一个笔记里面有</font></li></ol></li><li>开启串口异步接收中断<ol><li>HAL_UART_Receive_IT()</li></ol></li><li>设置优先级，使能中断<ol><li>HAL_NVIC_SetPriority()、 HAL_NVIC_EnableIRQ()</li></ol></li><li>编写中断服务函数<ol><li>USARTx_IRQHandler()、 UARTx_IRQHandler()</li></ol></li><li>串口数据发送<ol><li>USART_DR， HAL_UART_Transmit()</li></ol></li></ol><h3 id="HAL库相关函数介绍">HAL库相关函数介绍</h3><ol><li>HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef * huart)<ol><li>handletypedef命名的是句柄<br>关键结构体（F1）：</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>    <span class="type">uint32_t</span> BaudRate;   <span class="comment">/* 波特率 */</span></span><br><span class="line">     <span class="type">uint32_t</span> WordLength;   <span class="comment">/* 字长 */</span></span><br><span class="line">     <span class="type">uint32_t</span> StopBits;   <span class="comment">/* 停止位 */</span></span><br><span class="line">     <span class="type">uint32_t</span> Parity;   <span class="comment">/* 奇偶校验位 */</span></span><br><span class="line">     <span class="type">uint32_t</span> Mode;   <span class="comment">/* UART 模式 */</span></span><br><span class="line">     <span class="type">uint32_t</span> HwFlowCtl;   <span class="comment">/* 硬件流设置 */</span></span><br><span class="line">     <span class="type">uint32_t</span> OverSampling;   <span class="comment">/* 过采样设置 */</span></span><br><span class="line">&#125;UART_InitTypeDef</span><br></pre></td></tr></table></figure><ol start="2"><li>HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef * huart , uint8_t * pData , uint16_t Size)<ol><li>作用：以中断的方式接收指定字节的数据</li><li>形参 1 是 UART_HandleTypeDef 结构体类型指针变量</li><li>形参 2 是指向接收数据缓冲区</li><li>形参 3 是要接收的数据大小，以字节为单位</li></ol></li><li>HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef * huart,  uint8_t * pData, uint16_t Size, uint32_t Timeout)<ol><li>作用：以阻塞的方式发送指定字节的数据(必须发送完才能接受，和上面有区别)</li><li>形参 1 ：UART_HandleTypeDef 结构体类型指针变量</li><li>形参 2：指向要发送的数据地址</li><li>形参 3：要发送的数据大小，以字节为单位</li><li>形参 4：设置的超时时间，以ms单位</li></ol></li></ol><h2 id="IO引脚复用功能（掌握）">IO引脚复用功能（掌握）</h2><p>#复用</p><h3 id="何为复用？">何为复用？</h3><ol><li>通用：IO端口的输入或输出是由GPIO外设控制，我们称之为通用</li><li>复用：IO端口的输入或输出是由其它非GPIO外设控制，我们称之为复用</li></ol><h3 id="STM32F1的IO引脚复用">STM32F1的IO引脚复用</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938307.png" alt="Pasted image 20230618205358|500"><br>参考：STM32F103ZET6（中文版）.pdf     第3小节  引脚定义</p><h3 id="IO引脚复用映射示意图">IO引脚复用映射示意图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938308.png" alt="Pasted image 20230618205911|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938309.png" alt="Pasted image 20230618205915|500"><br>温馨提示：IO引脚与AF(0~15)具体定义关系，需要参考对应的芯片数据手册</p><h4 id="GPIO-复用功能低位寄存器-AFRL">GPIO 复用功能低位寄存器(AFRL)</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938310.png" alt="Pasted image 20230618210110|500"></p><h4 id="GPIO-复用功能高位寄存器-AFRH">GPIO 复用功能高位寄存器(AFRH)</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938311.png" alt="Pasted image 20230618210120|500"><br>摘自：STM32F4xx参考手册_V4（中文版）.pdf，7.4.9节 7.4.10</p><h2 id="实验">实验</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>51单片机知识归档</title>
      <link href="/posts/2e5210af.html"/>
      <url>/posts/2e5210af.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2023-05-22</h1><ul><li>Time:22:17</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-05]]</li></ul><hr><h2 id="直流电机介绍">直流电机介绍</h2><ol><li>直流电机是一种将电能转换为机械能的装置。一般的直流电机有两个电极，当电极正接时，电机正转，当电极反接时，电机反转</li><li>直流电机主要由永磁体（定子）、线圈（转子）和换向器组成</li><li>除直流电机外，常见的电机还有步进电机、舵机、无刷电机、空心杯电机等</li></ol><h2 id="电机驱动电路">电机驱动电路</h2><ol><li>大功率直接驱动<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937135.png" alt="Pasted image 20230521222110|500"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937136.png" alt="Pasted image 20230521222117|500"></li></ol></li><li>H 桥驱动<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937137.png" alt="Pasted image 20230521222246|500"></li><li>可以正反转动</li></ol></li></ol><h2 id="PWM">PWM</h2><ol><li>PWM（Pulse Width Modulation）即脉冲宽度调制，在具有惯性的系统中，可以通过对一系列<font color="#ff0000">脉冲的宽度进行调制</font>，来<font color="#ff0000">等效</font>地获得所需要的<font color="#ff0000">模拟参量</font>，常应用于电机控速、开关电源等领域</li><li>PWM 重要参数：<ol><li>频率 = 1 / TS            占空比 = TON（打开的时间） / TS（总时间）           精度 = 占空比变化步距（一格一格的调整，格子越小月细致）</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937138.png" alt="Pasted image 20230521222713|500"></li><li>紫线为等效的线</li></ol></li><li>产生 pwm 方法<ol><li>模型结构<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937139.png" alt="Pasted image 20230521224437|500"></li></ol></li><li>波形<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937140.png" alt="Pasted image 20230521224452|500"></li></ol></li></ol></li></ol><h1>- Date:2023-04-29</h1><ul><li>Time:12:52</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><p>51 自带 uart（Universal Asynchronous Receiver Transmitter，通用异步收发器）</p><h2 id="电平标准">电平标准</h2><p>电平标准是数据 1 和数据 0 的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：<br>TTL 电平：+5V 表示 1，0V 表示 0<br>RS232 电平：-3~-15V 表示 1，+3~+15V 表示 0<br>RS485 电平：两线压差+2~+6V 表示 1，-2~-6V 表示 0（差分信号）</p><h2 id="电路">电路</h2><ol><li>两端的设备的 TXD（发送）和 RXD（接受）交叉连接，单向可以一条，vcc，gnd 必须接</li><li>点平标准不一样的时候要加转换芯片</li></ol><h2 id="通信接口比较">通信接口比较</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030934282.png" alt="Pasted image 20230429110126|500"></li></ol><h2 id="相关术语">相关术语</h2><p>全双工：通信双方可以在同一时刻互相传输数据<br>半双工：通信双方可以互相传输数据，但必须分时复用一根数据线<br>单工：通信只能有一方发送到另一方，不能反向传输<br>异步：通信双方各自约定通信速率<br>同步：通信双方靠一根时钟线来约定通信速率，有时钟线<br>总线：连接各个设备的数据传输线路（类似于一条马路，把路边各住户连接起来，使住户可以相互交流）</p><h2 id="51-单片机的-uart">51 单片机的 uart</h2><ol><li>我们的低端单片机只能一个</li><li>四个工作模式<ol><li>模式 0：同步移位寄存器</li><li>模式 1：8 位 UART，波特率可变（常用）</li><li>模式 2：9 位 UART，波特率固定</li><li>模式 3：9 位 UART，波特率可变</li></ol></li><li><strong>串口模式图</strong><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030934283.png" alt="Pasted image 20230429124914|400"></li><li>SBUF：串口数据缓存寄存器，物理上是两个独立的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器，读操作时，读出的是接收寄存器</li></ol></li><li><strong>相关寄存器</strong><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030934284.png" alt="Pasted image 20230429125026|400"></li></ol></li></ol><h1>- Date:2023-04-29</h1><ul><li>Time:12:52</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><h2 id="介绍">介绍</h2><p>单片机，英文 Micro Controller Unit，简称 MCU<br>里面有电脑的各个组成部分，有 CPU、RAM、ROM、定时器、中断系统、通讯接口，可以构成一个计算机系统，一个袖珍计算机，但是它小，功能实现比较完整<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937223.png" alt="Pasted image 20230423211439|500"><br>其可以完成的任务：信息采集（依靠传感器）、处理（依靠 CPU）和硬件设备（例如电机，LED 等）的控制，在我们比赛的时候处处都快体现（如机械臂，麦克纳姆轮）<br>我当前学的用的是 51 单片机，也就是 stc51 单片机，stc 是公司，<br>stm32 单片机 比赛用的</p><h2 id="常见术语">常见术语</h2><ol><li>LED 灯</li><li>引脚 P1_0 P1 gnd vcc 对应有功能</li><li>串口 与电脑进行通讯，电脑也参与到工作来</li><li>定时器，用于计时系统，隔一段时间进行操作<ol><li>中断系统：为了应急事件设计的，先处理应急的，暂停其他的，再回来</li><li>寄存器：连接软硬件的媒介，单片机的放在 ram，然后 ram 后面接着导线，寄存器相当于一个复杂机器的“操作按钮”，软件上设置了，实际的硬件电路能发生相应的功能</li></ol></li><li>keil4 keil5 用来写代码的平台</li><li>c 语言，单片机的程序语言</li></ol><h1>- Date:2023-04-29</h1><ul><li>Time:12:51</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><h2 id="定时器框架">定时器框架</h2><p>时钟（提供计数单元的时钟脉冲）-&gt; 计数单元（时钟计数）-&gt;中断系统（产生中断，执行定时任务）</p><h2 id="工作模式">工作模式</h2><ol><li>模式 0：13 位定时器<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937963.png" alt="Pasted image 20230423155323|500"><br>相当于一个计数器</li><li>模式 1：16 位定时器/计数器（常用）<ol><li>sysclk ：系统时钟，也就是晶振周期，</li><li>12T 12 分频，1 微秒，这样记一次数</li><li>6T 类似</li><li>C/T=0 count 选择上下的模式</li></ol></li></ol><h2 id="中断系统">中断系统</h2><ol><li>发生紧急事情，先暂停其他处理紧急，然后再回去，cpu 优先相依那个中断源请求问题，所以中断源就有优先级别</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937964.png" alt="Pasted image 20230423161243|500"></li><li>相当于可以同时进行两个任务（断点）</li></ol><h2 id="定时器相关寄存器">定时器相关寄存器</h2><ol><li>定时器/计数器 0 和 1 的相关寄存器<ol><li>特殊的 ram 存储器，每个寄存器连着导线，控制电路连接的方式</li><li>可位寻址，可以单独设置；</li><li>不可位寻址，统一设置；</li></ol></li></ol><h2 id="设置">设置</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937965.png" alt="Pasted image 20230521224952|500"></p><h2 id="驱动电路">驱动电路</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937553.png" alt="Pasted image 20230501103127|500"></li></ol><h2 id="ULN2003">ULN2003</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937554.png" alt="Pasted image 20230501103255|500"></li><li>增大驱动能力</li><li>与门 或门 非门 ，如下：<img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937555.png" alt="Pasted image 20230501103511|500"></li></ol><h2 id="乐理部分">乐理部分</h2><h1>- Date:2023-05-18</h1><ul><li>Time:23:53</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-05]]</li></ul><hr><h2 id="AT24C02">AT24C02</h2><ol><li>AT24C02 是一种可以实现掉电不丢失的存储器，可用于保存单片机运行时想要永久保存的数据信息</li><li>存储介质：E2PROM</li></ol><h2 id="内部结构框图">内部结构框图</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937651.png" alt="Pasted image 20230519000430|500"></p><ol><li>eeprom 的左边 x DEC 就是 decoder 编码器；下面就是输出端；上面用于擦除</li><li>data word 地址寄存器</li></ol><h2 id="I2C-总线（i-方-c）">I2C 总线（i 方 c）</h2><ol><li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）半双工通信</li><li>同步 半双工 带数据应答</li><li>通用的 I2C 总线，可以使各种设备的通信标准统一</li><li>I2C 总线（Inter IC BUS）是由 Philips 公司开发的一种通用数据总线</li></ol><h2 id="I2C-电路规范">I2C 电路规范</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937652.png" alt="Pasted image 20230519224809|500"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937653.png" alt="Pasted image 20230519224814|500"></li><li>所有 I2C 设备的 SCL 连在一起，SDA 连在一起</li><li>设备的 SCL 和 SDA 均要配置成开漏输出模式</li><li>SCL 和 SDA 各添加一个上拉电阻，阻值一般为 4.7KΩ 左右</li><li>开漏输出和上拉电阻的共同作用实现了“线与”的功能，<font color="#ff0000">此设计主要是为了解决多机通信互相干扰的问题</font></li></ol><h2 id="I2C-时序结构">I2C 时序结构</h2><ol><li>起始条件：<font color="#ff0000">SCL 高电平期间，SDA 从高电平切换到低电平</font><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937654.png" alt="Pasted image 20230519230113|500"></li></ol></li><li>终止条件：<font color="#ff0000">SCL 高电平期间，SDA 从低电平切换到高电平</font><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937655.png" alt="Pasted image 20230519230123|500"></li></ol></li><li>发送一个字节：SCL 低电平期间，<font color="#ff0000">主机</font>将数据位依次放到 SDA 线上（高位在前），然后拉高 SCL，从机将在 SCL 高电平期间读取数据位(读取 b7 下面的两个脉冲)，所以 SCL 高电平期间 SDA 不允许有数据变化（方框内的下面两个脉冲得保持不变），依次循环上述过程 8 次(b7-b0)，即可发送一个字节<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937656.png" alt="Pasted image 20230519230412|500"></li></ol></li><li>接收一个字节：SCL 低电平期间，<font color="#ff0000">从机</font>将数据位依次放到 SDA 线上（高位在前），然后拉高 SCL，<font color="#ff0000">主机将在 SCL 高电平期间读取数据位</font>，所以 SCL 高电平期间 SDA 不允许有数据变化，依次循环上述过程 8 次，即可接收一个字节（主机在接收之前，需要释放 SDA，把控制权交给从机）紫色是从机控制的时候<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937657.png" alt="Pasted image 20230519233248|500"></li></ol></li><li>发送应答(SA)：在接收完一个字节之后，主机在下一个时钟发送一位数据，<font color="#ff0000">数据 0 表示应答，数据 1 表示非应答</font>（ACK 就是应答）</li><li>接收应答(RA)：在发送完一个字节之后，主机在下一个时钟接收一位数据，判断从机是否应答，<font color="#ff0000">数据 0 表示应答，数据 1 表示非应答</font>（主机在接收之前，需要<font color="#ff0000">释放 SDA，也就是 sda 置高电平，控制权交给从机</font>）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937658.png" alt="Pasted image 20230519233803|500"></li></ol></li></ol><h2 id="I2C-数据帧">I2C 数据帧</h2><ol><li>发送一帧数据<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937659.png" alt="Pasted image 20230519234146|500"></li><li>a6-3 在这个芯片规定为 1010 无法改变（相当于身份）后三位可以见到在原理图，都是接地的，为 0，最后一位决定功能，带横线接 gnd 起作用</li><li><font color="#ff0000">向谁发什么</font></li></ol></li><li>接受一帧数据<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937660.png" alt="Pasted image 20230519235731|500"></li><li><font color="#ff0000">向谁收什么</font></li></ol></li><li>先发送再接收数据帧（复合格式）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937661.png" alt="Pasted image 20230519235841|500"></li><li>先说（发）再收取数据，对于传感器来说不必要，但是对于其他的，主机给了什么指令，就让从机回复些什么东西；实现的是 <font color="#ff0000">向谁收指定的什么</font></li></ol></li><li>字节写<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937662.png" alt="Pasted image 20230520000310|500"></li><li>在 WORD ADDRESS（字地址）处写入数据 DATA</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937663.png" alt="Pasted image 20230520000838|500"></li><li>手册上的时序，可以参照思考对照一下，下面也是</li></ol></li><li>随机读<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937664.png" alt="Pasted image 20230520000337|500"></li><li>读出在 WORD ADDRESS 处的数据 DATA</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937665.png" alt="Pasted image 20230520000827|500"></li></ol></li><li><font color="#ff0000">注</font>：AT24C02 的固定地址为 1010，可配置地址本开发板上为 000（原理图中的 a0-a2），所以 SLAVE ADDRESS+W 为 0xA0 (Write 接地起作用)，SLAVE ADDRESS+R 为 0xA1（Read 接高电平起作用）</li></ol><h1>- Date:2023-04-29</h1><ul><li>Time:17:43</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><p>RTC(Real Time Clock)：实时时钟，是一种集成电路，通常称为时钟芯片</p><h2 id="电路-2">电路</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937877.png" alt="Pasted image 20230429203500|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937878.png" alt="Pasted image 20230429203524|500"></p><h2 id="寄存器">寄存器</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937879.png" alt="Pasted image 20230429204346|500"></p><ol><li>前两列命令字的结果，命令是什么，就是上面<font color="#ff0000">对</font><font color="#ff0000">应</font>的功能</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937880.png" alt="Pasted image 20230429205534|500"></li></ol><h2 id="时序定义">时序定义</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937881.png" alt="Pasted image 20230429210957|500"></li><li>第一位读取 write 还是 read，要是 read，则就把后面的那一段作为读取，从时钟芯片读取，write 就是下面的第二段，把它写入到里面去</li><li>一个时钟周期是一系列的上升沿伴随下降沿.要输入数据在时钟的上升沿数据必须有效，而 且在下降沿要输出数据位.如果 CE 输入为低电平,则所有数据传输终止,并且 I/O 口成高阻 抗状态.图 4 显示了数据传输. 在上电时, CE 必须为逻辑 0 直到 VCC 大于 2v，同样，SCLK 必须为逻辑 0 当 CE 变成逻辑 1 状态.</li></ol><h2 id="bcd-码">bcd 码</h2><ol><li>用 4 位二进制数来表示 1 位十进制数</li><li>BCD 码转十进制：DEC=BCD/16 * 10+BCD%16; （2 位 BCD）</li><li>十进制转 BCD 码：BCD=DEC/10 * 16+DEC%10; （2 位 BCD）</li><li>在十六进制中的体现：0x13 表示 13，0x85 表示 85，0x1A 不合法</li></ol><h1>- Date:2023-04-29</h1><ul><li>Time:14:34</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><ol><li><strong>显示原理</strong><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937218.png" alt="Pasted image 20230429143429|500"></li></ol><h2 id="74HC595">74HC595</h2><ol><li>74HC595 是串行输入并行输出的移位寄存器，可用 3 根线输入串行数据，8 根线输出并行数据，多片级联后，可输出 16 位、24 位、32 位等，常用于 IO 口扩展。</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937219.png" alt="Pasted image 20230429145026|500"></li><li>SER: 输入数据，serclk：移动位置，一层层往下，上面补充</li><li>先最上面 1 下一格子，然后最上面 0，现在 1 在第二行，然后两个再下沿，补第一层</li><li>qh‘ 放到下一个芯片的寄存器里面（当 8 位满了之后）</li><li>低电平工作</li></ol><h2 id="srf-sbit">srf sbit</h2><ol><li>sfr（special function register）：<ol><li>特殊功能寄存器声明 例：sfr P0 = 0x80; <font color="#ff0000">声明 P0 口寄存器，物理地址为 0x80</font></li></ol></li><li>sbit（special bit）： 2. 特殊位声明例：sbit P0_1 = 0x81;    或     sbit P0_1 = P0^1; <font color="#ff0000"> 声明 P0 寄存器的第 1 位</font></li><li>可位寻址/不可位寻址：在单片机系统中，操作任意寄存器或者某一位的数据时，必须给出其物理地址，又因为一个寄存器里有 8 位，所以位的数量是寄存器数量的 8 倍，单片机无法对所有位进行编码，故每 8 个寄存器中，只有一个是可以位寻址的。对不可位寻址的寄存器，若要只操作其中一位而不影响其它位时，可用“&amp;=”、“|=”、“^=”的方法进行位操作</li></ol><h2 id="代码习惯">代码习惯</h2><ol><li>函数和变量命名建议小写开头，结构体建议大写开头，常量建议全大写</li></ol><h2 id="术语">术语</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937220.png" alt="Pasted image 20230429175356|500"></p><ol><li>首先要知道这个: <strong>加横线一般表示这个接口低电平工作</strong></li><li>OE:<br>open enable 直译(打开使能)<br>说人话(打开此芯片的开关)<br>带上横线的意思用人话说就是(输入低电平这个芯片才能工作)</li><li>SRCLR:<br>serial clear 直译(连续清零/串行清零)<br>说人话(这个芯片数据清空)<br>带上横线的意思用人话说就是(输入低电平这个芯片里面的数据清空)<br>所以说你要用的话得接个高电平才能工作(毕竟你不能让芯片一直清空你准备的数据信号是不是)</li><li>SER: serial 直译(连续/串行)<br>说人话解释(这个接口就是商场大门,排成一条长队的数据就从这个接口进)<br>这个接数据输入的 IO 口</li><li>SRCLK : serial clock 直译(连续时钟/串行时钟)<br>说人话解释(这个就是可以通行的绿色标志,数据从 SER 口排着队,这里大喊一声(具体操作就是给他一个高点平),贵客一位! 然后数据就从这里进一位)<br>感觉和水龙头也挺像的,开一下关一下,水和数据似得.打开走一点,打开走一点,打开走一点…<br>要用的话就是 给高电平一下 走一个位(bit) 给高电平一下走一个位(bit)</li><li>RCLK: receive clock 直译(接收时钟)<br>说人话解释(连着上面的说了啊,一个一个顾客进来凑够了一桌子 8 个人,不能让他们站着啊,你得让他们坐下来,这个就是请坐,你们一块坐下吧)<br>诶,这就输出了这个接口就是把当前的 8 个位,一块儿给输出的 要用的话就是给 给高电平一下,输出存的那几个位</li><li>QA-QH:<br>就是桌子旁边的座位,这是输出口 最后进来的位在最前面 QA 座位 第二个进来位在第二个 QB 座位</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一章英语阅读原文（更新中）</title>
      <link href="/posts/29eadd43.html"/>
      <url>/posts/29eadd43.html</url>
      
        <content type="html"><![CDATA[<h1><strong>The best bosses know how to subtract work</strong></h1><hr><ul><li>Start Time: 13:02</li><li>End Time: 15:02</li><li>[[第一章英语阅读原文#<strong>The best bosses know how to subtract work</strong>|note]]<br>Companies are used to celebrating addition. Profits, customers and share prices should go up rather than fall. Innovation is the adding of new products. Larger numbers are a measure of career success: managers climb the corporate ladder by taking on more reports, running <strong>heftier</strong> budgets and <strong>trousering</strong> bigger salaries.</li></ul><p>Genuine superstars don’t just add. They multiply. The best software programmers are tagged as “10x developers”, for <strong>supposedly</strong> being ten times more productive than their peers.</p><p>Firms are not always opposed to subtraction. There are good kinds of cuts: carbon emissions, most obviously. Reducing costs is a necessary part of management, though not a welcome one. But the value of doing less is underestimated. <em>The best bosses are those who take things away as well as add them on.</em></p><p>That means clearing time for employees to get work done. Meetings are almost always called by bosses. Some are useful; many of them have all the <strong>pizzazz</strong> and impact of a speed-awareness course.</p><p><strong>Shopify</strong>, an e-commerce firm, began the year by deleting 12,000 <strong>recurring</strong> meetings from corporate calendars, and asking everyone to think carefully before <strong>reinstating</strong> them. The company reports a rise in productivity as a result of the <strong>cull</strong>.</p><p>The only thing worse than having too many meetings is not being invited to them at all. So whenever meetings do take place, surprisingly large numbers of people can <strong>turn up</strong>. Minus-minded managers will give employees permission not to attend if they are not needed.</p><p><strong>By the same token</strong>, good bosses will send messages when necessary, not every time a bright idea <strong>pops into</strong> their head. They will reduce the tempo of work, by leaving employees time to concentrate. They will be clear if something is urgent or not.</p><p>A recent study by Laura Giurge of London Business School and Vanessa Bohns of Cornell University found that receivers of an email routinely overestimate how quickly its sender expects a reply.</p><p>Subtraction is not just about removing day-to-day distractions. It’s also about taking decisions to kill off projects and products that are going nowhere, and to <strong>focus efforts on the most important bits of</strong> the business.</p><p>Peter Drucker, the <strong>doyen</strong> of management theorists, was an <strong>advocate</strong> of “planned abandonment”, so that resources that <strong>are tied up in marginal activities</strong> <strong>are freed for</strong> more profitable use. <strong>Executives</strong> should, he advised, <strong>routinely</strong> ask the same question of every aspect of the business: “If we did not do this already, would we go into it now knowing what we now know?”</p><p>In “The Case for Good Jobs”, a new book, Zeynep Ton of MIT Sloan School of Management argues that doing less can often make commercial sense. Costco, a <strong>well-regarded</strong> American <strong>retailer</strong> that believes in the “intelligent loss of sales”, has a deliberately limited product range. That means it can focus its buying power more effectively, forecast demand more <strong>accurately</strong> and use its employees’ time more productively.</p><p>Less may not sound like a great outcome for customers, but at some point choice is deeply <strong>wearying</strong>. <em>When you have spent more time trying to decide what to watch on a streaming service than it takes to go to the cinema and watch “Oppenheimer” twice, scarcity</em> <strong>seems pretty attractive</strong>.</p><h1><strong>Research: Few Corporate Spinoffs Deliver Value</strong></h1><hr><ul><li>Start Time: 14:28</li><li>End Time: 14:51<br>[[第一章笔记英语阅读笔记#<strong>Research Few Corporate Spinoffs Deliver Value</strong>|note]]<br>Barely a month goes by without a major company announcing that it is breaking up its business into <strong>spun-out</strong> public companies. Kellogg, GSK, Johnson &amp; Johnson, General Electric, and IBM all recently made such announcements. While it is too soon to predict the effectiveness of any single recently announced deal, this intensified focus on separations raises some critical questions about the value created from a spin-off. What is it that these companies are hoping to achieve? What challenges will they face? How will they create <strong>shareholder</strong> value in light of these challenges?</li></ul><p>We analyzed more than 350 public <strong>spin-offs</strong> valued at greater than $1 billion between 2000 and 2020. The most unexpected thing we learned was that 50% of companies pursuing a separation fail to create any new shareholder value two years down the road, and 25% destroy a significant amount of shareholder value in the process. This happens despite their stated <strong>intentions</strong> to create value through greater management focus, additional growth opportunities, targeted capital allocation, and investment profiles that match a more specific investor base.</p><p>The evidence is <strong>overwhelming</strong>. Among the companies in our study, the average separation delivered as little as a 5% increase in combined market cap two years after spinning off. The range of performance was significant. Companies in the bottom <strong>quartile</strong> completed separations that actually destroyed value by as much as 50% of the combined market cap.</p><p>At the same time, while most companies saw little for their efforts, top-quartile separations performed exceptionally well, with 75% higher combined market cap two years after the separation. Think of the experience of industrial company Arconic, which spun off Howmet Aerospace in April 2020. Fifteen months later the combined market cap of both companies had <strong>risen by</strong> more than 150%. Or consider Baxter’s spin-off of Baxalta in 2015, in which combined market cap rose by 30% in one year before Baxalta was acquired by Shire.</p><p>The huge <strong>disparity</strong> in performance between winners and losers led us to focus our research on what leading companies do that results in such dramatic outperformance—as well as on the <strong>missteps</strong> that <strong>trip up</strong> other companies.</p><p>What we see is that many companies <strong>doom</strong> their separations from the start with a faulty <strong>premise</strong>. They assume the mere act of spinning off a business is sufficient to achieve a higher multiple, and <em>they define success <strong>shortsightedly</strong> as getting to day one as fast as possible</em>. In fact, investors know there are sometimes significant dis-synergies and one-time costs from breaking up. They want to see that the profit-and-loss (P&amp;L) shape, operating model, and growth <strong>trajectory</strong> of one or both entities are great enough to <strong>offset</strong> those costs and sufficiently different enough from past performance to <strong>warrant</strong> a higher multiple.</p><p>Some companies already run separate operations, with no shared functions and systems, and can break apart easily and relatively quickly. Most companies, however, face a high level of <strong>entanglement</strong> across support functions and even operations. Untangling can take several months to several years and often includes service agreements of varying durations. In addition, the complex regulatory and legal requirements make the process even more complex.</p><h1><strong>Kindness Can Have Unexpectedly Positive Consequences</strong></h1><hr><ul><li>Start Time: 15:02</li></ul><p>[[第一章笔记英语阅读笔记#<strong>Kindness Can Have Unexpectedly Positive Consequences</strong>|note]]<br>Scientists who study happiness know that being kind to others can improve well-being. Acts as simple as buying a cup of coffee for someone can boost a person’s mood, for example. Everyday life <strong>affords many opportunities for</strong> such actions, yet people do not always take advantage of them. In a set of studies published online in the <em>Journal of Experimental Psychology: General</em>, Nick Epley, a behavioral scientist at the University of Chicago Booth School of Business, and I examined a possible explanation. <em>We found that people who perform random acts of kindness do not always realize how much of an impact they are having on another individual.</em> People <strong>consistently</strong> and systematically underestimate how others value these acts.</p><p>Across multiple experiments involving approximately 1,000 participants, people performed a random act of kindness—that is, an action done with the primary intention of making someone else (who isn’t expecting the gesture) feel good. Those who perform such actions expect nothing <strong>in return</strong>. From one procedure to the next, the specific acts of kindness varied. For instance, in one experiment, people wrote notes to friends and family “just because.” In another, they gave cupcakes away. Across these experiments, we asked both the person performing a kind act and the one receiving it to fill out questionnaires. We asked the person who had acted with kindness to report their own experience and predict their <strong>recipient</strong>’s response. We wanted to understand how valuable people perceived these acts to be, so both the performer and recipient had to rate how “big” the act seemed. <strong>In some cases</strong>, we also <strong>inquired about</strong> the actual or perceived cost in time, money or effort. <strong>In all cases</strong>, we compared the performer’s expectations of the recipient’s mood with the recipient’s actual experience.</p><p>Across our investigations, several robust patterns emerged. <strong>For one</strong>, both performers and recipients of the acts of kindness were in more positive moods than normal after these exchanges. <strong>For another</strong>, it was clear that performers undervalued their impact: recipients felt significantly better than the kind actors expected. The recipients also <strong>reliably</strong> rated these acts as “bigger” than the people performing them did. We initially studied acts of kindness done for familiar people, such as friends, classmates or family. But we found that participants underestimated their positive impact on strangers as well. In one experiment, participants at an ice-skating rink in a public park gave away hot chocolate on a cold winter’s day. Again the experience was more positive than the givers anticipated for the recipients, who were people that just happened to be nearby. While the people giving the hot chocolate saw the act as relatively <strong>inconsequential</strong>, it really mattered to the recipients.</p><p>Our research also <strong>revealed</strong> one reason that people may underestimate their action’s impact. When we asked one set of participants to estimate how much someone would like getting a cupcake simply for participating in a study, for example, their predictions <strong>were well-calibrated with</strong> recipient reactions. But when people received cupcakes through a random act of kindness, the cupcake givers underestimated how positive their recipients would feel. Recipients of these unexpected actions tend to focus more on warmth than performers do. Our work suggests that simply being part of a positive, <strong>prosocial</strong> <strong>interaction</strong> is meaningful beyond whatever it is a person receives. People understand that cupcakes can make folks feel good, to be sure, but it <strong>turns out</strong> that cupcakes given in kindness can make them feel surprisingly good. When someone is thinking primarily about the tasty treat they are giving away, they may not realize that the warmth of that gesture is an extra <strong>ingredient</strong> that can make the cupcake even sweeter.</p><p><em>Missing the importance of warmth may <strong>stand in the way of</strong> being kinder in daily life.</em> People generally want to perform kind actions—in fact, many of our participants noted that they’d like to do so more often. But our data suggest that underestimating the impact of one’s actions may reduce the likelihood of kindness. If people undervalue this impact, they might not bother to carry out these warm, prosocial behaviors. Furthermore, the <strong>consequences</strong> of these acts may go beyond a single recipient: kindness can be <strong>contagious</strong>. In another experiment, we had people play an economic game that allowed us to examine what are sometimes called “pay it forward” effects. In this game, participants allocated money between themselves and a person whom they would never meet. People who had just been on the receiving end of a kind act gave <strong>substantially</strong> more to an <strong>anonymous</strong> person than those who had not. Meanwhile the person who performed the initial act did not recognize that their generosity would <strong>spill over</strong> in these <strong>downstream</strong> interactions.</p><p>These findings suggest that what might seem small when we are deciding whether or not to do something nice for someone else could matter a great deal to the person we do it for. <em>Given that these warm gestures can enhance our own mood and brighten the day of another person, why not choose kindness when we can?</em></p><h1><strong>Why falling asleep with the lights on is bad for your health</strong></h1><hr><ul><li>Start Time: 16:09</li><li>End Time: 16:24<br>[[第一章英语阅读原文#<strong>Why falling asleep with the lights on is bad for your health</strong>|note]]<br>Many of us are surrounded by light at night — from <strong>streetlights streaming through</strong> our windows to televisions and smartphones by our beds. And now research shows that <strong>exposure to</strong> light at night in the hours before bedtime and even during sleep can be <strong>detrimental</strong> to our health.</li></ul><p>Light is a key regulator of our brain’s biological clock, known as the suprachiasmaticnucleus. “<em>Light is powerful <strong>in that</strong> it can synchronize rhythms and, at the wrong time, it can desynchronize rhythms</em>,” said Phyllis Zee, neurologist and director of the Center for Circadian and Sleep Medicine at Northwestern University Feinberg School of Medicine.</p><p>In one 2022 study, Zee and her colleagues tested how light exposure would affect the biology of 20 young healthy adults as they slept. One group spent a night asleep in <strong>dim</strong> light, similar to dusk, followed by a night with the overhead lights on. The overhead lights <strong>emitted a glow</strong> that was roughly equivalent to hotel hallway lighting — bright, but not sufficient for comfortable reading, Zee said. A control group spent both nights sleeping in dim light.</p><p>Participants who slept with the lights on reported that they slept fine, but brain recordings showed that they spent less time in slow wave and rapid eye movement sleep, which are more restful stages critical for cognitive functioning. The effects on their metabolism and heart were even more striking. Blood samples <strong>indicated that</strong> a single night sleeping under room light increased participants’ <strong>insulin</strong> <strong>resistance</strong>, which is important for blood sugar control, the following morning. But most surprising to the researchers was how the light exposure affected heart rate. “It was high the entire night,” Zee said. “That’s what was bizarre.”</p><p><em>These results suggest that, even with our eyes closed, our brain can be aware of relatively low light, which may cause the brain’s autonomic “fight-or-flight” system to become “low-key revved up,”</em> Zee said. “It’s almost like in preparation to run or having to wake up.” Though this study <strong>was conducted with</strong> a small sample size of young and healthy people, other recent research suggests that light exposure during sleep may be even more detrimental to older individuals. In another 2022 study involving over 550 adults 63 and older, Zee and her colleagues found that any light exposure during sleep was associated with higher <strong>prevalence</strong> of obesity, diabetes and hypertension.</p><p>Other research indicated that sleeping with even a little light in the room decreased sleep quality. Kenji Obayashi, a researcher studying the epidemiology of circadian rhythms at Nara Medical Universityin Japan, conducted a 2019 study involving over 1,100 older participants that found light exposure in the hours before waking up was associated with more sleep disturbances. “We know that even moderate levels of light at night, like you may see coming in from the windows outside or your night light or hallway light, seems to affect your brain,” Zee said.</p><h1><strong>To live longer, pick up the pace just three minutes a day, study shows</strong></h1><hr><ul><li>Start Time: 16:24</li><li>End Time: 16:40<br>[[第一章英语阅读原文#<strong>To live longer, pick up the pace just three minutes a day, study shows</strong>|note]]<br>Hurry to the bus stop. Rush up the stairs. Play tag with your kids. Romp with the dog. Vacuum the living room with a little extra zing. Increasing the vigor and gusto of our daily activities could <strong>have a substantial impact on</strong> our longevity, according to a fascinating new study of movement intensity and mortality.</li></ul><p>The study finds that as few as three minutes a day of <strong>vigorous</strong> everyday activity is linked to a 40 percent lower risk of premature death in adults, even when they do not otherwise exercise at all. “It is fantastic” research, said Ulrik Wisloff, the director of the K.G. Jebsen Center for Exercise in Medicine at the Norwegian University of Science and Technology in Trondheim. He has <strong>extensively</strong> studied activity and longevity but <strong>was not involved</strong> in the new study.</p><p>The study’s results join <strong>mounting</strong> scientific evidence that adding a little <strong>intensity</strong> to our lives <strong>pays big dividends for</strong> our health, without requiring extra equipment, instruction, gym memberships or time. The idea that how we move influences how long we live is hardly new. Plenty of research <em>links regular exercise with longer life spans</em>, including the formal public health exercise guidelines, which recommend at least 150 minutes a week of moderate exercise for health and longevity.</p><p>More-focused research, though, suggests intensifying some of our exercise — making sure our heart rates and breathing rise — <strong>amplifies</strong> the health benefits. In a large-scale 2006 study from Wisloff’s lab, for instance, just 30 minutes a week of intense exercise dropped the risk of dying from heart disease by about half in men and women, compared to people who were sedentary. Similarly, a study published last year in JAMA Internal Medicine concluded that people who occasionally pushed themselves during exercise were about 17 percent less likely to die <strong>prematurely</strong> than other people who did the same amount of exercise, but at a gentler, moderate pace.</p><p>Both of these studies, though, and similar, past research were based on people’s subjective recall of how much and how hard they exercised. They also were exercise studies, making them <strong>inherently</strong> of interest mostly to people who exercise or would like to, which does not represent the greater part of humanity. “If we’re honest, most people are allergic to the word ‘exercise,’” said Emmanuel Stamatakis, a professor of physical activity and health studies at the University of Sydney in Australia, who led the new study.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux命令学习</title>
      <link href="/posts/ed5f8cc8.html"/>
      <url>/posts/ed5f8cc8.html</url>
      
        <content type="html"><![CDATA[<h1>- Date:2024-01-05</h1><ul><li>Time:21:44</li><li>Subject:</li><li>Tags: #linux<br>[[2024-01]]</li></ul><hr><h1>通配符</h1><ul><li><code>*</code> 匹配0个或者多个字符</li><li><code>?</code> 匹配一个字符</li><li><code>[abcd]</code> 匹配abcd中任意一个字符</li><li><code>[a-z]</code> 匹配a-z任意一个字符</li><li><code>[!abc]</code> 不匹配括号内任意一个字符，或者用 <code>^</code> 代替 <code>!</code></li></ul><h1>linux的文件目录</h1><blockquote><p>[!note]</p><ul><li>磁盘结构——树状，与Windows不同</li><li><code>ls /</code> 把根的目录显示出</li><li><code>sudo apt-get install openssh -server</code>安装ssh服务</li><li><code>sudo service ssh start</code>启动ssh命令</li><li><code>/etc/init.d/ssh restart</code>重启ssh服务</li></ul></blockquote><h2 id="目录结构">目录结构</h2><ul><li>bin<ul><li>存放命令</li><li>binary的缩写</li></ul></li><li>boot<ul><li>系统启动所需的目录</li></ul></li><li>dev<ul><li>设备文件，把设备抽象成文件</li><li>device缩写</li></ul></li><li>etc<ul><li>系统所需的配置文件</li></ul></li><li>home<ul><li>存放用户文件的目录，可以是不同用户的</li></ul></li><li>lib<ul><li>动态库，给应用程序使用</li><li>library缩写</li></ul></li><li>lost+found<ul><li>异常关机产生的</li></ul></li><li>media<ul><li>自动挂载的设备</li></ul></li><li>mnt<ul><li>手动挂载的目录</li><li>一般是空的，需要手动创建目录</li></ul></li><li>opt<ul><li>安装的文件的目录</li><li>类似usr目录</li></ul></li><li>proc<ul><li>放进程有关的信息</li><li>process</li></ul></li><li>root<ul><li>root用户的文件</li></ul></li><li>sbin<ul><li>super usr</li><li>系统管理员会用的命令</li></ul></li><li>usr<ul><li>用户程序的资源</li><li>类似program files<ul><li>bin 用户所用的程序</li><li>sbin 超级用户使用的高级程序</li><li>src 内核源码</li></ul></li></ul></li><li>var<ul><li>存放经常修改的文件 如日志</li></ul></li><li>srv<ul><li>系统服务启动后用到的数据</li></ul></li></ul><h1>终端中不同颜色的含义</h1><ul><li>白色 普通文件</li><li><font color="#00b0f0">蓝色 目录</font></li><li><font color="#00b050">绿色 可执行文件</font></li><li><font color="#4bacc6">青色 链接文件</font> ln文件</li><li><font color="#ff0000">红色 压缩文件</font></li><li><font color="#ffc000">黄色 设备文件</font></li><li><font color="#7f7f7f">灰色 其他文件</font></li></ul><h1>终端中的快捷键</h1><h2 id="终端中ctrl类">终端中ctrl类</h2><ul><li>ctrl f 向前光标</li><li>ctrl b 向后光标</li><li>ctrl a 行首</li><li>ctrl e 行尾</li><li>ctrl p 上翻页（感觉和上下键的一样）</li><li>ctrl n 下翻页</li><li>ctrl h 删除前一个字符（就是bcak键）</li><li>ctrl d 删除光标的字符，就是对应的，不同上面的</li><li>ctrl u 删除光标前所有内容（不包括光标的字符）</li><li>ctrl k 删除光标至末尾的内容（包括光标的字符）</li><li>ctrl w 删除光标前单词（空格隔开）</li><li>ctrl y 快速恢复擦除的文本</li></ul><h2 id="终端中tab">终端中tab</h2><ul><li>补全输入的命令/路径（唯一的时候会补全，否则会下面）</li><li>提示可能要输入的命令/路径</li></ul><h1>文件权限</h1><ul><li>对于d<font color="#ff0000">rwx</font><font color="#00b050">rwx</font><font color="#0070c0">rw-</font><ul><li><font color="#ff0000">所有者</font> <font color="#00b050">用户组</font> <font color="#0070c0">其他人</font></li></ul></li><li>权限类型<ul><li>r 可读</li><li>w 可写</li><li>x 可执行/可切换目录</li><li><ul><li>无权限</li></ul></li></ul></li></ul><h1>命令</h1><blockquote><p>[!tip]<br>十分重要，但不局限于这些</p></blockquote><h2 id="一般类">一般类</h2><h3 id="man">man</h3><ul><li>查看帮助手册，比如查看命令的使用方法，或者应用程序</li></ul><h4 id="常用参数">常用参数</h4><ul><li>-f 显示简短描述信息（先使用这个，这样可以知道这个名字下是不是有同名的函数/命令）</li><li>-k 根据关键词搜索手册，和这个相关的都会出来</li><li>-w 显示手册文件所在位置</li></ul><h4 id="例子">例子</h4><blockquote><p>[!note]<br>先打参数 再打需要操作的word</p></blockquote><ul><li><code>man -f sleep</code></li><li><code>man 3 sleep</code> 看第三个章节的sleep （因为使用-f查看时发现有多个sleep，默认看的是1）</li></ul><h4 id="快捷用法">快捷用法</h4><ul><li>/word 在帮助文档中搜索word关键词<ul><li>n 下一个</li><li>shift n 上一个</li></ul></li></ul><h3 id="info">info</h3><ul><li>比man更复杂，有多页，有超链接</li></ul><h4 id="常见参数">常见参数</h4><ul><li>-w 显示物理位置</li><li>-f 指定要访问的info</li><li>-n 在首个浏览过的info文件中指定节点</li><li>-O 跳转至命令行选项节点</li></ul><h4 id="常用操作">常用操作</h4><ul><li>n 显示下一节点的内容</li><li>p 显示上一节点的内容</li><li>l 返回上一个访问节点的内容</li><li>空格 向前一页</li><li>back 向后一页</li><li>b/e 一个节点内容的开始/结束</li><li>h 打开info教程</li><li>d 回到info的初始节点</li><li>回车 跳转到链接文本</li><li>q 退出</li></ul><h3 id="whatis">whatis</h3><ul><li>查询命令执行的功能是什么</li><li>相当于把man -f的结果打印出来</li></ul><h3 id="touch">touch</h3><h4 id="作用">作用</h4><ul><li>改变已有文件的时间戳属性</li><li>创建新的空文件</li></ul><h4 id="参数">参数</h4><ul><li>-a 改变读取时间的记录（access change）</li><li>-m 改变修改时间的记录（modify change）</li><li>-c 不创建新文件</li><li>-t 设置文件时间记录，格式和date命令相同 <code>touch -t 2201011030.55 file</code> 2022年1月1日10点30分55秒</li><li>-r 使用参考文件的时间记录 <code>touch file -r ref_file</code></li><li>-d 使用指定字符串表示时间式 <code>touch -d &quot;tomorrow&quot; file</code></li></ul><h3 id="mkdir">mkdir</h3><ul><li>创建目录makedir，使用很多</li></ul><h4 id="参数-2">参数</h4><ul><li>-p 递归创建多级目录</li><li>-m 建立目录同时设置权限</li><li>-v 显示目录创建过程</li></ul><h4 id="例子-2">例子</h4><ul><li>多个目录<ul><li><code>mkdir dir1 dir2 dir3</code> 创建多个笔记</li><li><code>mkdir dir&#123;5..7&#125;</code> 创建5到7的目录</li><li><code>mkdir -p dir7/dir8/dir9</code> 文件夹里面又有文件夹</li></ul></li><li><code>mkdir -m 700 dir1/dir10</code> 700权限的递归目录</li></ul><h3 id="rm">rm</h3><ul><li>删除文件，remove</li></ul><h4 id="参数-3">参数</h4><ul><li>-r 递归删除，把子目录的文件也删除</li><li>-f 忽略不存在的文件，不会出现警告信息</li><li>-v 显示执行的过程</li><li>-i 删除前会问是否进行操作</li></ul><h4 id="例子-3">例子</h4><ul><li><code>rm -rf *</code> 删除该目录下所有文件</li><li><code>rm -r dir</code> 删除这个目录</li><li><code>rm file.txt</code> 删掉这个文件</li></ul><h3 id="rmdir">rmdir</h3><ul><li>删除空目录</li></ul><h4 id="参数-4">参数</h4><ul><li>-p 递归方式删除所有父级目录</li><li>-v 显示过程</li></ul><h4 id="例子-4">例子</h4><ul><li><code>rmdr -p dir1/dir2/dir3</code> 递归删除多重目录</li></ul><h3 id="mv">mv</h3><ul><li>移动文件</li><li>重命名文件</li></ul><h4 id="参数-5">参数</h4><ul><li>-i 存在同名，询问覆盖</li><li>-f 直接覆盖，不询问</li><li>-b 存在同名，覆盖前创建备份</li><li>-u 当源文件比目标的新，或者目标文件不存在，才执行移动的操作</li></ul><h4 id="例子-5">例子</h4><ul><li><code>mv file.txt newnew.txt</code> 重命名</li><li><code>mv file.txt /dir</code> 移动到dir目录</li><li><code>mv dir1 dir2</code> 把dir1移动到dir2中，存在的时候才会移动，不存在就是重命名</li><li><code>mv -i file1.txt file2.txt</code> 提示是否覆盖</li><li><code>mv * ../</code> 移动当前文件夹下所有文件到上一目录</li><li><code>mv dir3/* dir2</code> 将当前目录的一个子目录文件移动到另外一个子目录里面</li></ul><h3 id="cp">cp</h3><ul><li>复制文件和目录</li></ul><h4 id="参数-6">参数</h4><ul><li>-f 目标文件存在，直接覆盖，<font color="#ffc000">默认就是-f，不会提示</font></li><li>-i 目标文件存在，询问是否覆盖</li><li>-a 一般复制目录的时候用，保留链接，文件属性，并复制目录下的所有内容</li><li>-r 递归复制文件和目录</li><li>-b 覆盖已存在的文件目标前将目标文件备份</li><li>-v 详细显示操作的过程</li></ul><h4 id="例子-6">例子</h4><ul><li><code>cp file1.txt file2.txt</code> 复制文件</li><li><code>cp -r dir1 dir2</code> 复制目录</li><li><code>cp -a dir1 dir2</code> 保留所有属性复制</li></ul><h3 id="cd">cd</h3><ul><li>切换目录</li></ul><h4 id="特殊目录">特殊目录</h4><ul><li><code>~</code> 用户家目录</li><li><code>.</code> 当前目录</li><li><code>..</code> 当前目录的上一级目录</li><li><code>/</code> 根目录</li><li><code>-</code> 上一次所在的目录</li></ul><h4 id="绝对路径和相对路径">绝对路径和相对路径</h4><ul><li>起始路径为<code>/</code>的为<font color="#ffc000">绝对路径</font></li><li>不是<code>/</code>的是<font color="#ffc000">相对路径</font></li></ul><h4 id="例子-7">例子</h4><ul><li><code>cd dir</code> 切换到当前的dir目录</li><li><code>cd ../../</code> 切换到上上级目录</li><li><code>cd </code> 切换到家目录</li><li><code>cd ~</code> 切换到上一次的目录</li></ul><h3 id="pwd">pwd</h3><ul><li>打印当前路径，打印的是<font color="#ffc000">绝对路径</font></li><li>print working directory</li></ul><h4 id="例子-8">例子</h4><ul><li><code>pwd</code> 直接显示</li></ul><h3 id="ls">ls</h3><ul><li>显示目录信息</li><li>list</li></ul><h4 id="参数-7">参数</h4><ul><li>-a 显示所有文件和目录（包括隐藏文件）</li><li>-l 长格式列出文件和目录信息</li><li>-r 相反次序显示（默认按英文字母显示）</li><li>-t 根据修改时间排序</li><li>-h 以人类可读的格式显示数字大小，会有kb/mb/gb，不然就是直接比特显示</li><li>-A 同 -a 但不列出<code>. 和 ..</code>这个是当前目录和父目录，-a会列出</li><li>-S 根据文件大小排序</li><li>-R 递归列出所有子目录</li><li>-F 在列出的文件名称后加一符号；<ul><li>可执行文件多个<code>*</code></li><li>目录多个<code>/</code></li></ul></li></ul><h4 id="例子-9">例子</h4><ul><li><code>ls -a</code> 列出所有文件，包括隐藏文件</li><li><code>ls -l</code> 显示详细信息</li><li><code>ls /</code> 列出根目录<code>/</code>下的所有文件</li><li><code>ls -lR</code> 列出当前目录所有文件，包括子目录</li><li><code>ls -l f*</code> 列出带f开头的文件详细信息</li><li><code>ls -ltr</code> 列出所有文件，时间的倒序显示</li><li><code>ls -AF</code> 显示所有文件和目录，并且加上特定独好区分文件</li><li><code>ls -lh</code> 列出详细信息并显示文件大小</li></ul><h3 id="tree">tree</h3><ul><li>以树状图列出目录内容</li></ul><h4 id="参数-8">参数</h4><ul><li>-a 显示所有文件和目录（加上隐藏文件）</li><li>-L 层级限制</li><li>-t 根据更改时间排序</li><li>-r 更改时间倒叙</li><li>-f 在每个文件或目录之前，显示完整的相对路径名称</li><li>-d 显示目录名称而非内容</li><li>-p 显示权限信息</li></ul><h4 id="例子-10">例子</h4><ul><li><code>tree -L 2</code> 显示n层目录</li></ul><h3 id="stat">stat</h3><ul><li>显示文件或者文件系统的详细信息</li></ul><h4 id="参数-9">参数</h4><ul><li>-L 支持符号链接</li><li>-f 显示文件系统的信息</li><li>-t 简洁方式输出</li></ul><h4 id="三种时间">三种时间</h4><ul><li>acess time 访问时间<ul><li>读取（more/less/cat/tail），修改时（vim/nano）改变</li></ul></li><li>modify time 修改时间<ul><li>修改时改变</li></ul></li><li>change tiem 状态改变时间<ul><li>修改，文件属性变化的改变（chmod/chown）</li></ul></li></ul><h2 id="文件操作-工具类">文件操作/工具类</h2><h3 id="rename">rename</h3><ul><li>用字符串替换的方式批量改变文件名</li></ul><h4 id="语法">语法</h4><ul><li><code>rename 's/oldname/newname/' files</code><ul><li>files 是修改的文件，可以是多个，用通配符表示</li></ul></li></ul><h4 id="通配符">通配符</h4><ul><li><code>?</code> 替代单个字符</li><li><code>*</code> 替代多个字符</li></ul><h4 id="参数-10">参数</h4><ul><li>-n 模拟运行</li><li>-v 输出每步的执行信息</li><li>-f 强制执行</li></ul><h4 id="例子-11">例子</h4><ul><li><code>rename 's/.txt/.doc/ myfile.txt'</code> 把.txt改成了.doc</li><li><code>rename -n 's/file/file0/' file*</code> 模拟把file开头的所有文件都改成file0开头</li></ul><h3 id="chattr">chattr</h3><ul><li>更改文件属性</li></ul><h4 id="参数-11">参数</h4><ul><li>-R 递归处理目录下所有文件</li><li>-v 设置文件或目录版本</li><li>-V 显示指令执行过程</li><li><ul><li>开启某个权限</li></ul></li><li><ul><li>关闭某个权限（属性）</li></ul></li><li>= 指定某个权限</li></ul><h4 id="属性">属性</h4><ul><li>略 太多了</li></ul><h4 id="例子-12">例子</h4><ul><li><code>chattr +i file.txt</code> 防止修改</li><li><code>chattr -i file.txt</code> 解锁</li><li><code>chattr +a file.txt</code> 只允许最佳内容</li><li><code>chattr -R +i dir</code> 给一个目录所有文件添加限制</li><li><code>lsattr file.txt</code> 查看文件属性</li></ul><h3 id="file">file</h3><ul><li>识别文件类型</li></ul><h4 id="参数-12">参数</h4><ul><li>-b 列出文件类型，不显示文件名称</li><li>-c 详细限制执行过程</li><li>-f 指定名称文件，显示多个文件类型信息</li><li>-L 直接显示符号连接指向的文件类型</li><li>-m 指定魔法数字文件</li><li>-z 尝试区解读压缩包的内容</li><li>-i 显示MIME类型</li></ul><h3 id="md5sum">md5sum</h3><ul><li>生成和校验文件的md5值</li></ul><h4 id="参数-13">参数</h4><ul><li>-b 以二进制模式读取文件</li><li>-t 以文本模式读入文件内容</li><li>-c 根据已知的md5，对现存的文件进行校验</li></ul><h4 id="例子-13">例子</h4><ul><li><code>md5sum file.txt &gt; file.md5</code> 将生成的md5值重定向到指定文件（md5文件）</li><li><code>md5sum -c file.md5</code> 直接对file文件进行md5验证</li><li><code>md5sum -c --status file.md5</code> <code>ech$?</code> 校验但是不显示任何输出，echo返回码表示成功与否</li></ul><h3 id="find">find</h3><ul><li>搜索指定文件</li></ul><h4 id="例子-14">例子</h4><ul><li><code>find / -name *.conf</code> 全盘搜索以conf结尾的文件</li><li><code>find /etc -size +1k</code> 搜索/etc目录下大于1k大小的文件</li><li><code>find . -type f</code> 搜索当前目录所有文件</li><li><code>find . -perm 664 -exec ls -l &#123;&#125; \;</code> 搜索664权限文件并列出</li><li><code>find .</code> 列出当前目录和文件</li><li><code>find . -iname &quot;*.txt&quot;</code> 搜索后缀为txt的，有i就是包括大写的</li><li><code>find . ! -name &quot;*.txt&quot;</code> 反过来</li><li><code>find . -mtime -7 -exec rm -i &#123;&#125; \;</code> 搜索7天内被修改的文件，并询问删除</li></ul><h3 id="which">which</h3><ul><li>查找命令文件所在位置</li><li>搜索在path变量中</li></ul><h4 id="例子-15">例子</h4><ul><li><code>which bash</code> 找bash在哪</li></ul><h3 id="whereis">whereis</h3><ul><li>查找命令二进制程序、源码和man手册相关文件的路径</li></ul><h4 id="例子-16">例子</h4><ul><li><code>whereis ls</code> 找出所有</li><li><code>whereis -b ls</code> 只找二进制程序</li><li><code>whereis -m ls</code> 只找man手册页路径</li></ul><h3 id="locate">locate</h3><ul><li>快速查找文件或者目录</li></ul><h4 id="例子-17">例子</h4><ul><li><code>locate file.txt</code> 找带 <code>file.txt</code> 的所有文件</li><li><code>locate /etc/sh</code></li><li><code>locate whereis</code></li><li><code>locate -i locate/f</code> 查找该路径下f开头的文件，-i不区分大小写</li></ul><h3 id="chown">chown</h3><ul><li>Change owner</li><li>改变用户和用户组</li></ul><h4 id="参数-14">参数</h4><ul><li>-c 显示变更信息</li><li>-R 目录下所有都改变</li></ul><h4 id="例子-18">例子</h4><ul><li><code>sudo chown alvin:alvin file.txt</code> 把这个文件的用户组和用户改成alvin</li><li><code>sudo chown :alvin file.txt</code> 改用户组</li><li><code>sudo chown -R alvin:alvin dir</code> 把指定目录和其他子文件都该了</li></ul><h3 id="chgrp">chgrp</h3><ul><li>改变用户组</li><li>和chown很像</li></ul><h3 id="chmod">chmod</h3><ul><li>Change mod</li><li>改变文件权限</li></ul><h4 id="模式">模式</h4><ul><li>符号模式<ul><li>对象<ul><li>u user 文件所有者</li><li>g group 文件所有组所在组</li><li>o others 其他用户</li><li>A all 所有用户，相当于ugo</li></ul></li><li>操作<ul><li><ul><li>加权限</li></ul></li><li><ul><li>去除权限</li></ul></li><li>= 重新设置权限</li></ul></li><li>权限<ul><li>r 读</li><li>w 写</li><li>x 执行</li></ul></li></ul></li><li>数字模式<ul><li>类似二进制的代码，加起来，数字代表权限</li></ul></li></ul><h4 id="参数-15">参数</h4><ul><li>-R 递归处理所有文件</li></ul><h4 id="例子-19">例子</h4><ul><li><code>chmod a+r file.txt</code> 设置都可读</li><li><code>chmod -R a+r</code> 全部设置可读取</li><li><code>chmod u+x file.txt</code> 文件拥有者才能执行</li><li><code>chmod ug+w,0-w file.txt</code> 所有者和同组可写，其他人不可写</li><li><code>chmod a+r,a+w,a+x file.txt</code> <code>chmod 777 file.txt</code> 设置所有人都可读可写可执行</li><li><code>chmod 755 file.txt</code> 拥有者可读可写可执行，其他人可读可执行</li><li><code>chmod 9=rw,go= file.txt</code> 拥有者可读可写，其他人没有权限</li></ul><h3 id="grep">grep</h3><ul><li>文本搜索工具</li></ul><h4 id="参数-16">参数</h4><ul><li>-i 忽略大小写</li><li>-c 输出匹配行的数量</li><li>-l 只列出符合的文件名，不输出匹配行</li><li>-n 列出所有匹配行，显示行号</li><li>-h 查询多文件时不显示文件名</li><li>-s 不显示不存在，不匹配的错误信息</li><li>-v 显示不包含匹配文本的所有行</li><li>-w 匹配整词</li><li>-x 匹配整行</li><li>-r 递归搜索</li><li>-q 禁止输出任何结果，退出状态标识是否成功</li><li>-b 打印距离文件头部偏移量，字节为单位</li><li>-o 于-b结合使用</li><li>-F 匹配固定字符串的内容</li><li>-E 支持扩展的正则表达式</li></ul><h4 id="例子-20">例子</h4><ul><li><code>grep -rl hello *</code> 目录下及其子目录搜hello</li><li><code>grep root /etc/passwd /etc/shadow</code> 搜索多个文件中的内容root</li></ul><h3 id="egrep">egrep</h3><ul><li>性能更好且优化的grep -E</li><li>可使用正则表达式</li></ul><h4 id="例子-21">例子</h4><ul><li><code>egrep 'a+' file.txt</code> 找包含一个以上a的内容</li><li><code>egrep 'linux|666 file.txt'</code> 包含linux或者666</li><li><code>egrep '(linux)+' file.txt</code> 包含多个linux整体的内容</li><li><code>egrep '^#' file.txt</code> 查找 <code>#</code> 开头的内容</li><li><code>egrep 'linux$' file.txt</code> 查找linux结尾的内容</li><li><code>egrep '(ab)&#123;3&#125; file.txt'</code> 查找连续出现三次ab的内容</li><li><code>egrep 'ab[cd]' file.txt</code> 查找包括abc或者abd的内容</li></ul><h3 id="cat">cat</h3><ul><li>查看文件内容</li></ul><h4 id="参数-17">参数</h4><ul><li>-n 显示行数</li><li>-s 去除重复的空行</li><li>-b 显示行数，空行不算</li><li>-E 每行结束显示$</li><li>-T 将tab显示为 <code>^I</code></li></ul><h4 id="例子-22">例子</h4><ul><li><code>cat -b file.txt</code> 显示行数</li><li><code>cat file.txt &gt; file1.txt #</code> 重定向内容<ul><li>若file1不存在则创建，内容被覆盖</li><li>换成 <code>&gt;&gt;</code> 就变成追加到末尾，不会覆盖</li></ul></li><li><code>cat file1.txt file2.txt &gt; combine.txt</code> 合并文件</li><li><code>cat &gt; file.txt</code> 创建文件，完成后ctrl+d保存</li></ul><h3 id="more">more</h3><ul><li>分页显示内容，只能往下翻，不能往前</li></ul><h4 id="操作">操作</h4><ul><li>回车 下一行</li><li>空格下一页</li></ul><h4 id="例子-23">例子</h4><ul><li><code>more -c -10 ~/.bashrc</code> 清屏操作，每次十行显示</li><li><code>more -s +10 ~/.bashrc</code> 从第十行开始，连续两行空白，合并成一行空白显示</li></ul><h3 id="less">less</h3><ul><li>分页显示，可以上下翻页</li></ul><h4 id="操作-2">操作</h4><ul><li>回车/j 下一行</li><li>k 上一行</li><li>空格/f 下页</li><li>b 上一页</li><li>q 退出</li><li>/xx 搜索<ul><li>n 下一个</li><li>Shift n 上一个</li></ul></li></ul><h4 id="例子-24">例子</h4><ul><li><code>less abc def</code> 查看两个文件<ul><li><code>:n</code> 浏览下一个文件</li><li><code>:p</code> 浏览前一个文件</li></ul></li><li><code>history | less</code> 以less命令分页查看history命令，用管道</li></ul><h3 id="nl">nl</h3><ul><li>添加行号显示</li></ul><h4 id="例子-25">例子</h4><ul><li><code>nl -b t file.txt</code> 空行没有行号，默认没有</li><li><code>nl -b a -n rz -w 3 file.txt</code> 行号右边显示，加0填充，宽度为3，空行有行号</li></ul><h3 id="split">split</h3><ul><li>文件分割</li></ul><h4 id="例子-26">例子</h4><ul><li><code>split -2 file2.txt</code> 每两行分成一个文件</li><li><code>split -b 10k file2.txt</code> 每10kb切割</li><li><code>split -b 10k -d -a 3 file2.txt</code> 数字后缀，宽度为3</li><li><code>split -b 10k -d -a 3 file2.txt split_file</code> 指定前缀</li></ul><h3 id="diff">diff</h3><ul><li>比较文件的差异</li></ul><h4 id="参数-18">参数</h4><ul><li>-y 并列方式显示</li><li>-c 显示全文，标出不同之处</li><li>-u 合并的方式显示不同</li><li>-W 设置宽度</li></ul><h4 id="显示提示">显示提示</h4><ul><li>a -add</li><li>c -change</li><li>d -delete</li><li>| 前后两个文件内容不同</li><li><code>&lt; 后面比前面少了一行</code></li><li><code>&gt; 后面比前面多了一行</code></li><li><ul><li>后面比前面多了一行</li></ul></li><li><ul><li>后面比前面少了一行</li></ul></li><li>! 有差别的行</li></ul><h4 id="例子-27">例子</h4><ul><li><code>diff -y -W 50 file1.txt file2.txt</code> 并排格式输出</li><li><code>diff -c file1.txt file2.txt</code> 上下文格式输出</li><li><code>diff file1.txt file2.txt &gt; file.patch</code> 生成补丁</li><li><code>patch file1.txt file.patch</code> 打补丁</li></ul><h3 id="tr">tr</h3><ul><li>转换或者删除文件中的字符</li></ul><h4 id="参数-19">参数</h4><ul><li>-c 反选字符</li><li>-d 删除集合中的字符</li><li>-s 缩减连续字符成指定单个字符</li></ul><h4 id="例子-28">例子</h4><ul><li><code>tr -d &quot;[a-z]&quot;</code> 删除小写字母</li><li><code>tr -d 0-9</code> 删除数字</li><li><code>tr -d -c '0-9 \n'</code> 删除不在集合中的字符</li><li><code>tr -s '\n'</code> 压缩重复空白行</li></ul><h3 id="du">du</h3><ul><li>查看磁盘使用空间</li></ul><h4 id="参数-20">参数</h4><ul><li>-a 显示目录中所有文件大小</li><li>-h 易读方式显示</li><li>-s 看目录占用大小</li></ul><h3 id="df">df</h3><ul><li>查看磁盘空间使用情况</li></ul><h4 id="参数-21">参数</h4><ul><li>-a 显示所有文件系统</li><li>-h 易读显示</li><li>-i 显示inode信息</li><li>-t&lt;文件系统类型&gt; 显示指定文件系统类型的文件系统</li><li>-T 输出时显示系统类型</li></ul><h3 id="sync">sync</h3><ul><li>强制将更改的内容立刻写入磁盘</li></ul><h3 id="mount">mount</h3><ul><li>挂载文件系统</li></ul><h4 id="参数-22">参数</h4><ul><li>-o 挂载方式<ul><li>loop 用来把一个文件当成硬盘分区挂载接上系统</li><li>ro 只读方式挂载</li><li>rw 读写方式挂载</li><li>iocharset 指定访问文件系统所用字符集</li></ul></li><li>-t 指定挂载类型</li></ul><h4 id="例子-29">例子</h4><ul><li><code>mount -t tmpfs</code> 查看当前系统挂载的所有文件系统信息</li><li><code>sudo mount /dev/sdb /mnt/udisk</code> 把U盘挂载</li><li><code>sudo mount -0 loop /home/xxiso /mnt/iso</code> 把ISO镜像挂载</li></ul><h3 id="umount">umount</h3><ul><li>卸载文件系统</li></ul><h4 id="例子-30">例子</h4><ul><li><code>umount -v /dev/sdb</code> 设备名卸载</li><li><code>umount -v /media/chris/xxx</code> 挂载点卸载</li></ul><h3 id="tar">tar</h3><ul><li>打包/解压工具</li></ul><h4 id="参数-23">参数</h4><ul><li>-c 新建打包文件</li><li>-x 解压</li><li>-f 指定需要处理的文件</li><li>-z 通过gzip方式压缩 <code>.tar.gz</code> 为后缀</li><li>-v 显示过程</li><li>-t 查看打包文件内容</li><li>-C dir 指定压缩/解压目录</li></ul><h4 id="例子-31">例子</h4><ul><li><code>tar -zcvf file.tar *.txt</code> 所有txt打包压缩</li><li><code>tar -zxvf file.tar.gz</code> 解压到当前目录</li></ul><h3 id="zip">zip</h3><ul><li>压缩</li></ul><h4 id="参数-24">参数</h4><ul><li>-v 显示执行过程</li><li>-d 更新包内内容</li><li>-r 递归处理</li></ul><h4 id="例子-32">例子</h4><ul><li><code>zip -r dir.zip dir</code></li><li><code>zip files.zip *.txt</code></li><li><code>zip -dv files.zip newfile.txt</code> 添加新文件进去压缩包</li></ul><h3 id="unzip">unzip</h3><ul><li>解压</li></ul><h4 id="参数-25">参数</h4><ul><li>-l 显示压缩包包含文件</li><li>-v 显示过程</li><li>-d &lt;目录&gt; 解压到指定位置</li></ul><h4 id="例子-33">例子</h4><ul><li><code>unzip -v file.zip</code> 显示文件列表包含压缩比率</li><li><code>unzip files.zip -d udir/</code> 解压指定目录</li></ul><h3 id="gzip-gunzip">gzip/gunzip</h3><ul><li>对文本高效率压缩</li></ul><h4 id="参数-26">参数</h4><ul><li>-d 解开压缩文件</li><li>-k 保留源文件</li><li>-l 列出压缩文件信息</li><li>-r 递归</li><li>-v 显示执行过程</li><li>-t 测试压缩包</li></ul><h2 id="系统类">系统类</h2><h3 id="uname">uname</h3><ul><li>显示系统信息</li></ul><h4 id="参数-27">参数</h4><ul><li>-a 显示所有</li><li>-m 显示架构</li><li>-n 主机名称</li><li>-s 内核</li><li>-r 内核发行版本号</li><li>-v 内核版本</li><li>-p 处理器</li><li>-o 操作系统名称</li><li>-i 显示硬件平台</li></ul><h3 id="hostname">hostname</h3><ul><li>设置系统主机名</li><li>略</li></ul><h3 id="uptime">uptime</h3><ul><li>显示系统启动时间和负载信息</li></ul><h4 id="参数-28">参数</h4><ul><li>-p 正常运行时间</li><li>-s 系统启动时间</li></ul><h3 id="free">free</h3><ul><li>显示内存使用量</li></ul><h4 id="参数-29">参数</h4><ul><li>略</li></ul><h3 id="ulimit">ulimit</h3><ul><li>控制shell程序的资源</li></ul><h3 id="init">init</h3><ul><li>切换系统运行级别</li></ul><h3 id="service">service</h3><ul><li>控制系统服务</li></ul><h3 id="vmstat">vmstat</h3><ul><li>显示虚拟内存状态</li></ul><h3 id="iostat">iostat</h3><ul><li>监视出入输出设备和CPU使用情况</li></ul><h3 id="ipcs">ipcs</h3><ul><li>显示进程间通讯设备信息</li></ul><h2 id="网络类">网络类</h2><h3 id="route">route</h3><ul><li>显示并设置路由</li></ul><h4 id="例子-34">例子</h4><ul><li><code>route add -net 244.0.0.0 netmask 24.0.0.0 dev ens33</code> 添加网关/设置网关</li><li><code>route -n</code> 显示当前路由</li><li><code>route add -net 244.0.0.0 netmask 24.0.0.0 reject</code> 屏蔽一条路由</li></ul><h3 id="ping">ping</h3><ul><li>测试网络连通性</li></ul><h4 id="参数-30">参数</h4><ul><li>-c 指定发送报文数目</li><li>-i 指定发送间隔</li><li>-s 设置大小</li><li>-t 设置TTL大小</li></ul><h3 id="traceroute">traceroute</h3><ul><li>追踪数据包在网络上传输的全部路径</li></ul><h4 id="参数-31">参数</h4><ul><li>-m &lt;数量&gt;设置检测数据包最大存活数值ttl的大小</li><li>-n 直接使用ip</li><li>-p &lt;端口&gt; 指定udp端口</li><li>-q 探测包个数</li></ul><h3 id="ifconfig">ifconfig</h3><ul><li>查询修改网络信息</li><li>Network interface configuring</li><li>设置重启后失效</li></ul><h4 id="参数-32">参数</h4><ul><li>Add 设置设备ipv6</li><li>Del 上传</li><li>Down 关闭指定设备</li><li>Up 启动</li></ul><h3 id="ifup-ifdown">ifup/ifdown</h3><ul><li>激活/禁用网络接口</li></ul><h3 id="netstat">netstat</h3><ul><li>查看网络状态</li></ul><h4 id="参数-33">参数</h4><ul><li>-a 显示连线中所有socket</li><li>-p 显示正在使用socket的程序识别码和程序名称</li><li>-l 仅列出监听的服务状态</li><li>-t 显示tcp的情况</li><li>-u udp</li><li>-i 显示网络界面信息表单</li><li>-r 显示路由表信息</li><li>-n 直接使用ip地址，不通过域名服务器</li><li>-x unix端口</li><li>-s 所有端口</li></ul><h3 id="ss">ss</h3><ul><li>显示活动套接字信息</li><li>很强大，东西太多了</li></ul><h4 id="例子-35">例子</h4><ul><li><code>ss -at</code> 显示tcp套接字</li><li><code>ss -s</code> 显示套接字使用情况</li><li><code>ss -lp | grep 6010</code> 找出端口/套接字应用程序</li><li><code>ss -tlr</code> 解析IP和端口号</li></ul><h3 id="telnet">telnet</h3><ul><li>远程登入服务器</li></ul><h3 id="ssh">ssh</h3><ul><li>安全远程连接工具</li></ul><h4 id="参数-34">参数</h4><ul><li>-l &lt;登录名&gt; 指定用户名</li><li>-p &lt;端口&gt; 指定端口</li></ul><h3 id="ftp">ftp</h3><ul><li>文件传输协议客户端</li></ul><h3 id="sftp">sftp</h3><ul><li>安全的ftp</li></ul><h4 id="参数-35">参数</h4><ul><li>-r 下载目录的时候使用，递归</li></ul><h4 id="例子-36">例子</h4><ul><li><code>sftp -P 30 chris@192.168.2.34</code> 可以不跟端口</li></ul><h3 id="lftp">lftp</h3><ul><li>优秀的文件客户端</li><li>支持各种协议</li></ul><h4 id="例子-37">例子</h4><ul><li><code>get file.txt</code> <code>mget file*.txt</code> <code>mget -c *.txt</code> 下载</li><li><code>mirror dir</code> 下载整个目录</li><li><code>mirror -R dir</code> 上传目录</li><li><code>mput new*.txt</code> <code>put file.txt</code> 上传</li></ul><h3 id="wget">wget</h3><ul><li>下载文件</li></ul><h4 id="参数-36">参数</h4><ul><li>-i 下载指定文件中列出的地址</li><li>-O 下载后重命名</li><li>-c 打开断点续传</li><li>-b 启动后转入后台执行</li><li>-P 只当保存路径</li></ul><h4 id="例子-38">例子</h4><ul><li><code>wget --limit-rate=300k -O newname.zip https://xx/xx.zip</code></li><li><code>tail -f wget-log</code> 查看下载进度</li></ul><h3 id="scp">scp</h3><ul><li>远程拷贝文件</li></ul><h4 id="参数-37">参数</h4><ul><li>-r 递归复制目录</li><li>-p 保留源文件的时间，模式属性</li><li>-P 指定传输的端口号</li></ul><h4 id="例子-39">例子</h4><ul><li><code>scp chris@ip:/home/file.txt /myhome/</code> 复制文件到指定目录</li></ul><h3 id="curl">curl</h3><ul><li>强大的文件传输工具</li></ul><h4 id="参数-38">参数</h4><ul><li>-o 指定新的本地文件名</li><li>-O 保留远程文件的原始名</li><li>-u 通过服务端配置的用户名和密码授权访问</li><li>-A 设置用户代理标头信息</li><li>-b 设置cookie信息</li><li>-C 断点续传</li><li>-s 静默模式</li><li>-T 上传文件</li></ul><h4 id="例子-40">例子</h4><ul><li><code>curl -T newfile.txt -u root:key ftp://xxxxx/xx/dir</code> 上传</li><li><code>curl -o myname.zip https://xxx/xx.zip</code> 下载并重命名</li></ul><h3 id="host">host</h3><ul><li>查询域名</li></ul><h4 id="参数-39">参数</h4><ul><li>-a 详细信息</li><li>-v 显示执行过程</li></ul><h3 id="tcpdump">tcpdump</h3><ul><li>监听网络流量</li><li>内容太多了</li></ul><h4 id="例子-41">例子</h4><ul><li><code>tcpdump -i ens33</code> 指定网络接口数据包</li><li><code>tcpdump -c 10 -q</code> 精简显示10个包</li><li><code>tcpdump host www.xxxx.xx</code></li><li><code>tcpdump -i any port 22 -A</code> 监听指定端口，并文本显示</li></ul><h3 id="nc">nc</h3><ul><li>设置路由器，建立连接, 端口扫描等等，很强大</li><li>瑞士军刀，netcat</li></ul><h4 id="参数-40">参数</h4><ul><li>-v 显示执行过程</li><li>-w&lt;超时时间&gt; 设置等待连线时间</li><li>-u udp协议</li></ul><h4 id="例子-42">例子</h4><ul><li><code>nc-v -z -w2 192xxxxip 1-100</code> 扫描端口范围</li><li><code>nc ip port</code> 连接端口</li></ul><h2 id="用户管理">用户管理</h2><h3 id="useradd">useradd</h3><ul><li>创建并设置信息</li></ul><h4 id="参数-41">参数</h4><ul><li>-m 自动创建家目录</li><li>-M 不要创建家目录</li><li>-s 指定用户登录后使用的shell</li></ul><h4 id="例子-43">例子</h4><ul><li><code>useradd -m -s /bin/bash user2</code> 常用创建方法</li><li><code>useradd -g group username</code> 指定组id</li></ul><h3 id="passwd">passwd</h3><ul><li>修改密码</li></ul><h4 id="参数-42">参数</h4><ul><li>-d 删除密码</li><li>-l 锁定用户密码值，不可改</li><li>-u 解锁，可以改</li><li>-e 下次登录强制修改密码</li><li>-k 到期还能用</li><li>-S 查询密码状态</li></ul><h4 id="例子-44">例子</h4><ul><li><code>passwd -l chris</code> 锁定密码</li></ul><h3 id="userdel">userdel</h3><ul><li>删除用户</li></ul><h4 id="例子-45">例子</h4><ul><li><code>userdel -r chris</code> 把家目录和账号都删掉</li></ul><h3 id="su">su</h3><ul><li>切换用户</li></ul><h4 id="例子-46">例子</h4><ul><li><code>su -c whoami alivin</code> 执行whoami之后退后原来的</li><li><code>su - chris</code> 切换账号并改到chris的家目录</li></ul><h3 id="sudo">sudo</h3><ul><li>管理员身份执行</li></ul><h4 id="例子-47">例子</h4><ul><li><code>sudo -l</code> 列出当前用户权限</li></ul><h3 id="id">id</h3><ul><li>显示id</li></ul><h4 id="例子-48">例子</h4><ul><li><code>id -g chris</code> 显示所属组的id</li></ul><h3 id="usermod">usermod</h3><ul><li>修改用户信息</li></ul><h4 id="例子-49">例子</h4><ul><li><code>usermod -u 1234 chris</code> 修改uid</li><li><code>usermod -l harry chris</code> 修改名字成harry</li><li><code>usermod -L chris</code> 锁定</li></ul><h3 id="groups-groupadd-groupdel">groups groupadd groupdel</h3><ul><li>组管理</li></ul><h3 id="whoami">whoami</h3><ul><li>打印当前登录用户</li></ul><h3 id="who">who</h3><ul><li>查看当前登录用户信息（所有人）</li></ul><h4 id="参数-43">参数</h4><ul><li>-a 全面信息</li><li>-b 系统最近启动工商局</li><li>-l 系统登录进程</li><li>-H 带有标题打印用户名，终端，时间</li><li>-u 已登录用户列表</li><li>-q 列出所有用户数量和名称</li></ul><h3 id="w">w</h3><ul><li>现在登录用户</li></ul><h4 id="参数-44">参数</h4><ul><li>-h 不打印头信息</li><li>-u 显示当前进程和cpu时间时忽略用户名</li><li>-s 短输出</li><li>-f 从哪登录</li><li>-o 老式输出</li><li>-i 显示ip而不是主机名</li></ul><h3 id="last">last</h3><ul><li>显示用户或终端的登录情况</li></ul><h4 id="例子-50">例子</h4><ul><li><code>last -n 5 -a -i</code> 最后一列显示ip，显示5行</li></ul><h3 id="user">user</h3><ul><li>显示当前登录的用户</li></ul><h2 id="进程查看">进程查看</h2><h3 id="top">top</h3><ul><li>实时显示进程动态</li></ul><h4 id="参数-45">参数</h4><ul><li>-d 指定刷新间隔</li><li>-c 切换显示命令名称和完整命令行</li><li>-p 通过监控进程id看一个</li><li>-n 信息更新最大次数</li></ul><h4 id="快捷键">快捷键</h4><ul><li>c 显示进程绝对路径</li><li>P cpu排序</li><li>M 内存排序</li></ul><h3 id="ps">ps</h3><ul><li>显示进程状态</li></ul><h4 id="参数-46">参数</h4><ul><li>-A 显示所有进程信息</li></ul><h4 id="例子-51">例子</h4><ul><li><code>ps -aux</code> 显示所有程序</li><li><code>ps -axf</code> 树形显示进程</li><li><code>ps -u chris</code> 指定用户</li><li><code>ps -aux | less</code> 配合less</li></ul><h3 id="pstree">pstree</h3><ul><li>树状图显示进程</li></ul><h4 id="参数-47">参数</h4><ul><li>-a 显示完整指令</li><li>-c 不使用精简表示法</li><li>-G 使用VT100终端机的列绘图字符</li><li>-h 特表指明正在执行的程序</li></ul><h3 id="pgrep">pgrep</h3><ul><li>检索进程</li></ul><h4 id="参数-48">参数</h4><ul><li>-d 设置字符用于分割id</li><li>-f 模式参数仅用于匹配进程名</li><li>-l 列出名字和id</li><li>-u 匹配指定有效用户id进程</li></ul><h3 id="lsof">lsof</h3><ul><li>查看进程打开的文件</li></ul><h4 id="例子-52">例子</h4><ul><li><code>lsof +d /home</code> 显示指定目录中被调用的文件信息</li><li><code>lsof -c bash</code> 只当某个程序的信息</li><li><code>lsof +D /home</code> 递归显示</li><li><code>lsof /bin/bash</code> 查看谁在用这个文件</li></ul><h2 id="进程操作">进程操作</h2><h3 id="jobs-bg-fg">jobs/bg/fg</h3><ul><li>终端任务调度</li></ul><h4 id="例子-53">例子</h4><ul><li><code>jobs -l</code> 列出当前shell任务</li><li><code>fg 2</code> 调至前台</li><li><code>ctrl+z</code> 后台</li><li><code>bg 2</code> 后台</li></ul><h3 id="kill">kill</h3><ul><li>发送信号到进程</li></ul><h4 id="常用信号">常用信号</h4><ul><li>9 终止</li><li>3 退出ctrl \</li><li>2 终端ctrl+c</li><li>1 终端断线</li><li>15 终止</li><li>19 暂停</li><li>18 继续</li></ul><h4 id="例子-54">例子</h4><ul><li><code>kill -9 18889</code> 杀死进程</li></ul><h3 id="killall">killall</h3><ul><li>杀死进程</li><li>也能发送信号</li></ul><h4 id="参数-49">参数</h4><ul><li>-l 打印所有信号</li><li>-u 杀死指定用户进程</li></ul><h4 id="例子-55">例子</h4><ul><li><code>killall sleep</code> 杀死所有sleep进程</li></ul><h3 id="nice-renice">nice/renice</h3><ul><li>调整进程优先级</li></ul><h4 id="参数-50">参数</h4><ul><li>-n 接数值</li><li>-g 指定进程组</li><li>-p 改变优先级等级</li><li>-u 指定开启进程的用户名</li></ul><h4 id="例子-56">例子</h4><ul><li><code>nice -15 vim &amp;</code> <code>nice -n 15 vim &amp;</code> 设置优先级</li><li><code>renice 6 -p 6666</code> 把6666进程改优先值</li></ul><h3 id="nohup">nohup</h3><ul><li>后台运行，不显示终端</li></ul><h2 id="包管理">包管理</h2><h3 id="apt">apt</h3><ul><li>包管理器</li></ul><h4 id="例子-57">例子</h4><ul><li><code>sudo apt update upgrade</code></li><li><code>sudo apt upgrade vim</code></li><li><code>sudo apt install bat</code> 安装</li><li><code>sudo apt remove bat</code> 卸载</li><li><code>sudo apt show bat</code> 展示软件包信息</li><li><code>sudo apt autoremove</code> 自动清理依赖和库文件</li><li><code>sudo apt list --installed</code> 列出已安装的软件包</li></ul><h3 id="apt-get">apt-get</h3><ul><li>类似的，用apt</li></ul><h2 id="环境变量">环境变量</h2><h3 id="export">export</h3><ul><li>显示设置环境变量</li><li>仅仅本次登录</li></ul><h4 id="例子-58">例子</h4><ul><li><code>export -p</code> 列出</li><li><code>export MYenv=7</code> 定义环境变量</li><li><code>export PATH=$PATH:/usr/local/mysql/bin</code> 修改变量</li></ul><h4 id="配置文件">配置文件</h4><ul><li><code>/etc/porfile</code> 所有用户</li><li><code>~/.bashrc</code> 当前用户</li></ul><h3 id="source">source</h3><ul><li>更新环境变量</li><li>可以用 <code>.</code> 来代替</li></ul><h4 id="例子-59">例子</h4><ul><li><code>. ~/.bashrc</code> 读取和执行bashrc文件</li></ul><h2 id="终端操作">终端操作</h2><h3 id="echo">echo</h3><ul><li>输出字符串</li></ul><h4 id="例子-60">例子</h4><ul><li><code>echo $PATH</code> $把path提取出来打印</li><li><code>echo &quot;hello&quot; &gt; file.txt</code> 定向到文件</li><li><code>echo -e &quot;a\nb\nc&quot;</code> 开启转义</li><li>Echo `date` 能执行命令，显示结果</li></ul><h3 id="clear">clear</h3><ul><li>清理屏幕</li></ul><h3 id="history">history</h3><ul><li>管理命令记录</li></ul><h4 id="参数-51">参数</h4><ul><li>-c 清空记录</li><li>-d 删除指定序号的记录</li><li>-n 读取命令记录</li></ul><h4 id="例子-61">例子</h4><ul><li><code>!2039</code> 重新执行2039命令</li><li><code>!!</code> 执行上一条</li></ul><h3 id="login-logout">login/logout</h3><ul><li>登入登出</li></ul><h3 id="exit">exit</h3><ul><li>退出终端/ssh</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自动控制原理第一章</title>
      <link href="/posts/a48157de.html"/>
      <url>/posts/a48157de.html</url>
      
        <content type="html"><![CDATA[<h1>1.2自动控制基本原理</h1><h2 id="人工控制与自动控制">人工控制与自动控制</h2><ul><li>操作人员完成控制——人工控制</li><li>自动控制模仿了人工控制</li><li>自动控制元件<ul><li>给定元件</li><li>测量元件</li><li>比较元件</li><li>校正元件</li><li>执行元件</li></ul></li></ul><h2 id="1-2-2开环控制与闭环控制">1.2.2开环控制与闭环控制</h2><ul><li>归为基本控制方式</li></ul><h3 id="1-开环控制系统">1.开环控制系统</h3><ul><li>方块 表示系统中的功能元件</li><li>箭头有向线段 元件之间的输入输出传递方向</li><li>外部干扰较弱，精度要求不高场合</li><li>特征：没有反向的信号回传；抗干扰能力差；成本低</li></ul><h3 id="闭环控制系统">闭环控制系统</h3><ul><li>信息在系统内的传递形成了闭合环路</li><li>通道<ul><li>前向通道：信号从输入到输出方向传递的通路</li><li>反馈通道：输出到输入</li></ul></li><li>闭环控制系统利用反馈信号获得比较偏差来产生控制作用，故也称为反馈控制系统。</li><li>内部参数精度没有这么高；增加了反馈元件和比较元件；结构比较复杂，搞不好会震荡</li><li>系统是自动控制还是手动控制与系统是开环还是闭环<strong>无关</strong>。</li></ul><h2 id="反馈控制系统的基本要求">反馈控制系统的基本要求</h2><h3 id="稳定性">稳定性</h3><ul><li>稳定性是指系统受扰动后<strong>重新恢复平衡</strong>的能力</li><li>稳定是衰减过程，等幅振荡（临界稳定过程）；不稳定为发散过程</li></ul><h3 id="快速性">快速性</h3><ul><li>稳定的系统对平衡状态的<strong>恢复或跟随</strong>的速度</li><li>影响因素<ul><li>扰动</li><li>任务需要改变平衡状态</li></ul></li></ul><h3 id="准确性">准确性</h3><ul><li>跟随期待量的能力</li><li>系统输出量的期望值与实际值之差称为稳态误差，越小稳态精度越高；为零就是无差系统，不为零就是有差系统</li></ul><h1>反馈系统的组成</h1><h2 id="按构成系统的基本元件划分">按构成系统的基本元件划分</h2><ul><li>测量元件：测量，量纲转换</li><li>比较元件：形成偏差</li><li>校正元件：基于偏差产生控制命令</li><li>执行元件：执行控制命令</li><li>放大元件：对信号家乡放大</li><li>被控对象：受控对象</li></ul><h2 id="按系统内部基本功能环节划分">按系统内部基本功能环节划分</h2><ul><li>传感器：测量</li><li>控制器：产生执行的控制信号</li><li>执行机构：执行器，控制/调节被控过程</li><li>被控对象：被控过程</li></ul><h2 id="常见术语">常见术语</h2><ul><li>p11 略</li></ul><h1>控制系统分类</h1><h2 id="按参考输入信号特征分类">按参考输入信号特征分类</h2><h3 id="恒值控制系统">恒值控制系统</h3><ul><li>输入信号恒定</li></ul><h3 id="随动控制系统">随动控制系统</h3><ul><li>伺服系统</li><li>参考输入信号为预先未知的函数</li></ul><h3 id="程序控制系统">程序控制系统</h3><ul><li>参考输入信号是预先设定的函数曲线</li></ul><h2 id="按系统环节间信号传递形式分类">按系统环节间信号传递形式分类</h2><h3 id="连续时间控制系统">连续时间控制系统</h3><ul><li>环节间的信号传递为t的连续函数</li></ul><h3 id="离散时间控制系统">离散时间控制系统</h3><ul><li>脉冲序列/数字编码序列形式</li><li>差分方程描述</li><li>控制器输入输出为数字量，A/D</li></ul><h3 id="网络化控制系统">网络化控制系统</h3><ul><li>不连续信号——一个个包含数据和网络控制信息的数据包</li></ul><h2 id="按描述系统的动态方程分类">按描述系统的动态方程分类</h2><h3 id="线性系统">线性系统</h3><ul><li>满足线性叠加原理</li></ul><h3 id="非线性系统">非线性系统</h3><ul><li>非线性微分方程</li></ul><h3 id="定常系统">定常系统</h3><ul><li>定常微分方程</li><li>时不变系统</li></ul><h3 id="时变系统">时变系统</h3><ul><li>微分方程描述</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自动控制原理第二章</title>
      <link href="/posts/9a8d65cc.html"/>
      <url>/posts/9a8d65cc.html</url>
      
        <content type="html"><![CDATA[<h1>mathjax: true</h1><h1>- Date:2024-03-05</h1><ul><li>Time:17:02</li><li>Subject:</li><li>Tags:<br>[[2024-03]]</li></ul><hr><h1>系统的微分方程</h1><h2 id="物理系统微分方程">物理系统微分方程</h2><blockquote><p>[!note]<br>步骤</p><ol><li>定义系统及其组成元件</li><li>确定必要的假设条件</li><li>利用系统自身的物理规律</li><li>利用各组成元件的原始方程和前面所确定的输入量、中间变量和输出量，<strong>消去中间变量</strong>，建立描述系统输入量与输出量之间关系的微分方程</li><li>若得到的是线性微分方程，通常将其列写为<strong>标准形式</strong>，即将与输出量和输入量有关的各项分别列写在等号左右两边**（左出右入）<strong>，并且两边各导数项均按</strong>降幂排列**。若得到的是非线性微分方程，则需要对非线性微分方程进行<strong>线性化处理</strong>才能列写为线性微分方程的标准形式</li></ol></blockquote><ul><li>线性叠加</li><li>例p24</li><li>几阶系统看最高次导数</li><li>时间常数</li><li>$$T_m=J_m R_a /\left(\beta_m R_a+C_e C_m\right)$$</li><li>电压传递常数和转矩传递常数</li><li>$$\frac  {  C_m  }    {  \beta_m R_a+C_e C_m  }   u_a(t)-\frac  {  R_a  }    {  \beta_m R_a+C_e C_m  }   M_c(t)$$</li></ul><h2 id="微分方程的增量化和无因次化">微分方程的增量化和无因次化</h2><h3 id="增量化">增量化</h3><ul><li>微分方程变量各阶导数为0，变化率0，也称为静态数学模型，例如 <code>t=0</code> 系统处于稳定工作状态，又称为平衡状态，此时各变量可视为常量，则各阶导数均为零</li><li>初步认识：微分方程=稳态+瞬态</li><li>平衡状态方程，导数等于0，解出当前t0</li><li>非增量微分方程消去常数项后，各变量前添加Δ</li></ul><h3 id="无因次化">无因次化</h3><p>考虑微分方程</p><p>$$ T_  {  m  }   \frac  {  d \omega( t )  }     {  d t  }  +\omega( t )=K_  {  u  }   u_  {  a  }   ( t )-K_  {  M  }   M_  {  c  }   ( t ) $$</p><p>平衡位置：<br>$$\omega( t_  {  0  }   )=\omega_  {  0  }  , \ \ u_  {  a  }   ( t_  {  0  }   )=u_  {  a 0  }  , \ \ M_  {  c  }   ( t_  {  0  }   )=M_  {  c 0  }  ,$$</p><p>满足<br>$$\omega_  {  0  }  =K_  {  u  }   u_  {  a 0  }  -K_  {  M  }   M_  {  c 0  }  $$<br>再令：</p><p>$$\overline  {     {     {     {  \omega  }     }     }     }   ( t ) !=! \frac  {  \omega( t )  }     {  \omega_  {  0  }     }  , \ \ \overline  {     {     {     {  u  }     }     }     }  _  {  a  }   ( t ) !=! \frac  {  u_  {  a  }   ( t )  }     {  u_  {  a 0  }    }  , \ \ \overline  {     {     {     {  M  }    }     }     }  _  {  c  }   ( t ) !=! \frac  {  M_  {  c  }   ( t )  }     {  M_  {  c 0  }     }   $$</p><p>$$T_  {  m  }   \frac  {  d \overline   {    {    {    {  \omega  }    }     }    }   ( t )  }     {  d t  }  +\overline   {    {    {    {  \omega  }    }     }    }   ( t )=\frac  {  K_  {  u  }   u_  {  a 0  }    }     {  \omega_  {  0  }    }   \overline   {    {    {    {  u  }    }     }    }  _  {  a  }   ( t )-\frac  {  K_  {  M  }   M_  {  c 0  }    }     {  \omega_  {  0  }    }   \overline   {    {    {    {  M  }    }     }    }  _  {  c  }   ( t )$$</p><ul><li>时间还是绝对化描述</li><li>令<br>$$\tau=t / T_  {  m  }  $$</li><li>时间常数，作为标称<br>$$T_  {  m  }  $$</li></ul><p>$$\frac  {  d \overline  {     {     {     {  \omega  }     }     }     }   ( \tau T_  {  m  }   )  }     {  d \tau  }  +\overline  {     {     {     {  \omega  }     }     }     }   ( \tau T_  {  m  }   ) !=! \frac  {  K_  {  u  }   u_  {  a 0  }    }     {  \omega_  {  0  }    }   \overline  {     {     {     {  u  }     }     }     }  _  {  a  }   ( \tau T_  {  m  }   ) !-! \frac  {  K_  {  M  }   M_  {  c 0  }    }     {  \omega_  {  0  }    }   \overline  {     {     {     {  M  }     }     }     }  _  {  c  }   ( \tau T_  {  m  }   ) !$$</p><h2 id="非线性方程线性化">非线性方程线性化</h2><ul><li>在小范围内线性处理，且选择在<strong>平衡状态点</strong>进行增量化描述</li><li>考虑高次，低次去掉偏导</li></ul><p>$$\begin{aligned}     {    {  y ( t )  }    }   &amp;   {    {    }     {    {    }  =f ( x_  {  1  }   ( t ), x_  {  2  }   ( t ) )  }    }   \   {    {    }    }   &amp;   {    {    }     {    {    }     {    }  =f ( x_  {  1 0  }  , x_  {  2 0  }   )+\frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  1  }    }   \Bigg|_  {  \stackrel  {  x_  {  i  }  =x_  {  i 0  }    }     {  x_  {  i  }  =x_  {  i 0  }    }    }   \frac  {  \Delta x_  {  1  }    }     {  1!  }  +\frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  2  }    }   \Bigg|_  {  \stackrel  {  x_  {  i  }  =x_  {  i 0  }    }     {  x_  {  i  }  =x_  {  i 0  }    }    }   \frac  {  \Delta x_  {  2  }    }     {  1!  }    }    }   \ \end{aligned}   $$</p><p>$$+ \frac  {  \partial^  {  2  }   f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  1  }  ^  {  2  }    }   \Bigg|_  {  x_  {  1  }  =x_  {  i_  {  0  }    }   \atop x_  {  2  }  =x_  {  i_  {  0  }    }    }   \frac  {  \big( \Delta x_  {  1  }   \big)^  {  2  }    }     {  2!  }  +\frac  {  \partial^  {  2  }   f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  2  }  ^  {  2  }    }   \Bigg|_  {  x_  {  1  }  =x_  {  i_  {  0  }    }   \atop x_  {  2  }  =x_  {  i_  {  0  }    }    }   \frac  {  \big( \Delta x_  {  2  }   \big)^  {  2  }    }     {  2!  }  +\cdots $$</p><ul><li>当增量Δx1=x1-x10 Δx2=x2=x20足够小，忽略高次方的项</li></ul><p>$$\begin{array}     {  r  }     {    {    {  \Delta y ( t )=y ( t )-y_  {  0  }  =f ( x_  {  1  }   ( t ), x_  {  2  }   ( t ) )-f ( x_  {  1 0  }  , x_  {  2 0  }   )  }    }    }   \   {    {    {  =\left. \frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  1  }    }   \right|_  {  x_  {  1  }  =x_  {  0  }    }   \Delta x_  {  1  }   ( t )+\left. \frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  2  }    }   \right|_  {  x_  {  1  }  =x_  {  0  }    }   \Delta x_  {  2  }   ( t )  }    }    }   \   {    {    {  =K_  {  1  }   \Delta x_  {  1  }   ( t )+K_  {  2  }   \Delta x_  {  2  }   ( t )  }    }    }   \ \end{array}   $$</p><p>$$其中<br>K_  {  1  }  =\frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  1  }    }   \Bigg|_  {  \stackrel  {  x_  {  1  }  =x_  {  1 0  }    }     {  x_  {  2  }  =x_  {  2 0  }    }    }   ;, ; ; ; K_  {  2  }  =\frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  2  }    }   \Bigg|_  {  \stackrel  {  x_  {  1  }  =x_  {  1 0  }    }     {  x_  {  2  }  =x_  {  2 0  }    }    }   $$</p><h2 id="传递函数">传递函数</h2><ul><li>引入复数将时间域问题转化为复频率域问题来研究，将解微分方程问题简化为解代数问题</li></ul><h3 id="线性系统传递函数的概念和定义">线性系统传递函数的概念和定义</h3><ul><li>传递函数=系统输出的拉氏变换/输入的拉氏变换</li><li>输入与输出之间的关系 （固有特性）, 与输入的具体形式无关，都以相同的传递作用输出</li><li>标准线性系统的传递模型<br>$$<br>G ( s ) !=! \frac  {  Y ( s )  }     {  U ( s )  }   !=! \frac  {  b_  {  m  }   s^  {  m  }  +b_  {  m-1  }   s^  {  m-1  }  +\cdots+b_  {  1  }   s+b_  {  0  }    }     {  a_  {  n  }   s^  {  n  }  +a_  {  n-1  }   s^  {  n-1  }  +\cdots+a_  {  1  }   s+a_  {  0  }    }<br>$$</li><li>初始条件下有<br>$$<br>f ( 0 )=f^  {  \prime  }   ( 0 )=\cdots=f^  {  n-1  }   ( 0 )=0 ,, \ \ L \Biggl[ \frac  {  d^  {  n  }   f ( t )  }     {  d t^  {  n  }    }   \Biggr]=\Biggl( s^  {  n  }   F ( s ) \Biggr)<br>$$</li><li>通过上式，下式两边拉氏变换</li></ul><p>$$<br>\begin{aligned}     {    {  a_  {  n  }     {  \frac  {  \mathrm  {  d  }  ^  {  n  }   y ( t )  }     {  \mathrm  {  d  }   t^  {  n  }    }    }    }    }   &amp;   {    {    }     {    {    }  +a_  {  n-1  }     {  \frac  {  \mathrm  {  d  }  ^  {  n-1  }   y ( t )  }     {  \mathrm  {  d  }   t^  {  n-1  }    }    }  +\cdots+a_  {  1  }     {  \frac  {  \mathrm  {  d  }   y ( t )  }     {  \mathrm  {  d  }   t  }    }  +a_  {  0  }   y ( t )  }    }   \   {    {    }    }   &amp;   {    {    }     {    {    }  =b_  {  m  }     {  \frac  {  \mathrm  {  d  }  ^  {  m  }   u ( t )  }     {  \mathrm  {  d  }   t^  {  m  }    }    }  +b_  {  m-1  }     {  \frac  {  \mathrm  {  d  }  ^  {  m-1  }   u ( t )  }     {  \mathrm  {  d  }   t^  {  m-1  }    }    }  +\cdots+b_  {  1  }     {  \frac  {  \mathrm  {  d  }   u ( t )  }     {  \mathrm  {  d  }   t  }    }  +b_  {  0  }   u ( t )  }    }   \ \end{aligned}<br>$$</p><ul><li>有如下，化简最后得到标准的模型</li><li></li></ul><p>$$<br>\begin{aligned} { {a_{n} s^{n} Y ( s )+}} &amp; { {} { {} a_{n-1} s^{n-1} Y ( s )+\cdots+a_{1} s Y ( s )+a_{0} Y ( s )}} \ { {} } &amp; { {} { {} {}=b_{m} s^{m} U ( s )+b_{m-1} s^{m-1} U ( s )+\cdots+b_{1} s U ( s )+b_{0} U ( s )} } \ \end{aligned}<br>$$</p><ul><li>对于多个输入，分析时，将另外一个输入关闭</li></ul><p>$$<br>\Omega( s )=G_  {  1  }   ( s ) U_  {  a  }   ( s )+G_  {  2  }   ( s ) M_  {  c  }   ( s )<br>$$</p><blockquote><p>[!note] 说明</p><ul><li>传递函数是对线性定常微分方程求拉普拉斯变换得到的，因此，传递函数表达式中各项系数的值完全与微分方程中各导数项的系数相对应，取决于系统的结构和参数。</li><li>分母最高次n，n阶系统，n≥m，真有理函数</li><li>单入单出</li></ul></blockquote><h3 id="传递函数常用表现形式">传递函数常用表现形式</h3><ol><li>零、极点表示的形式<br>$$<br>G ( s )=\frac  {  b_  {  m  }    }     {  a_  {  n  }    }   \times\frac  {  s^  {  m  }  +d_  {  m-1  }   s^  {  m-1  }  +\cdots+d_  {  1  }   s+d_  {  0  }    }     {  s^  {  n  }  +c_  {  n-1  }   s^  {  n-1  }  +\cdots+c_  {  1  }   s+c_  {  0  }    }<br>= K_  {  g  }   , \frac  {  ( s+z_  {  1  }   ) ( s+z_  {  2  }   ) \cdots( s+z_  {  m  }   )  }     {  ( s+p_  {  1  }   ) ( s+p_  {  2  }   ) \cdots( s+p_  {  n  }   )  }  =K_  {  g  }   , \frac  {  \prod_  {  i=1  }  ^  {  m  }   ( s+z_  {  i  }   )  }     {  \prod_  {  l=1  }  ^  {  n  }   ( s+p_  {  l  }   )  }<br>$$</li><li>实数极点和共轭复数极点细化形式</li></ol><ul><li>不同极点种类性质不同<br>$$<br>G ( s )=\frac  {  K_  {  g  }    }     {  s^  {  \nu  }    }   \times\frac  {  \prod_  {  i=1  }  ^  {  m  }   ( s+z_  {  i  }   )  }     {  \prod_  {  l=\nu+1  }  ^  {  \nu+n_  {  i  }    }   ( s+p_  {  l  }   ) \prod_  {  l=\nu+n_  {  i  }  +1  }  ^  {  \nu+n_  {  i  }  +( s-\nu-n_  {  i  }   ) / 2  }   ( s^  {  2  }  +2 \zeta_  {  l  }   \omega_  {  l  }   s+\omega_  {  l  }  ^  {  2  }   )  }<br>$$</li><li>$K_  {  g  }  =\frac  {  b_  {  m  }    }     {  a_  {  n  }    }  $ ,称增益或传递系数</li><li>-z : 传递函数的零点，由 $G ( s )=0$ 求得，用“”表示;</li><li>$- p_  {  l  }  $ : 传递函数的极点，由 $G ( s )=\infty$ 求得，用“×”表示;</li><li>v：系统型数，决定稳态误差</li><li>共轭极点：与震荡有关</li></ul><ol start="3"><li>时间常数表示</li></ol><p>$$<br>G ( s )=\frac  {  b_  {  0  }    }     {  a_  {  0  }    }   \times\frac  {  d_  {  m  }  ^  {  \prime  }   s^  {  m  }  +d_  {  m-1  }  ^  {  \prime  }   s^  {  m-1  }  +\cdots+d_  {  1  }  ^  {  \prime  }   s+1  }     {  c_  {  n  }  ^  {  \prime  }   s^  {  n  }  +c_  {  n-1  }  ^  {  \prime  }   s^  {  n-1  }  +\cdots+c_  {  1  }  ^  {  \prime  }   s+1  }  =K \frac  {  ( \tau_  {  1  }   s+1 ) ( \tau_  {  2  }  ^  {  2  }   s^  {  2  }  +\tau_  {  2  }   \zeta s+1 ) \cdots( \tau_  {  i  }   s+1 )  }     {  ( T_  {  i  }   s+1 ) ( T_  {  2  }  ^  {  2  }   s^  {  2  }  +T_  {  2  }   \zeta s+1 ) \cdots( T_  {  j  }   s+1 )  }<br>$$<br>$$<br>G ( s )=\frac  {  K  }     {  s^  {  \nu  }    }   \times\frac  {  \prod_  {  i=1  }  ^  {  m  }   \left( \tau_  {  i  }   s+1 \right)  }     {  \prod_  {  l=\nu+1  }  ^  {  \nu+n_  {  i  }    }   ( T_  {  l  }   s+1 ) \prod_  {  l=\nu+n_  {  i  }  +1  }  ^  {  \nu+n_  {  i  }  +( n-\nu-n_  {  i  }   ) / 2  }   ( T_  {  l  }  ^  {  2  }   s^  {  2  }  +2 \xi_  {  l  }   T_  {  l  }   s+1 )  }<br>$$</p><ul><li>$\tau_  {  i  }  , T_  {  i  }  $ : 时间常数</li><li>$K : K=G ( 0 ),$ 直流增益或静态放大系数</li></ul><h3 id="典型输入信号及其拉普拉斯变换">典型输入信号及其拉普拉斯变换</h3><ol><li>单位阶跃信号</li></ol><p>$$<br>1 ( t )=\begin{cases}     {    {    {  1,  }    }    }   &amp;   {    {    {  t \geqslant0  }    }    }   \   {    {    {  0,  }    }    }   &amp;   {    {    {  t &lt; 0  }    }    }   \ \end{cases}  .<br>$$</p><p>$$<br>L   {  \bigl[  }   1 ( t )   {  \bigr]  }  =  {  \frac  {  1  }     {  s  }    }<br>$$</p><ol start="2"><li>单位斜坡函数</li></ol><p>$$<br>r ( t )=\left{\begin{array} {c c} { { {t,} } } &amp; { { {t \geqslant0} } } \ { { {0,} } } &amp; { { {t &lt; 0} } } \ \end{array} \right.<br>$$</p><p>$$<br>L \bigl[ r ( t ) \bigr]=\frac  {  1  }     {  s^  {  2  }    }<br>$$<br>3. 单位抛物线<br>4. 单位脉冲函数</p><p>$$<br>\delta( t )=\operatorname*   {  l i m  }  _  {  \varepsilon\to0  }   \delta_  {  \varepsilon  }   ( t )<br>$$</p><p>$$<br>\delta_{\varepsilon} ( t )=\left{\begin{aligned} { { {0} } } &amp; { { {} { {},} } } &amp; { { { {} {} { {} t &lt; 0} } } } \ { { { {} } } } &amp; { { {} { {} { {} \frac{1} {\varepsilon}},} } } &amp; { { { {} 0 \leq{}t \leq\varepsilon} } } \ { { { {} } } } &amp; { { {} } } \ { { { {0},} } } &amp; { { { {} {} { {} t &gt; \varepsilon} } } } \ \end{aligned} \right.<br>$$</p><ul><li>δ函数的强度，也称单位脉冲函数的冲量定义为 $S=\int_  {  -\infty  }  ^  {  +\infty  }   \delta( t ) \mathrm  {  d  }   t=1$</li></ul><p>$$<br>L \big[ \delta( t ) \big]=1<br>$$</p><ul><li>由于理论分析而已，是理想的函数</li></ul><h3 id="单位脉冲响应函数">单位脉冲响应函数</h3><ul><li>卷积公式</li><li></li></ul><p>$$<br>y ( t )=L^  {  -1  }   [ Y ( s ) ]=L^  {  -1  }   [ G ( s ) R ( s ) ]=\int_  {  0  }  ^  {  +\infty  }   g ( \tau) r ( t-\tau) \mathrm  {  d  }   \tau, ; ; ; t \geq0<br>$$</p><blockquote><p>[!note]<br>线性定常系统的单位脉冲响应<strong>数值上</strong>等于改系统传递函数的反拉氏变换</p></blockquote><p>U（s）=1 （t）</p><h3 id="求解系统输出响应">求解系统输出响应</h3><ul><li>输出求解为<br>$$<br>y ( t )=L^  {  -1  }   \bigl[ Y ( s ) \bigr]=L^  {  -1  }   \bigl[ G ( s ) U ( s ) \bigr]=L^  {  -1  }   \bigl[ F ( s ) \bigr]<br>$$</li><li>解法<ul><li>结合留数进行求解最终大多是exp（-xxt），位移性质</li><li>重根考虑求导加那个感叹号</li></ul></li></ul><h3 id="典型环节及其传递函数">典型环节及其传递函数</h3><ol><li>比例环节</li></ol><ul><li><p>输入输出成比例<br>$y ( t )=K u ( t )$<br>$$<br>G ( s )=  {  \frac  {  Y ( s )  }     {  U ( s )  }    }  =K<br>$$</p></li><li><p>常见的比例环节实例有分压器、变压器、杠杆、线性放大器、无隙的传动齿轮组等</p></li></ul><ol start="2"><li>积分环节</li></ol><ul><li>输入的累积，表现为<strong>输出的变化速度和输入成正比</strong></li><li>在单位阶跃输入激励下，积分环节的输出响应Y（t） 随时间直线上升</li></ul><p>$$<br>微分方程:y ( t )=K ! \int u ( t ) \mathrm  {  d  }   t<br>$$</p><p>$$<br>G ( s )=  {  \frac  {  Y ( s )  }     {  U ( s )  }    }  =  {  \frac  {  K  }     {  s  }    }  =  {  \frac  {  1  }     {  T s  }    }<br>$$</p><ol start="3"><li>惯性环节</li></ol><ul><li>物体对运动状态变化的阻抗程度</li></ul><p>$$<br>微分方程:T   {  \frac  {  \mathrm  {  d  }   y ( t )  }     {  \mathrm  {  d  }   t  }    }  +y ( t )=u ( t )<br>$$<br>$$<br>G ( s )=  {  \frac  {  Y ( s )  }     {  U ( s )  }    }  =  {  \frac  {  1  }     {  T s+1  }    }<br>$$</p><ul><li>单位阶跃响应<br>$$<br>Y ( s ) !=! G ( s ) U ( s ) !=!   {  \frac  {  1  }     {  T s+1  }    }     {  \frac  {  1  }     {  s  }    }   !=!   {  \frac  {  1 / T  }     {  s ( s !+! 1 / T )  }    }   !=!   {  \frac  {  1  }     {  s  }    }   !-!   {  \frac  {  1  }     {  s !+! 1 / T  }    }<br>$$</li><li>跟随速度由T决定</li></ul><ol start="4"><li>振荡环节（二阶振荡环节）</li></ol><p>$$<br>T^  {  2  }   , \frac  {  \mathrm  {  d  }  ^  {  2  }   y ( t )  }     {  \mathrm  {  d  }   t^  {  2  }    }   !+! 2 \zeta T \frac  {  \mathrm  {  d  }   y ( t )  }     {  \mathrm  {  d  }   t  }   !+! y ( t ) !=! u ( t )<br>$$<br>$$<br>G ( s )=\frac  {  1  }     {  T^  {  2  }   s^  {  2  }  +2 \zeta T s+1  }<br>$$<br>$T$ : 时间常数<br>$\zeta$ : 阻尼比 $0 &lt; \zeta&lt; 1$<br>$\omega_{  n  }$ : 自然振荡角频率</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客第一文</title>
      <link href="/posts/b6ebd1b0.html"/>
      <url>/posts/b6ebd1b0.html</url>
      
        <content type="html"><![CDATA[<h1>简简单单的记录一下</h1><p><em>建立该博客用于记录各种事情吧~</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>hello!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;}div#menus {    font-family: "ZhuZiAYuanJWD";}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}.icon-zhongbiao::before {    color: #f7c768;}/* bilibli番剧插件 *//* #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;}a.bangumi-tab:hover {    text-decoration: none !important;}.bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;}.bangumi-button {    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size: 1.1em;}.bangumi-info-item {    border-right: 1px solid #f2b94b;}.bangumi-info-item span {    color: #f2b94b;}.bangumi-info-item em {    color: #f2b94b;} *//* 解决artitalk的图标问题 */#uploadSource>svg {    width: 1.19em;    height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {    background-color: transparent !important;}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);}/* 文章页面正文背景 */div#post {    background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page {    background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive {    background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag {    background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category {    background: rgba(255, 255, 255, 0.9);}/*夜间模式伪类遮罩层透明*/[data-theme="dark"] #recent-posts>.recent-post-item {    background: #121212;}[data-theme="dark"] .card-widget {    background: #121212 !important;}[data-theme="dark"] div#post {    background: #121212 !important;}[data-theme="dark"] div#tag {    background: #121212 !important;}[data-theme="dark"] div#archive {    background: #121212 !important;}[data-theme="dark"] div#page {    background: #121212 !important;}[data-theme="dark"] div#category {    background: #121212 !important;}[data-theme="dark"] div#category {    background: transparent !important;}/* 页脚透明 */#footer {    background: transparent !important;}/* 头图透明 */#page-header {    background: transparent !important;}#rightside>div>button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */    /* 默认情况下缩进左侧66px，只留一点箭头部分 *//* .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;} */    /* 鼠标悬停是左侧缩进归零，完全显示按钮 *//* .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;} *//* .aplayer.aplayer-fixed {    z-index: 999999 !important;} *//* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime.min.css"/>
      <url>/css/runtime.min.css</url>
      
        <content type="html"><![CDATA[div#runtime {    width: 180px;    margin: auto;    color: #fff;    padding-inline: 5px;    border-radius: 10px;    background-color: rgba(0, 0, 0, .7)}#workboard {    font-size: 12px}[data-theme=dark] div#runtime {    color: #28b4c8;    box-shadow: 0 0 5px rgba(28, 69, 218, .71);    animation: flashlight 1s linear infinite alternate}#ghbdages .github-badge img {    height: 20px}@-moz-keyframes flashlight {    from {        box-shadow: 0 0 5px #1478d2    }    to {        box-shadow: 0 0 2px #1478d2    }}@-webkit-keyframes flashlight {    from {        box-shadow: 0 0 5px #1478d2    }    to {        box-shadow: 0 0 2px #1478d2    }}@-o-keyframes flashlight {    from {        box-shadow: 0 0 5px #1478d2    }    to {        box-shadow: 0 0 2px #1478d2    }}@keyframes flashlight {    from {        box-shadow: 0 0 5px #1478d2    }    to {        box-shadow: 0 0 2px #1478d2    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.min.js"/>
      <url>/js/runtime.min.js</url>
      
        <content type="html"><![CDATA[var now = new Date();function createtime() {  var t = new Date("08/11/2023 00:00:00");  now.setTime(now.getTime() + 250);  var e = (now - t) / 1e3 / 60 / 60 / 24,    a = Math.floor(e),    n = (now - t) / 1e3 / 60 / 60 - 24 * a,    r = Math.floor(n);  1 == String(r).length && (r = "0" + r);  var s = (now - t) / 1e3 / 60 - 1440 * a - 60 * r,    i = Math.floor(s);  1 == String(i).length && (i = "0" + i);  var o = (now - t) / 1e3 - 86400 * a - 3600 * r - 60 * i,    l = Math.round(o);  1 == String(l).length && (l = "0" + l);  let g = "";  (g =    r < 18 && r >= 9      ? `<span class='textTip'> 本站勉强运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-check-square' style='color:white'></i>`      : `<span class='textTip'> 本站勉强运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-check-square' style='color:white'></i>`),    document.getElementById("workboard") &&      (document.getElementById("workboard").innerHTML = g);}setInterval(() => {  createtime();}, 250);]]></content>
      
    </entry>
    
    
  
</search>

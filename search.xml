<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微机原理整理</title>
      <link href="/posts/8731d904.html"/>
      <url>/posts/8731d904.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><ul><li>摩尔定律(Moore’s Law)：<strong>微处理器内晶体管的集成度每两年增加一倍；</strong></li><li>吉尔德定律(Gilder,s Law)<strong>：主干网的带宽</strong>每 6 个月增加一倍；</li><li>麦特卡夫定第(Metcalfe’sLaw)：网络价值与网络用户数的平方成正比</li></ul><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><ul><li>泛在计算特别关注所谓的隐蔽性 (Invisibleness) 和环境感知性 (Context Awareness) 环境感知是泛在计算技术的核心；泛在通信即广泛存在的通信，以实现在任何时间、任何地点、任何人、任何物都能顺畅地通信为目标。</li><li>普适计算具有环境感知的特性<ul><li>强调和环境融为一体的计算概念，即人们能够在任何时间、任何地点、以任何方式进行信息的获取与处理。</li></ul></li><li>无线传感器网络 (Wireless Sensor Network, WSN)也称为泛在传感器网络 (Ubiquitous Sensor Network, USN) , 是一种由多个节点组成的、面向任务的无线自组织网络。<ul><li>自组织组网</li><li>多跳路由</li><li>资源受限</li><li>低功耗</li></ul></li></ul><h2 id="1-2-集成电路与-SoC-设计"><a href="#1-2-集成电路与-SoC-设计" class="headerlink" title="1.2 集成电路与 SoC 设计"></a>1.2 集成电路与 SoC 设计</h2><blockquote><ul><li>集成电路是指通过一系列特定的加工工艺，将晶体管、二极管等有源器件和电阻、电容、电感等无源器件，按照一定方式互连，“集成”在一块半导体晶片(如硅或神化像)上，封装在一个外壳内，执行特定电路或系统功能的一种器件。</li></ul></blockquote><ul><li><strong>特征尺寸</strong>(Feature Size)与集成规模(<strong>Integration</strong> Scale)是标志集成电路工艺技术水平的两个<strong>重要指标。</strong><ul><li><strong>特征尺寸</strong>表征了集成电路工艺所能实现的最<strong>小线宽</strong></li></ul></li><li><strong>系统级芯片(System on Chip, SoC)，SoC 也称为片上系统、系统芯片或系统集成芯片。</strong><ul><li>SoC 包括一个<strong>可编程处理器(叶)、片上存储器和由硬件实现的加速功能单元(如 DSP)</strong>。此外，SoC 作为一个系统，需要直接与外界打交道</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412141927564.png" alt="image.png|600"></li><li>现代 SoC 设计技术理念中，<strong>IP 是构成 SoC 的基本单元</strong>。这里的 <strong>IP 可以理解为满足特定的规范和要求，并且能够在设计中反复重用的功能模块，通常称其为 IP 核(IP Core</strong><ul><li>IP 核是一些设计好的功能模块，购买一个 IP 核所得到的是一些设计数据，但不是实际芯片</li><li>IP 核必须经过实际验证，最好 IP 核在设计中已经被成功使用，最起码已通过某种可编程器件(例如现场可编程门阵列 FPGA 等)验证了其功能正确</li><li>IP 核必须经过性能优化，只有那些性能优异的 IP 核才会有人购买</li></ul></li><li><strong>软核</strong>(Soft Core)。可重用性最高 设计复杂度将大幅增加</li><li><strong>硬核</strong>(Hard Core)。指经过预先布局且不能由系统设计者修改的 IP 核，通常以电路版图形式提交，灵活性最小,可重用性最低(硬核具有不可更改性)，但性能最稳定，可靠性最高。</li><li><strong>固核</strong>(Finn Core)。介于软核和硬核之间，固核由 RTL 描述和可综合网表组成，通常以门级网表的形式提交 固核与实现工艺相关，耳网表本身难于理解，这些都限制了固核的使用范围</li></ul></li></ul><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><ul><li>具有代表性的新型体系统结构主要包括片上多核处理器(Chip Multi-Processors, CMP) 、流处理器 (Stream Processor) 、存内处理器 (Processor In Memory)及可重构处理器(Reconfigurable Processor)</li><li>片上多核处理器(又称多核微处理器)是目前构造现代高性能微处理器的主要技术途径<ul><li>通过在单个芯片中放入多个结构相对简单的微处理器内核(而不是使用一个巨大的微处理器内核)，片上多核技术避免了上述问题。</li><li>结构易扩展。</li><li>设计可重用</li><li>低功耗</li><li>线延迟容忍度高。</li></ul></li><li>VIM 系统的结构示意图，主要由 4 部分组成：标量 RISC 核、向量核、嵌入式 DRAM 存储体和内部互连矩阵（CROSSBAR）。其中，嵌入式存储体内部由 4 个独立的存储体（Bank）组成</li><li>可重构处理器抛弃了指令流这种存储访问密集的计算方式，使用硬件完成重要数据的计算，而无须额外的指令控制，因而可以大大减缓存储屏障带来的压力。</li></ul><h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><ul><li>嵌入式系统是指任何包括可编程计算机的设备，但本身并未被刻意设计为一台通用计算机。<ul><li>以各种形态嵌入到对象体系中的专用计算机系统</li><li>嵌入式系统（Embedded System）是控制、监视或者辅助设备、机器或平台运行的装置</li><li>目前国内普遍认同的嵌入式系统的定义是：<strong>以应用为中心，以计算机技术为基础，软硬件可裁减，适应应用系统对功能、可靠性、成本、体积和功耗等严格要求的专用计算机系统，即“嵌入应用对象体系中的专用计算机系统”。</strong></li><li>嵌入性、专用性和计算系统是嵌入式系统的 3 个基本要素，对象系统则是指计算系统所嵌入的宿主系统。</li></ul></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412142034116.png" alt="image.png|600"></li><li>嵌人式系统一般由<strong>硬件平台、软件系统及开发工具</strong>等三部分组成<ul><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412141953096.png" alt="image.png|600"></li><li>嵌入式系统硬件包括嵌入式核心芯片、存储系统及外部接口。</li><li>嵌入式系统的软件主要包括两部分：嵌入式操作系统和应用软件</li></ul></li><li>嵌人式系统的核心部件是各种类型的嵌入式处理器<ul><li>网络互连</li><li>多核异构</li><li>软件定义</li></ul></li></ul><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h2><ul><li>RISC 技术</li><li>加载/存储体系结构，也称为寄存器/寄存器体系结构或 R-R 系统结构，借用大量的标量或向量寄存器来进行中转，使用更多的通用寄存器存储操作数和运算结果</li><li>采用固定长度精简指令集</li><li>三地址指令格式，操作数、源操作数和第二源操作数。</li></ul><h2 id="7-2-ARM-编程模型"><a href="#7-2-ARM-编程模型" class="headerlink" title="7.2 ARM 编程模型"></a>7.2 ARM 编程模型</h2><ul><li>32 位的 ARM 微处理器支持以下两种工作状态：<ul><li>ARM 状态。微处理器执行 32 位的字对齐的 ARM 指令。</li><li>Thumb 状态，微处理器执行 16 位的、半字对齐的 Thumb 指令。</li></ul></li><li>ARM 微处理器复位后开始执行代码时，或者异常处理时，处于 ARM 状态<ul><li>状态切换<strong>不影响工作模式和寄存器内容</strong></li><li>thumb 则会还在 thumb 状态</li></ul></li><li>ARM 微处理器的工作模式可以通过软件改变，也可能因外部中断或异常引发改变</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412142056560.png" alt="image.png|600"></li><li>其余所有 6 种模式称为非用户模式或特权模式 (Privileged Mode)</li><li>当微处理器工作在用户模式时，正在执行的程序不能访问某些被保护的系统资源，也示能直接进行工作模式的切换。应用程序可以通过产生异常中断，在异常处理过程中切换工作模式，当应用程序产生异常中断时，微处理器进入相应的异常模式</li><li>32 位 ARM 微处理器共有 37 个 32 位的物理寄存器，其中包括 31 个通用寄存器(含程序计数器 PC) 和 6 个程序状态寄存器。这些寄存器不能同时访问，具体哪些寄存器可编程访问取决于微处理器的工作状态及具体的工作模式。</li><li>通用寄存器包括 R0-R14, 可以分为两类：不分组寄存器(R0-R7)和分组寄存器(R8-R14)。<ul><li>对于不分组寄存器 R0 R7, 在微处理器的所有工作模式下，它们中的每一个都指向一个物理寄存器，且未被系统用于特殊用途。因此，在中断或异常处理中进行模式切换时，由于不同的微处理器工作模式均使用相同的物理寄存器，可能会破坏寄存器中的数据，进行程序设计时应引起注意。</li><li>对于分组寄存器 R8-R14, 物理寄存器可能有分组，具体使用哪一组与微处理器当前的工作模式有关<ul><li>寄存器 <strong>R13 通常作为堆栈指针(SP)</strong>, 用于保存当前微处理器工作模式下堆栈的<strong>栈顶地址</strong>。寄存器 R14 通常作为<strong>链接寄存器(LR</strong>),<strong>用于保存子程序的返回地址</strong>。当子程序的返回地址保存在堆栈中时，R14 也可以作为通用寄存器。</li></ul></li></ul></li><li>R15 作为<strong>程序计数器，用于保存微处理器准备读取的下一条指令的地址</strong> - 通常 PC 总是指向当前指令之后两条指令的地址，即 PC 的值为当前指令的地址值加 8 - ![[微机原理复习#^1z1bgb]]<blockquote><ul><li>程序状态寄存器(PSR)包括<strong>当前程序状态寄存器</strong> (Current Program Status Register, <strong>CPSR</strong>) 和<strong>程序状态保存寄存器</strong> (Saved Program Status Register, <strong>SPSR</strong>)<ul><li>微处理器在所有工作模式下都可以访问当前程序状态寄存器，而在每一种异常工作模式下都还另有一个程序状态保存寄存器 SPSR。当异常发生时，SPSR 用于保存 CPSR 的当前值,当从异常退出时，可用 SPSR 来<strong>恢复</strong> CPSR。</li><li>用户模式和系统模式不属于异常模式，因此这两种模式没有 SPSR, 当在这两种情况下访问 SPSR 时，结果是未知的<ul><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412142104189.png" alt="image.png|600"></li><li>控制位: CPSR 的低 8 位，即 I、F、T 和 M4-M0 称为控制位。当发生异常时这些位可能被改变，当微处理器运行在特权模式时，这些位也可以由程序修改</li></ul></li></ul></li></ul></blockquote></li><li>32 位 ARM 微处理器支持的数据类型有<strong>字节（8 位）、半字（16 位）和字（32 位）。</strong><ul><li>字节 在 ARM 微处理器中，字节的长度均为 8 位。</li><li>半字 ARM 微处理器中，半字的长度为 16 位，半字必须以 2 字节为边</li><li>字 在 ARM 微处理器中，字的长度为 <strong>32 位，字必须以 4 字节为边界对齐</strong></li><li>这三种数据类型都支持无符号数和有符号数 N 位决定</li></ul></li><li>以字节为单位的线性空间。每个字数据占 4 字节单元,每个半字数据占 2 字节单元。<ul><li>ARM 微处理器的 32 位地址线能支持的<strong>最大寻址空间为 4 GB 2 的 32 次方</strong></li><li>![[微机原理复习#^qus79v]]</li><li>在小端格式中，32 位字数据的高字节存放在高地址单元中，而低字节则存放在低地址单元中</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412142125194.png" alt="image.png|600"></li></ul></li><li>当发生异常时，微处理器必须<strong>先保存当前的状态</strong>；当异常处理完成后，需要将微处理器的<strong>状态恢复</strong>到处理异常之前，然后才能继续执行当前程序。ARM 微处理器允许多个异常同时发生，它们将会按固定的优先级进行处理。<ul><li>指令执行引起的直接异常。软件中断、未定义指令（包括要求的协处理器不存在时的协处理器指令）和预取指令中止都属于这一类。</li><li>指令执行引起的间接异常。数据中止（在用加载/存储指令访问数据时的存储器故障）属于这一类。</li><li>外部产生的与指令流无关的异常。复位、IRQ 和 FIQ 属于这一类</li></ul></li><li>当多个异常同时发生时，系统根据固定的优先级决定异常的处理次序<ul><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412142128040.png" alt="image.png|600"></li><li>未定义指令异常和软件中断异常都依靠指令的特殊 译码产生，由于两者是互斥的指令编码，因此不可能同时发生</li></ul></li><li>存储器中为每个异常类型分配一个固定地址，该固定地址称为异常向量<ul><li>当 ARM 微处理器发生异常时，<strong>程序计数器被强制设置为对应的异常向量</strong>，从而转到异常处理程序</li></ul></li><li>复位异常处理程序执行完后无须返回。其他所有异常处理程序执行完后必须返回到原来程序处继续执行</li><li>![[微机原理复习#^1zbw8k]]</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412150938864.png" alt="image.png|600"></li><li>异常返回<ul><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412150942158.png" alt="image.png|600"><br>-</li></ul></li></ul><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><ul><li><strong>易失性</strong>存储器是指需要持续<strong>维持电源供应</strong>，才能确保存储内容不变化或不丢失的存储器。</li><li>最常见的 <strong>MOS 型易失性存储器</strong>有两种基本类型：<ul><li>静态 RAM (Static RAM, SRAM)和动态 RAM (Dynamic RAM, DRAM) c</li><li>SRAM 中的基本存储单元是由 MOS 管构成的<strong>双稳态电路</strong>，存储的信息由双稳态电路的<strong>逻辑状态</strong>表征。</li><li>DRAM 存储的信息由<strong>电容上的电位</strong>来表征。由<strong>于电容总存在充电施电回路，即使不访问存储器，电容上的电荷也会发生变化，从而引起电位，变化并导致存储信息的丢失</strong>。<ul><li>reason：DRAM 内部保存信息的<strong>电荷会随着时间而泄漏</strong>，因此需要周期性地进行刷新</li></ul></li></ul></li><li>一般采用<strong>速度较快</strong>但<strong>成本较高</strong>的 <strong>SRAM</strong> 构成高速缓冲存储器(cache)，成本较低、速度较慢的 DRAM 可用于构成主存</li><li>最早的 NVM 是只读存储器 (Read Only Memory, ROM), 其存储内容在生产期间永久写入。<ul><li>EPROM</li><li>Flash 存储器又称为闪速存储器，简称<strong>闪存</strong></li></ul></li><li>按数据<strong>访问方式</strong>的不同，存储器可分为<strong>并行</strong>存储器(Parallel Memory, PM) 和<strong>串行</strong>存储器(Serial Memory, SM)</li><li><strong>随机存取又称为直接存取</strong><ul><li>可按地址随机访问任意存储单元；访问存储单元所需的时间与数据存储的位置(即地址)无关</li><li>计算机系统中 CPU 直接寻址的存储器都采用随机存取方式</li></ul></li><li>在顺序存取方式下，数据按照特定的线性或时序顺序写入存储介质，并且可以按照完全相同的顺序读回。顺序存取也称为 <strong>“先进先出</strong>” (First In First Out, FIFO), 非常适合作为缓冲存储器。<ul><li>队列</li></ul></li><li>按数据<strong>存取顺序</strong>的不同，存储器可分为<strong>随机</strong>存取存储器 (Random Access Memory,RAM) 、<strong>顺序</strong>存取存储器(Sequential Access Memory, SAM) 和<strong>堆栈</strong>存取存储器。</li><li>按存取方式可以把存储器分为 随机存储器 和 只读存储器 2 类</li><li><strong>存取周期</strong>是<strong>连续启动两次独立的存储器</strong>操作所需的<strong>最小时间间隔</strong></li><li><strong>存取时间</strong>又称为存储器访问时间，<strong>即启动一次存储器操</strong>和（读或写）<strong>到完成该操作所需的时间</strong>。存取周期往往比存取时间<strong>大</strong>得多、</li><li>带宽是指存储器在<strong>连续访问</strong>时的数据吞吐量</li><li>现代计算机系统通常把各种不同存储容量、存取速度和价格的存储器按一定的体系结构组成<strong>多层结构</strong>，并通过管理软件和辅助硬件有机组合成统一的整体，使所存放的程序和数据按层次分布在各种存储器中，以解决存储容量、存取速度和价格之间的矛盾</li><li>映像规则用于确定一个新的块（页）被调人本级存储器时应放在什么位置上。<ul><li><strong>全相联映像</strong>方式的优点是可以灵活地进行块的分配，块的<strong>冲突率低</strong>，但实际上由于成本太高而并不会被采用，可以允许在任意的存储器位置</li><li><strong>组相联映像</strong>方式是直接映像和全相联映像方式的一种<strong>折中</strong>方案</li><li><strong>直接映像</strong> 方式规定每一个块（页）只能被放到唯一的指定位置。直接映像时的地址变换速度快，实现简单，缺点是不够灵活，降低了命中率</li></ul></li><li>这种对局部范围内存储器地址频繁访问，而对此范围以外的存储器地址较少访问的现象称为<strong>存储器访问的局部性</strong><ul><li>时间局部性</li><li>引用局部性</li></ul></li><li>替换规则<ul><li><strong>先人先出法</strong>(First In First Out, FIFO)选择将最早调入的块作为被替换的块</li><li><strong>最近最少使用法</strong>(Lqast Recently Used, LRU)选择将最久未被访问块作为被替换的块，可以<strong>提高命中率</strong></li><li><strong>随机替换算法</strong>(RAlgom substitution, RAND)是在组内随机选择一块来替换</li></ul></li><li>cache<ul><li>如果不命中，则将数据请求传给主存，<strong>贯穿读出</strong>，该方法的优点是降低了 CPU 对主存的请求次数，缺点是<strong>延迟</strong>了 CPU 对主存的访问时间</li><li><strong>旁路读出式</strong>，如果命中，则 cache 在将数据回送给 CPU 的同时，还来得及中断 CPU 对主存的请求；若不命中，贝 U cache 不做任何动作，由 CPU 直接访问主存。它的优点是没有延时，缺点是每次 CPU 都要访问主存，会<strong>占用部分总线时间</strong></li></ul></li><li>多层存储系统也需要使用这种<strong>虚拟存储器技术</strong>来实现相邻层之间的数据调度。<strong>其主要思想是将虚拟地址空间和物理地址空间分离，并通过存储器管理单元 Management Unit, 使用地址映射表来完成两者之间的映射联系</strong></li><li>cache 存储器系统主要负责解决<strong>高速度和低成本</strong>之间的矛盾。为了弥补主存速度的不足，这个层次的功能完全由硬件实现，因此对用户是完全透明的。<ul><li>高速缓存技术是一种用来缓解冯 •诺依曼瓶颈</li></ul></li><li>虚拟存储器系统主要负责解决<strong>大容量和低成本</strong>之间的矛盾，由于 CPU 不能直接访问辅存，主存-辅存层次通过附加的硬件及存储管理软件来控制。<ul><li>![[微机原理复习#^c2nnhj]]</li><li>可以简化寻址方式。</li><li>可以高效利用物理存储器</li><li>便于访问控制</li></ul></li><li><strong>虚拟地址</strong>空间指的是<strong>程序使用</strong>的地址空间（也称为逻辑地址空间或程序空间），而<strong>物理地址空</strong>间指的是物理存储器<strong>实际的硬件地址空间</strong>（也称为实存空间）<ul><li>另一种常用的存储器地址映射技术称为<strong>分段</strong>技术，<strong>逻辑地址到物理地址</strong>。在<strong>分段技术中，段的大小可变</strong>。用户可见，段内连续编址，段间不一定，<strong>段是逻辑单位</strong></li><li>与<strong>分页技术</strong>（虚<strong>拟地址到物理地址</strong>）的不同之处在于，系统确定，用户不可见，大小固定，<strong>页是物理单位</strong></li></ul></li></ul><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><ul><li><strong>输入/输出接口</strong>简称 I/O 接口，有时也称为 I/O 电路或 I/O 控制器。I/O 接口不仅包括<strong>外部设备</strong>与 CPU 或计算机之间的<strong>硬件电路</strong>，也包括相应的<strong>驱动程序</strong></li><li>分类<ul><li>并行接口是指微处理器与 I/O 接口之间、I/O 接口与外部设备之间均以多个位的并行方式传送数据。串行接口是指接口与外设之间采用串行方式(即单个位)传送数据，数据按位一位一位地传送<ul><li>并行接口适用于传输距离较<strong>近</strong>、传输速度较<strong>高</strong>的场合，接口电路相对<strong>简单</strong>。</li><li>串行接口则适用于传输距离较<strong>远</strong>、传输速度相对较<strong>低</strong>的场合，传输线路<strong>成本较低</strong>，接口电路相对前者更<strong>复杂</strong>。</li><li>现代的高速串行接口也用于对传输速度要求特别高的场合。</li></ul></li><li>同步接口是指与同步总线相连的接口，其数据传输由<strong>统一的时序信号同步控制</strong>。异步接口则是指与异步总线相连的接口，其信息传送采用异步<strong>应答的方式</strong>进行。</li><li>程序查询接口、程序中断接口、直接存储器访问 (DMA)接口<ul><li>CPU 通过程序来查询接口的状态寄存器,并执行相应接口的数据访问操作。</li><li>作为一种特例，即需传送的数据总是准备好的，无须任何状态联络信息，CPU 直接执行输入/输出指令即可实现读取接口数据或输出数据到输出接口的操作，这种特例也称为<strong>无条件传送方式</strong>。</li></ul></li></ul></li><li>统一编制<ul><li>这种编址方式是将存储器和 I/O 端口<strong>统一编址</strong>，即在存储器空间中<strong>划分出一段地址空间</strong>作为访问 I/O 端口的地址空间</li><li>将端口看<strong>作存储单元</strong>，仅以<strong>地址范围</strong>的不同来区分两者。</li><li>优点：对端口的操作和对存储单元的<strong>操作完全一样</strong>，因此<strong>系统简单</strong>，并且对端口操作的指令种类较多</li><li>缺点：CPU 对存储单元和 I/O 端口的实际寻址空间都<strong>小于其最大寻址空间</strong></li></ul></li><li>独立编址<ul><li>存储器和 I/O 端口的地址空间<strong>彼此独立</strong></li><li>特点：系统视端口和存储单元为不同的对象。</li><li>优点：系统中存储单元和 I/O 端口的<strong>数量可达到最大</strong>。</li><li>缺点：需<strong>专门信号</strong>来指示系统地址线上出现的是存储单元地址还是端口地址；专用端口操作<strong>指令比较单一</strong></li></ul></li><li><strong>中断</strong><ul><li>中断源是指引起中断的事件或发出中<strong>断请求的来源</strong>，如掉电、数据校验出错等异常事件,键盘、磁盘、网口等外设操作请求等，<ul><li>中断处理模块会对中断源加以命名或通过编号进行区分，这个编号就是所谓的<strong>中断类型码</strong>（或称中断类型号）。</li></ul></li><li><strong>中断向量</strong>即<strong>中断服务子程序的人口地址</strong>，也就是中断服务子程序<strong>第一条指</strong>令在存储器中的存放地址。</li><li><strong>断点</strong>通常是指<strong>被中断主程</strong>序<strong>下一条待执行指令的存放施址</strong>，也就是<strong>中断返回时的程序地址</strong>。</li><li><strong>现场</strong>指中断发生前<strong>程序的运行状态</strong>，一般主要指系统标志寄存器和相关数据寄存器中的内容。</li><li><strong>中断屏蔽</strong>可能在两种情况下发生：一种情况是中断<strong>系统允许设置</strong>中断屏蔽标志（或中断允许标志），以屏蔽某些中断源的请求；另一种情况是当系统在处理<strong>优先级较高</strong>的中断请求时,不会响应后到的级别较<strong>低</strong>的中断请求，也就是中断系统会自动屏蔽优先级低的中断，不允许其产生中断嵌套。</li></ul></li><li>中断处理 ^1zbw8k<ul><li><strong>中断请求及检测</strong><ul><li>虽然中断请求可能在任意时刻被送到 CPU, 但实际上 CPU 只是在当前指令执行完后才进行中断请求的检测，硬件检测</li></ul></li><li><strong>中断优先级的判断</strong></li><li><strong>中断响应</strong><ul><li><strong>跳转</strong>至中断服务<strong>子程序人口</strong>的过程，也是硬件</li><li>获取<strong>中断类型码</strong></li><li><strong>保护</strong>现场和断点</li><li>获取<strong>中断向量</strong>，从而进入中断处理</li></ul></li><li>中断处理就是<strong>执行中断服务子程序</strong>的过程</li><li>中断<strong>返回</strong></li></ul></li><li>优先级判断<ul><li>软件查询</li><li>硬件判断<ul><li>菊花链</li><li>中断优先级编码</li></ul></li></ul></li><li>中断控制方式充分发挥了 CPU 的效能，大大提高了 CPU 的工作效率。有了中断后，就允许 CPU 与多个外设<strong>同时工作</strong>，并可实现实时控制</li><li>DMA 直接存储器访问（DMA）传输方式<ul><li><strong>高速的批量数据传输</strong></li><li>MA 是通过硬件控制实现主存与 I/O 设备间的直接数据传送，在传送<strong>不用 cpu</strong>干预</li><li>控制主存与 I/O 设备间之间直接数据传输的硬件就是 DMA 控制器，总线的从属模块，要让出系统总线控制权</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412172213216.png" alt="image.png|600"></li><li>可以<strong>突发传输</strong>，这种一次请求总线传输一整块数据的方法；<strong>周期窃取</strong>，慢速设备，传输完一个数据字后，下一个字还没准备好，这时没有 DMA 请求，DMAC 撤销总线请求，恢复 CPU 操作。当 I/O 数据准备好时，再启动一次一个数据字的传输过程</li><li>它不运行程序，不能处理较复杂的事件</li></ul></li><li>可编程通用并行接口(GPIO)允许用户通过写入不同的控制字改变其工作方式<strong>8255</strong><ul><li>数据总线缓冲器、读医控制逻辑、输入/输出端口(A、B 和 C)和可编程控制寄存器。其中数据总线缓冲器用于总线隔离</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412172237359.png" alt="image.png|600"></li></ul></li><li>串行外围设备接口(SerialPeripheral Interface, <strong>SPI</strong>)是一种<strong>全双工同步串行</strong>总线接口 ^eh604s</li><li>I2c 是一种两线式<strong>半双工串行同步</strong>总线接口，两个都是同步的</li><li>异步：<ul><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412172243039.png" alt="image.png|600"></li><li><strong>波特率</strong> ^3czyja<ul><li>通信线路的传送速度可以<strong>每秒最多能传送的位数</strong>（即每秒硬件电路<strong>状态最多能改变的次数</strong>）来衡量</li><li>要求接收器采用比波特率更高的时钟频率对接收数据进行<strong>最大化采样</strong>，以提高定位采样的<strong>分辨率和抗干扰能力</strong></li></ul></li><li>在串行传输中，收发双方都按通信协议进行<ul><li>意义？停止位，起始位，校验位，校验位是补上之后加上停止和起始后还符合奇偶的方法</li><li>，起始位与停止位/空闲位采用不同的逻辑电平</li></ul></li></ul></li><li>起始位置和停止位置的作用是使<strong>收发双方在随机传送的字符与字符间实现同步</strong>。接收端在检测到起始位时，便知道字符已经到达，应开始接收字符；当检测到停止位时，则知道字符传送已经结束 ^2zcwk8<ul><li><strong>由于传送字符出现在数据流中的相对时间是任意的，保证异步通信的准确性，使收发两方随机传送的字符与字符之间实现同步接受发送</strong>。</li></ul></li><li>IO 端口：数据控制状态，接口电路中的一些寄存器</li><li>锁存器：对于慢速设备，将 cpu 的数据<strong>锁存到锁存器的输出</strong>中，然后给 io 口外设进行<strong>后续</strong>处理</li><li>数据缓冲器，三太缓冲，以便 cpu 读入数据时，缓冲电路打开设备和数据线之间<strong>通道</strong>，进行数据输入</li><li>约定通讯协议：波特率。校验方式，帧格式，停止位，起始位：<strong>保证双方能在数据流中识别出其实和结束</strong>，并能正确解析出数据，避免丢失信息 ^k6cnq3<ul><li>空闲状态为 1，一旦有数据，起始为 0，检测电平变换即可；</li><li>由于异步中没有共同的时钟信号，要对<strong>数据流进行采样</strong>，接收方 baud 率为发送方好几倍，保证<strong>最大化采样的准确性</strong>，中间信号最稳定，可以提高抗干扰与分率率；波特率因子</li><li>当收发双方的时钟源频率不严格一致时，<strong>累积的位时间错位</strong>会造成停止位采样落在实际停止位之外而产生帧错误，或数据采样值落在其他数据位处而产生校验错误等</li></ul></li></ul><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><ul><li>总线是<strong>计算机系统中的信息传输通道</strong>，由系统中各个部件所共享。总线是计算机系统中模块与模块之间、部件与部件之间、设备与设备之间传送信息的一组<strong>公用信号传输线</strong>。<strong>公用性</strong> ^ed1ans</li><li>分为<strong>片上总线、系统总线和系统外总线</strong><ul><li>片上总线是指在<strong>微处理器芯片内部的总线</strong>，是用来连接芯片内部各功能模块的信息通路</li><li>系统总线也称为微处理器系统总线，是微处理器芯片与存储器芯片、外设接口芯片等连接的总线，如 PCI-E 总线和 SAIA 总线等</li><li>系统外总线是微机系统与系统之间、微机系统与外部设备之间的总线。USB</li></ul></li><li>异步总线在数据传送时，没有固定的时钟周期定时，而采用<strong>应答方式</strong>工作，操作时间根据需要可长可短。控制较复杂</li><li>同步总线广泛应用于各个模块间<strong>数据传送时间差异较小的场合</strong>，控制简单，同步总线在进行数据传送时，由严格的时钟周期来定时，一般设置有同步定时信号</li><li>并行总线有<strong>多条数据传输线</strong>，可以同时并行传送多个二进制位，其位数一般就称为总线宽度。高速并行总线需要克服<strong>串扰</strong>、<strong>时钟偏斜</strong>(Skew)等问题，一般成本较<strong>高</strong></li><li>串行总线只需要一条数据线，串行地逐位传送数据。</li><li>性能指标<ul><li>总线时钟频率是总线时钟源每秒产生的脉冲数，反映了总线基本工作速度的快慢程度，总线偏斜</li><li><strong>总线宽度</strong>是总线单次并行传送数据的<strong>位数</strong>，一般为数据线的条数<ul><li>通常总线宽度仅指数据线宽度，<strong>与地址线宽度无关</strong>。</li></ul></li><li><strong>总线速率</strong>是指每秒所能传输数据的最大<strong>次数</strong>（区分带宽）。总线速率与总线的时钟频率(或时钟周期)和总线周期数有关，<ul><li><strong>总线速率=总线时钟频率/总线周期数</strong></li><li>总线周期数是指通过总线<strong>传送一次数据</strong>所需的<strong>时钟周期数</strong>。</li></ul></li><li><strong>总线带宽</strong>是指每秒传输的字节数，单位是字节用 XB/s)或<strong>兆字节</strong>电<ul><li>总线带宽与总线速率<strong>和总线宽度有关</strong>，即<strong>总线带宽=总线速率 x 总线宽度/8</strong></li></ul></li></ul></li><li>总线仲裁可分为两种方式：集中式(主从式)控制方式和分布式(对等式)控制方式。<ul><li>总线仲裁又称总线判决，其目的是<strong>合理的控制和管理系统中多个主设备的总线请求</strong>，以避免总线冲突。</li><li>集中式控制方式是指系统采用专门的总线控制器或仲裁器分配总线时间,总线控制器或仲裁器可以是独立的模块或器件，也可以集成在 CPU 中。<ul><li>采用<strong>集中式</strong>控制方式的总线协议简单而有效，但<strong>总体系统性能较低</strong>。分布式控制方式是指总线控制逻辑<strong>分散在连接于总线上的各个模块或设备</strong>中。</li><li><strong>串行仲裁</strong>“菊花链”(Daisy Chain)是一种常用的串行仲裁机制，模块使用总线时的优先级由它到总线仲裁器的距离决定，离仲裁器越近，则优先级越高</li><li><strong>并行仲裁</strong>，仲裁器按规定的优先级算法选中一个主模块，并把 BG 信号送给该模块</li><li><strong>混合仲裁</strong>又称为多级仲裁，是把并行和串行两种方案相结合构成的更为灵活的</li></ul></li><li>采用<strong>分布式</strong>控制方式的总线协议既复杂，成本又高，但可以换来 CPU 和总线的高效使用。<ul><li>可能更为复杂，但可靠性更高，不会因为某个设备（如集中式仲裁器）损坏而导致整个系统都无法工作。</li></ul></li></ul></li><li>总线时序一般可分为 4 种：同步时序、半同步时序、异步时序和周期分裂式时序。<ul><li>对于同步总线而言，其<strong>控制总线</strong>包含一个时钟和一个固定的<strong>与时钟有关</strong>的地址和数据发送协议</li><li>异步，一条同步总线上连接着多个工作速度<strong>有快有慢的设备</strong>，异步时序依靠传送双方互相制约的握手信号来实现定时控制。在这种方式下，系统没有公用的时钟，也没有固定的时间间隔，设备之间采用一问一答的方式进行联络和协调工作</li><li>周期分裂式时序，充分利用这段<strong>总线空闲的时间</strong>，两个子周期之间的空闲时间（从模块准备数据的时间）即可让出总线给其他主模块使</li></ul></li><li>串行总线<ul><li>串行总线使用的线缆少，成本低，非常适合用于嵌入式系统。，没有并行信号之间的串扰</li><li>单工和双工（又可分为半双工和全双工）<ul><li><strong>单工方式</strong>。在接收器和发送器之间<strong>只有一条</strong>传输线，只能进行单一方向的传输，这样的传送方式就是单工方式</li><li><strong>半双工方式</strong>。当使用<strong>同一条传输线</strong>既用于<strong>发送又用于接收</strong>时，虽然数据可以在两个方向上传送，但通信双方不能同时收发数据，这样的传送方式就是半双工方式，通信系统一端的发送器和接收器通过收/发开关接到通信线上，进行传输方向的切换。</li><li><strong>全双工方式</strong>。当数据的接收和发送分别由<strong>两条不同</strong>的传输线完成时，通信双方都能同时发送和接收数据，通信系统的每-端都设置了接收器和发送器</li></ul></li><li>采用调制解调技术之后，比特率大于波特率。![[微机原理复习#^3czyja]]</li><li>同步和异步<ul><li>在同步串行总线中，收发双方可以在同一个时钟的不同边沿工作</li><li>在异步串行总线中，收发双方使用<strong>频率接近</strong>（但不可能完全相同）的独立时钟源进行工作<ul><li><strong>在异步通信时，被传送的字符出现在数据流中的相对时间是任意的、随机的。为了确保异步通信的正确性，让发送的字符与字符之间实现同步，字符数据格式中设置起始位和停止位</strong></li><li>![[微机原理复习#^2zcwk8]]</li><li>![[微机原理复习#^k6cnq3]]</li><li>设置停止位的目的是强制总线恢复到初始（空闲）状态（1 高电平），以便能检测到下一起始位的下降沿</li></ul></li><li>将接收时钟的频率设置得比发送时钟的高，如令接收时钟频率是发送时钟的 16 倍，就能保证接收方不会漏掉任何一个起始位。<strong>异步才要</strong></li><li>接收方在检测到起始位的前沿（下降沿）后，延时 8 个采样时钟，确定起始位稳定时刻，之后每隔 16 个采样时钟读取一位数据即可</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412172338305.png" alt="image.png|600"></li><li>因为每个字都以一个新的起始位作为开头，这个起始位能够使通信重新同步</li><li>在停止位或空闲位后，如果全部 8 个采样点连续低电平，则确认起始位有效，而如果不是 8 个采样点连续低电平，则认为是干扰信号。</li><li>奇偶校验，<strong>加上这位判</strong>断</li></ul></li></ul></li><li>总线标准<ul><li>总线标准也称为总线协议</li><li>总线协议一般包括信号含义、数据格式、时序关系、信号电平、控制逻辑，甚至包括物理连接器的定义等，它确定了一个系统使用总线的方法</li><li>在 SoC 设计中，片上总线设计是最关键的问题</li></ul></li><li>PCI 总线<strong>支持多总线结构和线性突发(Burst)传输</strong>。最大允许 32/64 位<strong>并行</strong>数据传送，采用地址/数据总线复用方式<ul><li>数据帧的传输模式，可确保总线不断满载数据</li><li>PCI 总线是一种<strong>同步</strong>总线</li><li>PCI 总线上可以存在多个具有总线管理控制能力的主控设备</li><li>PCI 总线通过 CPU 局部总线到 PCI 总线之间的桥接器形成一种独特的中间缓冲器设计方式，将中央处理器子系统与外部设备分开，使 PCI 总线具有独立于微处理器的结构特点。</li></ul></li><li>PCI-E <strong>串行</strong>总线<ul><li>PCI-E 总线使用了高速差分总线，并采用端到端的连接方式</li><li>基于时钟的同步传送机制，但是在物理链路上并没有时钟线</li></ul></li><li>RS-232 是<strong>异步串行</strong>通信<ul><li>RS-232c 采用<strong>负逻辑</strong></li><li>噪声容限 6v</li></ul></li><li><strong>usb 半双工异步串行</strong></li><li><strong>spi 同步串行</strong>![[微机原理复习#^eh604s]]</li><li><strong>can 异步串行</strong></li></ul><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><blockquote><p>[!warning]</p><ul><li>PC 用于<strong>存放下一条要执行指令的存放地址</strong></li><li>计算机系统划分成三层，<strong>应用软件，系统软件，硬件系统</strong> ^1z1bgb</li></ul></blockquote><ul><li>计算机体系结构（ComputerArchitecture）主要是指程序员关心的计算机<strong>概念结构与功能特性</strong>，而计算机组成（Computer Organization）则偏重关注物理机器中各操作单元（部件）的<strong>逻辑设计、硬件实现及互连组织技术</strong>，更底层的集成电路设计技术、封装技术、电源技术、冷却措施及<strong>微组装技术</strong>则称为计算机实现</li><li>冯氏<ul><li><strong>电子计算机的基本工作原理：存储程序原理</strong></li><li>二进制表示和存储程序（Stored Program），</li><li><strong>运算器、控制器、存储器、输入设备和输出设备</strong><ul><li>控制器对程序代码进行<strong>解释并产生各种控制信号</strong>协调各部件工作</li><li>计算机按<strong>存储程序原理</strong>工作<ul><li>其基本点是指令（控制）驱动：编制好的<strong>程序</strong>（包括指令和数据）预先经由输人设备输入并<strong>保存在存储器</strong>中；计算机开始工作后，在无须人工干预的情况下，由控制器自动、高速地<strong>依次从存储器中取出指令并加以执行。</strong></li></ul></li></ul></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412182052743.png" alt="image.png|600"></li><li><strong>总线</strong>是<strong>连接上述各部件的公共通道，用于实现各部件之间的数据、信息等的传输和交换</strong>![[微机原理复习#^ed1ans]]</li><li>存储器由许多<strong>字节单元</strong>组成，每个单元都有一个唯一的编号。这个编号称为<strong>存储单元地址</strong>，而其中保存的字节信息称为<strong>存储单元内容</strong></li><li>输入/输出子系统用于完成计算机与外部的信息交换<ul><li><strong>总线和设备之间</strong>添加一个信息交换的中间环节一<strong>接口</strong> (Interface)，接口一方面应该负责<strong>接收、转换、解释并执行总线主设备(如 CPU)发来的命令</strong>，另一方面应能将总线从设备(如显示器、打印机)的状态或数据传送给总线主设备，从而完成<strong>数据交换</strong>。I/O 接口的组织及读写方式一般与<strong>存储器</strong>类似。</li></ul></li><li>运算器、控制器和寄存器集成在一片称为 CPU (Central Processing Unit, 中央处理单元，或称为中央处理器)的超大规模集成电路芯片 (VLSI) 中<ul><li><strong>算术逻辑单元</strong>是运算器的<strong>核心</strong></li><li>控制器是整个微处理器的指挥控制中心，对协调整个计算机系统有序工作极为重要。</li><li>reg 存器阵列是 CPU 内部的临时存储单元，用来暂时存放数据和地址</li><li>堆栈(Stack)是一组寄存器或存储器中开辟的<strong>一个特定区域</strong>。先进后出”(FILO)或“后进先出”(LIFO)</li></ul></li></ul></li><li><strong>CPU 可以处理</strong>的<strong>全部指令集合</strong>称为<strong>指令集</strong>（Instruction Set）<ul><li>指令通常包含<strong>操作码和操作数</strong>两部分</li><li>将源程序<strong>翻译成机器语言</strong>表示的目标程序，这个过程称为<strong>汇编</strong>。</li></ul></li><li>每条指令执行的基本过程都可以分为<strong>取指令(Fetch)、分析指令(Decode)和执行指令(Execute)三个阶段</strong> ^kqinps</li><li>冯 • 诺依曼型计算机的串行特点：计算机以<strong>存储程序原理</strong>为基础，将程序和数据混合存<strong>放在单一存储器</strong>中，并使用单一处理部件按“取指-分析-执行”的步骤顺序执行指令<ul><li><strong>指令执行的串行性和存储器读取的串行</strong>性。这种串行特性正是导致冯・诺依曼结构性能<strong>瓶颈</strong>的主要原因。</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412180939272.png" alt="image.png|600"></li></ul></li><li>CPU 的指令集结构(Instruction Set Architecture, ISA)是计算机体系结构的主要内容之一，其功能设计实际上就是<strong>确定软硬件的功能分配</strong>，即哪些基本功能由硬件实现,哪些由软件实现。<ul><li>设计指令集结构时有精简指令集计算机(Reduced Instruction Set Computer, <strong>RISC</strong>)和复杂指令集计算机(Complex Instruction Set Computer, <strong>CISC</strong>)</li><li>复杂指令功能通过<strong>微程序实现</strong>，再将微程序<strong>固化或硬化后交由硬件实现</strong>，这就是 CISC 系统的设计思路</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412180941008.png" alt="image.png|600"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412180941561.png" alt="image.png|600"></li></ul></li><li>大多数现代计算机采用了图 2-8 所示的<strong>四级存储结构</strong>。 ^c2nnhj<ul><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412180943698.png" alt="image.png|600"></li><li><strong>cache-主存层次</strong>的存取速度接近于 cache 的存取速度，容量和每位存储的平均价格却接近主存，解决了<strong>高速度和低成本之间的矛盾</strong>；而<strong>主存一辅存层次</strong>的存取速度接近于主存的存取速度，容量和每位存储的平均价格却接近辅存，解决了<strong>大容量和低成本</strong>之间的矛盾。</li></ul></li><li>哈佛体系结构计算机将<strong>程序存储器与数据存储器</strong>分开，从而可以提供较大的存储器带宽。但是要求 CPU 拥有<strong>两套独立的地址和数据总线。</strong><blockquote><p>[!warning]</p><ul><li>现代计算机采用了工业生产中基于时间重叠的<strong>流水线</strong>（Pipeline）技术，即把一个<strong>重复的过程分解为若干个子过程</strong>（相当于“工序”），每个<strong>子过程</strong>由<strong>专门的功能部件</strong>来实现。<ul><li>同一时刻流水线各段能够并行处理不同指令，使多条指令的执行过程实现了（时间）重叠</li></ul></li></ul></blockquote></li><li>超标量处理机通过重复设置<strong>多个流水段硬件</strong>并行工作来提高性能</li><li>超长指令字机能并行执行的多条指令组装成一条很长的指令</li><li>计算机体系结构分类，按指令流和数据流，单和多 - SIMD 阵列处理机和向量处理机 - MISD 不存在<blockquote><p>[!warning]</p><ul><li><strong>字长是一个基本的微处理器设计决策，它指 CPU 能够一次处理（运算、存储、传送）的最大数据宽度</strong>^qus79v<ul><li>所谓的 16 位（bit）机、3.2 位机、64 位机就是指该机的字长</li></ul></li></ul></blockquote></li><li>访存空间是指 CPU 能直接访问的存储单元(主存单元)数量，一般由 <strong>CPU 的地址总线宽度</strong>确定。 - 若 CPU 地址总线宽度为 16 位，则其直接访存空间为 2^16=64KB<blockquote><ul><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412180957251.png" alt="image.png|600"><ul><li>F是时钟频率，而 IC 是指令数目，即运行中的程序的指令总数</li><li><strong>局部性原理</strong>是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</li></ul></li></ul></blockquote></li></ul><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><ul><li>微处理器的基本功能包括<strong>数据的存储、数据的运算和控制</strong>，具体如下<ul><li><strong>数据加工</strong>由 ALU、移位器和寄存器等<strong>数据通路</strong>部件完成，其他功能由控制器实现</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412181032358.png" alt="image.png|600"></li></ul></li><li>微处理器中的<strong>计算部分</strong>称为<strong>数据通路</strong>，包括运算部件、移位器等执行部件，以及<strong>寄存器组和它们之间的通信通路</strong><ul><li>寄存器组常采用小型半导体存储器结构，一个存储单元相当于一个寄存器，存储单元的位数即是寄存器字长</li></ul></li><li>CPU 内部的控制器获取来自内存的指令流并逐条执行指令，根据指令规定产生各种具有一定时序的控制信号，送往数据通路或 CPU 外部。</li><li>MAR 存储器地址寄存器和 MBR 存储器缓冲寄存器是连接<strong>微处理器与主存</strong>的桥梁，这两个寄存器使 CPU 与主存之间的传送通路变得更容易控制。这两个寄存器不能直接编程访问，即对<strong>用户是透明的</strong></li><li>译码逻辑<ul><li>微程序 cisc，控制单元和<strong>输入输出之间的关系被视为一个存储系统</strong>，重用性好，开销大，硬件好设计</li><li>硬连逻辑 risc，随机逻辑，<strong>布尔函数</strong>表示控制单元，减少门电路，低沉本，重用性差，简单指令集结构，硬件难设计</li></ul></li><li>控制器的任务是<strong>决定在什么时间、根据什么条件、发出什么命令、做什么操作</strong>。产生微控制命令的基本依据是时间（如周期、节拍、脉冲等时序信号）、指令代码（如操作码、寻址方式）、状态（如内部的程序状态、外部设备的状态）、外部请求（如外部中断请求、DMA 请求）等。控制器以这些信息作为输入逻辑变量，经硬连电路产生控制信号序列，或者形成相应的微程序地址后再通过<strong>执行微指令实现控制功能</strong><ul><li>生成<strong>时钟信号</strong></li><li>生成执行一个基本指令周期所需的<strong>控制信号</strong></li><li><strong>响应异常事件请求</strong>或输人解出设备发出的<strong>中断</strong></li></ul></li><li>基本操作指令可以大致分为以下 3 类。<ul><li><strong>数据传送指令。</strong></li><li><strong>数据处理指令</strong></li><li><strong>控制指令</strong></li></ul></li><li>流水线<strong>各段延迟不同</strong>导致的性能下降，流水线中某些段的处理时间比其他段的长，则这些段将成为瓶颈，引起阻塞</li><li>流水<strong>线段数过多</strong>导致的性能下降，寄存器延迟占用多</li><li>流水线中<strong>指令相关</strong>导致的性能下降，两条相关指令在执行顺序中足够接近，就可能使爸们在重叠执行期间产生冒险（Hazard），产生停顿</li><li>冒险<ul><li>结构相关是指不同流水线阶段在同一时刻<strong>争用同一硬件资源</strong>的现象</li><li>数据相关是指流水线中<strong>相近指令因为操作重叠</strong>，引起对<strong>同一寄存器或存储单元</strong>访问次序的改变</li><li>控制相关是指流水线中的<strong>转移指令</strong>无法<strong>立即给出</strong>转移目标处的<strong>地址</strong>，而取指阶段又立即要求获得后继指令</li></ul></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412181053854.png" alt="image.png|600"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412181053176.png" alt="image.png|600"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202412181054980.png" alt="image.png|600"></li><li>处理器基本操作有：<strong>取指令、分析指令、执行指令</strong>。<ul><li>![[微机原理复习#^kqinps]]</li><li>取指令：当程序已在存储器中时，首先根据程序入口地址取出一条程序，为此要<strong>发出指令地址及控制信号</strong>。</li><li>分析指令：对当前取得的指令进行分析，<strong>指出它要求什么操作，并产生相应的操作控制命令</strong>。</li><li>执行指令：<strong>根据</strong>分析指令时产生的“<strong>操作命令</strong>”形成相应的<strong>操作控制信号序列</strong>，通过运算器、存储器及输入/输出设备的执行，<strong>实现每条指令的功能</strong>，其中包括对<strong>运算结果的处理以及下条指令地址</strong>的形成</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git知识总结</title>
      <link href="/posts/feefa20.html"/>
      <url>/posts/feefa20.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2024-07-03"><a href="#Date-2024-07-03" class="headerlink" title="- Date:2024-07-03"></a>- Date:2024-07-03</h1><ul><li>Time:15:19</li><li>Subject: CS</li><li>Tags: #git<br>[[2024-07]]</li></ul><hr><h2 id="交叉内容"><a href="#交叉内容" class="headerlink" title="交叉内容"></a>交叉内容</h2><p>[[git命令#- Date 2024-07-03]]</p><h2 id="git工作区域与文件状态"><a href="#git工作区域与文件状态" class="headerlink" title="git工作区域与文件状态"></a>git工作区域与文件状态</h2><h3 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407031520964.png" alt="image.png|600"></p><h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h4><ul><li>工作区提交后回到暂存区，确实就是文件管理器看到的，编辑的区域，正常使用（操作）的区域<h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h4></li><li>保存即将提交到git仓库的内容，临时存储</li><li>可以先修改一部分，放到暂存区钟，再统一提交commit<h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4></li><li><p>git init 的仓库，保存了项目历史</p><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407031526681.png" alt="image.png|600"></p></li><li><p>未跟踪，新创建，git还没管理，</p></li><li>未修改，管理起来的，但是没有修改的文件</li><li>已修改，已经修改了的，没暂存</li><li>已暂存，放到暂存区的文件<h2 id="gitignore-忽略文件"><a href="#gitignore-忽略文件" class="headerlink" title=".gitignore 忽略文件"></a>.gitignore 忽略文件</h2></li><li>把文件加入到里面，那么就会忽略这个文件</li><li>假如已经加到版本库中，那这个文件就不起作用了，需要先从版本库删除中删除 <code>git rm --catched</code> 本地不删除，但是暂存和版本库都删除<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*.txt ， *.xls  表示过滤某种类型的文件</span><br><span class="line">target/ ：表示过滤这个文件夹下的所有文件</span><br><span class="line">/test/a.txt ，/test/b.xls  表示指定过滤某个文件下具体文件</span><br><span class="line">!*.java , !/dir/test/     !开头表示不过滤</span><br><span class="line">*.[ab]    支持通配符：过滤所有以.a或者.b为扩展名的文件</span><br><span class="line">/test  仅仅忽略项目根目录下的 test 文件，不包括 child/test等非根目录的test目录</span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2></li><li>十分重要</li><li><code>git branch &lt;分支名&gt;</code> 创建分支</li><li><code>git checkout &lt;分支名&gt;</code> 切换到分支（恢复文件），可能会有歧义</li><li><code>git switch &lt;分支名&gt;</code> 专门用来切换分支</li><li><code>git merge &lt;被合并的分支1&gt; &lt;目标分支2&gt;</code> 会将1合并到2中</li><li><code>git branch -d &lt;删除的分支&gt;</code> 合并后可以删除，如果没合并就想删除，那得用 <code>-D</code><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3></li><li>如果两个分支对同一行都修改了，那就不知道怎么修改了，会有冲突；但是只有一者修改了，那就可以合并</li><li><p><code>git merge --abort</code> 终止合并</p><h3 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407041152476.png" alt="image.png|600"></p></li><li><p>feat——feature，功能开发</p></li><li>main——分支，稳定版本代码，可以随时发布的，不能直接修改，得用merge来改，用tag标记版本号</li><li>hotfix——问题修复分支，用于合并</li><li>develop——开发版本<h3 id="变基rebase"><a href="#变基rebase" class="headerlink" title="变基rebase"></a>变基rebase</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407041130339.png" alt="image.png|600"></li><li>嫁接移植的感觉</li><li>先switch到要移动的分支dev上，然后用 <code>git rebawse &lt;基的名字，branch名字&gt;</code>，然后就把dev移动到main上了，</li><li>优点：不会有额外提交记录，线性的，直观简洁</li><li>缺点：会改变提交记录，改变branch out的节点，避免在共享分支上使用<blockquote><p>[!note]<br>在使用 Git 的 <code>rebase</code> 时，如果两个不同的分支对同一行代码进行了不同的修改，<strong>也会像merge那样产生冲突</strong>,这种冲突需要手动解决。</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/posts/341ecd43.html"/>
      <url>/posts/341ecd43.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2024-07-03"><a href="#Date-2024-07-03" class="headerlink" title="- Date:2024-07-03"></a>- Date:2024-07-03</h1><ul><li>Time:15:35</li><li>Subject: CS</li><li>Tags: #git<br>[[2024-07]]</li></ul><hr><h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><ul><li><code>git status</code> 查看文件状态</li><li><code>git add xxx</code> 文件移动到暂存区，可以加上通配符，文件夹，如文件夹所有 <code>.</code></li><li><code>git commit -m &quot;xxx&quot;</code> 文件提交到仓库</li><li><code>git log</code> 查看提交记录 <code>--oneline</code> 简单版显示记录<h2 id="回退reset"><a href="#回退reset" class="headerlink" title="回退reset"></a>回退reset</h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407031535611.png" alt="image.png|600"></li><li>参数的区别</li><li><p><code>git reset --soft xxxx</code> xxx为版本id</p><h2 id="查看差异git-diff"><a href="#查看差异git-diff" class="headerlink" title="查看差异git diff"></a>查看差异git diff</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407031546380.png" alt="image.png|600"></p></li><li><p>可用于查看版本之间差异，各个区之间差异，或者分支之间差异</p></li><li><code>HEAD</code> 表示最新的版本</li><li><code>~</code> 或者 <code>^</code> 表示为上一个版本，如 <code>HEAD~2</code> 前两个版本<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2></li><li>rm之后，还需要在暂存区删除，也就是再add一次<h2 id="推送-拉取"><a href="#推送-拉取" class="headerlink" title="推送-拉取"></a>推送-拉取</h2></li><li><code>push</code> <code>pull</code> 拉去和推送，对于原创仓库的<h2 id="连接远程仓库"><a href="#连接远程仓库" class="headerlink" title="连接远程仓库"></a>连接远程仓库</h2></li><li><code>git remote add &lt;仓库别名&gt; &lt;远程仓库地址&gt;</code></li><li><code>git remote -v</code> 查看别名</li><li><code>git push -u &lt;远程仓库名&gt; &lt;分支名&gt;:&lt;分支名&gt;</code> 关联远程和本地，把本地的main推送到远程的main分支，</li><li>拉取远程仓库 <code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-c语言复习</title>
      <link href="/posts/46909ac5.html"/>
      <url>/posts/46909ac5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-06-05"><a href="#Date-2023-06-05" class="headerlink" title="- Date:2023-06-05"></a>- Date:2023-06-05</h1><ul><li>Time:17:08</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-06]]</li></ul><hr><h2 id="printf函数输出流程"><a href="#printf函数输出流程" class="headerlink" title="printf函数输出流程"></a>printf函数输出流程</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945863.png" alt="Pasted image 20230605171222|600"></p><h2 id="printf的使用"><a href="#printf的使用" class="headerlink" title="printf的使用"></a>printf的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;字符串\r\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;输出控制符&quot;，输出参数);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, temp);          <span class="comment">/* %d是输出控制符，temp是输出参数 */</span></span><br></pre></td></tr></table></figure><h3 id="常用输出控制符表"><a href="#常用输出控制符表" class="headerlink" title="常用输出控制符表"></a>常用输出控制符表</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945864.png" alt="Pasted image 20230605172851|600"></p><h3 id="常用转义字符表"><a href="#常用转义字符表" class="headerlink" title="常用转义字符表"></a>常用转义字符表</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945865.png" alt="Pasted image 20230605172915|600"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;输出控制符1输出控制符2…&quot;，输出参数1，输出参数2，…);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp1 = <span class="number">5</span>;   </span><br><span class="line"><span class="type">uint32_t</span>  temp2 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%x \r \n&quot;</span>, temp1,temp2);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;非输出控制符 输出控制符 非输出控制符&quot;，输出参数);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp = <span class="number">10</span>;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;temp=  %d  收到over\r\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何输出%、\和双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%% \r\n&quot;</span>);<span class="comment">// %</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\\\r\n&quot;</span>);<span class="comment">// \</span></span><br><span class="line"><span class="comment">printf(&quot;\&quot;\&quot;\r\n&quot;);// &quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="printf函数支持"><a href="#printf函数支持" class="headerlink" title="printf函数支持"></a>printf函数支持</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945866.png" alt="Pasted image 20230605173458|600"></p><h3 id="半主机模式简介"><a href="#半主机模式简介" class="headerlink" title="半主机模式简介"></a>半主机模式简介</h3><p>用于 ARM 目标的一种机制，可将来自应用程序代码的输入/输出请求传送至运行调试器的主机<br>简单说：就是通过仿真器实现开发板在电脑上的输入和输出<br>一般我们：不使用半主机模式！！！</p><h3 id="方法一：微库法"><a href="#方法一：微库法" class="headerlink" title="方法一：微库法"></a>方法一：微库法</h3><p>在魔术棒-&gt;Target选项卡，勾选：Use Micro LIB，即可避免半主机模式<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945867.png" alt="Pasted image 20230605173808|600"></p><h3 id="方法二：代码法"><a href="#方法二：代码法" class="headerlink" title="方法二：代码法"></a>方法二：代码法</h3><p>1个预处理、 2个定义、3个函数，会用就行</p><ol><li><h2 id="pragma-import-use-no-semihosting-，确保不从C库中使用半主机函数"><a href="#pragma-import-use-no-semihosting-，确保不从C库中使用半主机函数" class="headerlink" title="pragma import(__use_no_semihosting)，确保不从C库中使用半主机函数"></a>pragma import(__use_no_semihosting)，确保不从C库中使用半主机函数</h2></li><li>定义：__ FILE结构体，避免HAL库某些情况下报错</li><li>定义： FILE __ stdout，避免编译报错</li><li>实现：<em> ttywrch、</em> sys_exit和_sys_command_string等三个函数<br><font color="#ff0000">在历程（uart.c）中已经实现了</font><br><font color="#ff0000">到时候拷贝就好</font><h3 id="微库法-VS-代码法"><a href="#微库法-VS-代码法" class="headerlink" title="微库法 VS 代码法"></a>微库法 VS 代码法</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945868.png" alt="Pasted image 20230605174027|600"><h2 id="实现fputc函数"><a href="#实现fputc函数" class="headerlink" title="实现fputc函数"></a>实现fputc函数</h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945869.png" alt="Pasted image 20230605175055|600"><br>也不需要怎么知道</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-system文件夹</title>
      <link href="/posts/3b21df78.html"/>
      <url>/posts/3b21df78.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-06-05"><a href="#Date-2023-06-05" class="headerlink" title="- Date:2023-06-05"></a>- Date:2023-06-05</h1><ul><li>Time:15:31</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-06]]</li></ul><hr><h2 id="sys文件夹介绍"><a href="#sys文件夹介绍" class="headerlink" title="sys文件夹介绍"></a>sys文件夹介绍</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945185.png" alt="Pasted image 20230605153158|600"></p><h2 id="deley文件夹介绍"><a href="#deley文件夹介绍" class="headerlink" title="deley文件夹介绍"></a>deley文件夹介绍</h2><h3 id="deley文件夹函数简介"><a href="#deley文件夹函数简介" class="headerlink" title="deley文件夹函数简介"></a>deley文件夹函数简介</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945186.png" alt="Pasted image 20230605154243|600"></p><h3 id="SysTick工作原理"><a href="#SysTick工作原理" class="headerlink" title="SysTick工作原理"></a>SysTick工作原理</h3><p>SysTick，即系统滴答[[定时器]]，包含在M3/4/7内核里面，核心是一个24位的递减计数器(2的24次方，来一个脉冲就递减)<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945187.png" alt="Pasted image 20230605154419|600"></p><p><font color="#ff0000">每次VAL到0时，VAL自动从LOAD重载！开始新一轮递减计数！</font></p><h3 id="SysTick寄存器介绍"><a href="#SysTick寄存器介绍" class="headerlink" title="SysTick寄存器介绍"></a>SysTick寄存器介绍</h3><h4 id="SysTick控制及状态寄存器-CTRL"><a href="#SysTick控制及状态寄存器-CTRL" class="headerlink" title="SysTick控制及状态寄存器(CTRL)"></a>SysTick控制及状态寄存器(CTRL)</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945188.png" alt="Pasted image 20230605155740|600"></p><h4 id="SysTick重装载数值寄存器-LOAD"><a href="#SysTick重装载数值寄存器-LOAD" class="headerlink" title="SysTick重装载数值寄存器(LOAD)"></a>SysTick重装载数值寄存器(LOAD)</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945189.png" alt="Pasted image 20230605155836|600"></p><h4 id="SysTick当前数值寄存器-VAL"><a href="#SysTick当前数值寄存器-VAL" class="headerlink" title="SysTick当前数值寄存器(VAL)"></a>SysTick当前数值寄存器(VAL)</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945190.png" alt="Pasted image 20230605160021|600"></p><h3 id="delay-init-函数-f1"><a href="#delay-init-函数-f1" class="headerlink" title="delay_init()函数(f1)"></a>delay_init()函数(f1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">(<span class="type">uint16_t</span> sysclk)</span><span class="comment">//传入72（mhz）</span></span><br><span class="line">&#123;</span><br><span class="line">  SysTick-&gt;CTRL = <span class="number">0</span>;<span class="comment">//hal库清空，再配置</span></span><br><span class="line">  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK_DIV8);<span class="comment">//八分频，所以是72/8=9，计数频率是9mhz</span></span><br><span class="line">  g_fac_us = sysclk / <span class="number">8</span>;<span class="comment">//1us时机的来源</span></span><br><span class="line">  <span class="comment">//自动重装装载值，上面写的72/8=9，我们需要9，传入的是72，所以要处理，</span></span><br><span class="line">  <span class="comment">//1us是1/1000000s，频率f=9mzh，也就是T=1/9mhz=1/9000000s，因此乘以9，在这个计数频率的情况下，数九次才算1us</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delay-us-函数-f1"><a href="#delay-us-函数-f1" class="headerlink" title="delay_us()函数(f1)"></a>delay_us()函数(f1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint32_t</span> nus)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">uint32_t</span> temp; </span><br><span class="line">SysTick-&gt;LOAD = nus * g_fac_us; <span class="comment">/* 时间加载 */</span> <span class="comment">//与上面的init照应，乘以9，</span></span><br><span class="line">SysTick-&gt;VAL = <span class="number">0x00</span>; <span class="comment">/* 清空计数器 */</span> </span><br><span class="line">SysTick-&gt;CTRL |= <span class="number">1</span> &lt;&lt; <span class="number">0</span> ; <span class="comment">/* 开始倒数 */</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123; </span><br><span class="line">temp = SysTick-&gt;CTRL; </span><br><span class="line">&#125; <span class="keyword">while</span> ((temp &amp; <span class="number">0x01</span>) &amp;&amp; !(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))); <span class="comment">/* CTRL.ENABLE位必须为1, 并等待时间到达 */</span> <span class="comment">//1000000000000000(2)==2^16==65536</span></span><br><span class="line">SysTick-&gt;CTRL &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>) ; <span class="comment">/* 关闭SYSTICK */</span> </span><br><span class="line">SysTick-&gt;VAL = <span class="number">0X00</span>; <span class="comment">/* 清空计数器 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="delay-ms-函数-f1"><a href="#delay-ms-函数-f1" class="headerlink" title="delay_ms()函数(f1)"></a>delay_ms()函数(f1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用微秒延时函数实现</span></span><br><span class="line"><span class="comment">//us最多可以计数记多少秒：1/9000000*2^24=1s左右</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint16_t</span> nms)</span> <span class="comment">//传入要延时多少毫秒</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">uint32_t</span> repeat = nms / <span class="number">1000</span>;<span class="comment">/* 这里用1000,是考虑到可能有超频应用, </span></span><br><span class="line"><span class="comment">//取大于1000部分     * 比如128Mhz的时候, delay_us最大只能延时1048576us 约为1s</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">uint32_t</span> remain = nms % <span class="number">1000</span>; <span class="comment">//取小于1000部分</span></span><br><span class="line"><span class="keyword">while</span> (repeat) </span><br><span class="line">&#123; </span><br><span class="line">delay_us(<span class="number">1000</span> * <span class="number">1000</span>); <span class="comment">/* 利用delay_us 实现 1000ms 延时 */</span> 也即是<span class="number">1</span>s</span><br><span class="line">repeat--; <span class="comment">//把1000整数倍部分完成</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (remain) </span><br><span class="line">&#123; </span><br><span class="line">delay_us(remain * <span class="number">1000</span>); <span class="comment">/* 利用delay_us, 把尾数延时(remain ms)给做了 */</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Date-2023-06-05-1"><a href="#Date-2023-06-05-1" class="headerlink" title="- Date:2023-06-05"></a>- Date:2023-06-05</h1><ul><li>Time:17:08</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-06]]</li></ul><hr><h2 id="printf函数输出流程"><a href="#printf函数输出流程" class="headerlink" title="printf函数输出流程"></a>printf函数输出流程</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945863.png" alt="Pasted image 20230605171222|600"></p><h2 id="printf的使用"><a href="#printf的使用" class="headerlink" title="printf的使用"></a>printf的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;字符串\r\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;输出控制符&quot;，输出参数);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, temp);          <span class="comment">/* %d是输出控制符，temp是输出参数 */</span></span><br></pre></td></tr></table></figure><h3 id="常用输出控制符表"><a href="#常用输出控制符表" class="headerlink" title="常用输出控制符表"></a>常用输出控制符表</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945864.png" alt="Pasted image 20230605172851|600"></p><h3 id="常用转义字符表"><a href="#常用转义字符表" class="headerlink" title="常用转义字符表"></a>常用转义字符表</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945865.png" alt="Pasted image 20230605172915|600"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf(&quot;输出控制符1输出控制符2…&quot;，输出参数1，输出参数2，…);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp1 = <span class="number">5</span>;   </span><br><span class="line"><span class="type">uint32_t</span>  temp2 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%x \r \n&quot;</span>, temp1,temp2);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;非输出控制符 输出控制符 非输出控制符&quot;，输出参数);</span></span><br><span class="line"><span class="type">uint32_t</span>  temp = <span class="number">10</span>;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;temp=  %d  收到over\r\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何输出%、\和双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%% \r\n&quot;</span>);<span class="comment">// %</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\\\r\n&quot;</span>);<span class="comment">// \</span></span><br><span class="line"><span class="comment">printf(&quot;\&quot;\&quot;\r\n&quot;);// &quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="printf函数支持"><a href="#printf函数支持" class="headerlink" title="printf函数支持"></a>printf函数支持</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945866.png" alt="Pasted image 20230605173458|600"></p><h3 id="半主机模式简介"><a href="#半主机模式简介" class="headerlink" title="半主机模式简介"></a>半主机模式简介</h3><p>用于 ARM 目标的一种机制，可将来自应用程序代码的输入/输出请求传送至运行调试器的主机<br>简单说：就是通过仿真器实现开发板在电脑上的输入和输出<br>一般我们：不使用半主机模式！！！</p><h3 id="方法一：微库法"><a href="#方法一：微库法" class="headerlink" title="方法一：微库法"></a>方法一：微库法</h3><p>在魔术棒-&gt;Target选项卡，勾选：Use Micro LIB，即可避免半主机模式<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945867.png" alt="Pasted image 20230605173808|600"></p><h3 id="方法二：代码法"><a href="#方法二：代码法" class="headerlink" title="方法二：代码法"></a>方法二：代码法</h3><p>1个预处理、 2个定义、3个函数，会用就行</p><ol><li><h2 id="pragma-import-use-no-semihosting-，确保不从C库中使用半主机函数"><a href="#pragma-import-use-no-semihosting-，确保不从C库中使用半主机函数" class="headerlink" title="pragma import(__use_no_semihosting)，确保不从C库中使用半主机函数"></a>pragma import(__use_no_semihosting)，确保不从C库中使用半主机函数</h2></li><li>定义：__ FILE结构体，避免HAL库某些情况下报错</li><li>定义： FILE __ stdout，避免编译报错</li><li>实现：<em> ttywrch、</em> sys_exit和_sys_command_string等三个函数<br><font color="#ff0000">在历程（uart.c）中已经实现了</font><br><font color="#ff0000">到时候拷贝就好</font><h3 id="微库法-VS-代码法"><a href="#微库法-VS-代码法" class="headerlink" title="微库法 VS 代码法"></a>微库法 VS 代码法</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945868.png" alt="Pasted image 20230605174027|600"><h2 id="实现fputc函数"><a href="#实现fputc函数" class="headerlink" title="实现fputc函数"></a>实现fputc函数</h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945869.png" alt="Pasted image 20230605175055|600"><br>也不需要怎么知道</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-基础知识</title>
      <link href="/posts/1bce3e80.html"/>
      <url>/posts/1bce3e80.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-05-22"><a href="#Date-2023-05-22" class="headerlink" title="- Date:2023-05-22"></a>- Date:2023-05-22</h1><ul><li>Time:22:55</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h2><ol><li>存储器指可以存储数据的设备，本身没有地址信息，对存储器分配地址的过程称为存储器映射</li><li>19根地址线：A0-A18   16根数据线：D0-D15</li><li>地址范围：0 - 512K<ol><li>映射1：0 - 512K</li><li>映射2：1 – 512K + 1</li><li>映射3：100K – 612K</li><li>映射4：512K – 1024K</li></ol></li><li>F1为例子<ol><li>ST将4GB（2^32）地址空间分成8个块<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945405.png" alt="Pasted image 20230522230107|600"></li></ol></li><li>Block0（FLASH）功能划分<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945406.png" alt="Pasted image 20230522231205|600"></li></ol></li><li>Block1（SRAM）功能划分<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945407.png" alt="Pasted image 20230522231229|600"></li></ol></li><li>Block2（外设）功能划分<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945408.png" alt="Pasted image 20230522231356|600"><h3 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h3></li></ol></li></ol></li><li>寄存器是单片机内部一种特殊的内存，可以实现对单片机各个功能的控制</li><li>简单来说：寄存器就是单片机内部的控制机构<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945409.png" alt="Pasted image 20230522231543|600"></li></ol></li><li>STM32寄存器分类<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945410.png" alt="Pasted image 20230522231558|600"><h3 id="F1为例"><a href="#F1为例" class="headerlink" title="F1为例"></a>F1为例</h3></li></ol></li><li>寄存器是特殊的存储器，给寄存器地址命名的过程，就叫寄存器映射<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945411.png" alt="Pasted image 20230522232415|600"></li></ol></li><li>寄存器描述解读<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945412.png" alt="Pasted image 20230522232618|600"><ol><li>① 寄存器名字</li><li>② 偏移量及复位值</li><li>③ 寄存器位表</li><li>④ 位功能描述</li></ol></li><li>直接操作寄存器地址：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x4001</span> <span class="number">080</span>C) = <span class="number">0XFFFF</span>;</span><br><span class="line"><span class="comment">//强转unsigned int *,再取地址的值，然后进行操作</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名字后再操作：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    GPIOA_ODR    *(unsigned int *)(0x4001 080C)</span></span><br><span class="line">GPIOA_ODR = <span class="number">0XFFFF</span>；</span><br></pre></td></tr></table></figure><ol><li>寄存器地址计算<ol><li>为了方便编写代码及使用，我们将寄存器地址分为三个部分：<ol><li>总线基地址（BUS_BASE_ADDR）（对应总线表格中最下面的那个地址）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945413.png" alt="Pasted image 20230525091736|600"></li><li>APB1总线的基地址，也叫外设基地址（PERIPH_BASE）</li><li>此表的偏移量：是相对外设基地址（PERIPH_BASE）来说的</li></ol></li><li>外设基于总线基地址的偏移量（PERIPH_OFFSET）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945414.png" alt="Pasted image 20230525091902|600"></li><li>apb2为例子</li><li>此表的偏移量：是相对APB2外设基地址（APB2PERIPH_BASE）来说的</li><li>这是外设的基地址，上面是总线的基地址</li></ol></li><li>寄存器相对外设基地址的偏移量（REG_OFFSET）（对应8.24图的地址偏移0Ch）<ol><li>以GPIOA外设为例子</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945415.png" alt="Pasted image 20230525092031|600"></li><li>此表的偏移量：是相对GPIOA外设基地址（GPIOA_BASE（上图））来说的</li></ol></li></ol></li><li>例子计算过程（GPIOA_ODR寄存器地址计算过程）<ol><li>获取外设挂在哪个总线上面？查：系统结构图（同时得知道是哪个外设USART1_xx，那就是usart1）</li><li>获取总线基地址，APB2总线基地址：0X4001 0000</li><li>获取外设地址偏移量，GPIOA相对APB2总线偏移量是：0X800（一般可以直接找到外设地址）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945416.png" alt="Pasted image 20230525092659|600"></li></ol></li><li>获取寄存器地址偏移量，ODR相对GPIOA外设基地址的偏移量是：0X0C<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945417.png" alt="Pasted image 20230525092528|600"></li><li>在手册中找</li></ol></li><li>寄存器地址 = <font color="#ff0000">BUS_BASE_ADDR +  PERIPH_OFFSET + REG_OFFSET</font></li><li>GPIOA_ODR = 0X4001 0000 + 0X800 + 0X0C = 0X4001 080C</li></ol></li></ol></li><li>寄存器映射实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CRL;</span><br><span class="line">  __IO <span class="type">uint32_t</span> CRH;</span><br><span class="line">  __IO <span class="type">uint32_t</span> IDR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> ODR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> BSRR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> BRR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LCKR;</span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line">GPIOA_BASE： <span class="number">0X4001</span> <span class="number">0800</span></span><br></pre></td></tr></table></figure><ol><li>使用结构体，可以很方便的完成对寄存器的映射：</li><li>一次性把7个寄存器映射完毕，可对比上面的对一个寄存器映射</li><li>由于刚好结构体每个地址差4个字节，每个寄存器基地址之间差4个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>   GPIOA     ((GPIO_TypeDef *)GPIOA_BASE)</span></span><br><span class="line"><span class="comment">//强转GPIOA_BASE为结构体的地址</span></span><br><span class="line">&amp;GPIOA-&gt;CRL： <span class="number">0X4001</span> <span class="number">0800</span></span><br><span class="line">&amp;GPIOA-&gt;CRH： <span class="number">0X4001</span> <span class="number">0804</span></span><br><span class="line">&amp;GPIOA-&gt;IDR：  <span class="number">0X4001</span> <span class="number">0808</span></span><br><span class="line">&amp;GPIOA-&gt;ODR： <span class="number">0X4001</span> <span class="number">080</span>C</span><br><span class="line">实际应用：</span><br><span class="line"><span class="comment">//对地址的所指的位置赋值</span></span><br><span class="line"><span class="comment">//与前面单独对寄存器操作对比，方便了</span></span><br><span class="line">GPIOA-&gt; ODR = <span class="number">0XFFFF</span>；</span><br><span class="line">详见：stm32f103xe.h，<span class="number">725</span>行开始</span><br></pre></td></tr></table></figure></li></ol></li><li>stm32f103xe.h主要组成部分<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945418.png" alt="Pasted image 20230525094311|600"></li></ol></li></ol><h1 id="Date-2023-05-25"><a href="#Date-2023-05-25" class="headerlink" title="- Date:2023-05-25"></a>- Date:2023-05-25</h1><ul><li>Time:09:48</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="英文缩写部分"><a href="#英文缩写部分" class="headerlink" title="英文缩写部分"></a>英文缩写部分</h2><h3 id="A："><a href="#A：" class="headerlink" title="A："></a>A：</h3><p>ADC————Analog-to-Digital Converter—模/数转换器，模数转换器<br>AFIO———-alternate function IO—复用 IO 端口<br>AHB————先进高性能总线<br>AHB-AP——AHB访问端口<br>Arg————-argument—自变量<br>APB————先进外设总线<br>API————-Application Programming Interface—应用程序编程接口  </p><h3 id="B："><a href="#B：" class="headerlink" title="B："></a>B：</h3><p>BKP———后备寄存器<br>BSP———Board Support Package—板级支持包<br>BYP———Bypass—旁路<br>BYP———backup—备份  </p><h3 id="C："><a href="#C：" class="headerlink" title="C："></a>C：</h3><p>CAN——-Controller area network—控制器局域网<br>Calc——-Calculate—计算<br>CM———CMSIS标准—Cortex Microcontroller Software Interface Standard—Cortex微控制器软件接口标准<br>Cmd——-command—[kəˈmɑ:nd]—命令、使能<br>CLK———Clock—时钟<br>Conf——-Config—配置<br>CPI———-每条指令的周期数<br>CRC———Cyclic Redundancy Check—循环冗余校验<br>CSR———clock control/status register—时钟控制/状态寄存器<br>Ctrl— —-control—控制  </p><h3 id="D："><a href="#D：" class="headerlink" title="D："></a>D：</h3><p>DAC——-Digital to analog converter—数/模转换器，数字模拟转换器<br>DAP——-调试访问端口<br>DBG——-debug—调试<br>def ———Define—定义<br>DMA——Direct Memory Access—存储器直接访问<br>doc———Document—文件<br>DSP——-数字信号处理器/数字信号处理<br>DWT——数据观察点及跟踪  </p><h3 id="E："><a href="#E：" class="headerlink" title="E："></a>E：</h3><p>ETM———<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&amp;spm=1001.2101.3001.7020">嵌入式</a>跟踪宏单元<br>Eval———-Evaluate—评估<br>EXTI———-External Interrupts—外部中断  </p><h3 id="F："><a href="#F：" class="headerlink" title="F："></a>F：</h3><p>FLITF——-The Flash memory interface—闪存存储器接口<br>FPB———-闪存地址重载及断点<br>FPGA——-Field-Programmable Gate Array—现场可编程门阵列<br>FSMC——-Flexible static memory controller—可变静态存储控制器<br>FSR————Fault状态寄存器<br>FwLib——-Firmware Library—固件库  </p><h3 id="G："><a href="#G：" class="headerlink" title="G："></a>G：</h3><p>GPIO———general purpose input/output—通用 IO 端口<br>H：<br>HSE—————-High Speed External oscillator—高速外部时钟<br>HSI——————High Speed Internal oscillator—高速内部时钟<br>HTM—————CoreSight AHB跟踪宏单元  </p><h3 id="I："><a href="#I：" class="headerlink" title="I："></a>I：</h3><p>ICE————in circuit emulator—在线仿真器<br>IDE————integrated development environment—集成开发环境<br>inc————Include—包括<br>INT ———-it—Interrupt—中断<br>Init ———-Initialize—[ɪˈnɪʃəlaɪz]—初始化<br>I2C————IIC—Inter-integrated circuit—微集成电路<br>I2S————IIS—integrate interface of sound—集成音频接口<br>IRQ———-中断请求(通常是指外部中断的请求)<br>IRQn——-中断级<br>ISA———-指令系统架构<br>ISR————Interrupt Service Routines—中断服务程序<br>ITM———-指令跟踪宏单元<br>IWDG——independent watchdog—独立看门狗  </p><h3 id="J："><a href="#J：" class="headerlink" title="J："></a>J：</h3><p>JTAG————-连结点测试行动组(一个关于测试和调试接口的标准)<br>JTAG-DP——JTAG调试端口  </p><h3 id="L："><a href="#L：" class="headerlink" title="L："></a>L：</h3><p>Lib———lib—Library—库<br>LP———Low Power—低功耗<br>LR———link register—链接寄存器<br>LSB——-最低有效位<br>LSE——-Low Speed External oscillator—低速外部时钟<br>LSI———Low Speed Internal oscillator—低速内部时钟<br>LSU——-加载/存储单元  </p><h3 id="M："><a href="#M：" class="headerlink" title="M："></a>M：</h3><p>MCU—微控制器单元(俗称单片机)<br>MIPS—million instructions per second—每秒能执行的百万条指令的条数<br>MPU—Memory Protection Unit—存储器保护单元<br>MSB——最高有效位<br>MSP——main stack pointer—主堆栈指针  </p><h3 id="N："><a href="#N：" class="headerlink" title="N："></a>N：</h3><p>NVIC— Nested Vectored Interrupt Controller—嵌套向量中断控制器<br>NMI——不可屏蔽中断  </p><h3 id="O："><a href="#O：" class="headerlink" title="O："></a>O：</h3><p>OS——————操作系统<br>OTG—————On The Go—数据交换  </p><h3 id="P："><a href="#P：" class="headerlink" title="P："></a>P：</h3><p>PC———————program counter—程序计数器<br>Periph————-Peripherals—[pəˈrɪfərəlz]—外设<br>PLL———————Phase Locked Loop—锁相环\倍频器<br>PSP——————process stack pointer—进程堆栈指针<br>POR/PDR—上电/掉电复位<br>PPB—————-私有外设总线<br>PWR—————电源控制  </p><h3 id="R："><a href="#R：" class="headerlink" title="R："></a>R：</h3><p>RCC——————————Reset and clock control—复位和时钟控制<br>Retval————————Return value—返回值<br>RTC—————————-Real-Time Clock—实时时钟  </p><h3 id="S："><a href="#S：" class="headerlink" title="S："></a>S：</h3><p>SCB———-System control block<br>SDIO——-SD I/O—Secure Digital Input and Output—安全数字输入输出卡<br>SRAM——Static Random-Access Memory—静态随机存取存储器<br>SP————-stack pointer—堆栈指针<br>SPI————Serial Peripheral Interface—串行外围设备接口<br>src————Source—源码<br>std————Standard—[ˈstændəd]—标准<br>STK———-SysTick timer<br>SW——- —Software—软件  </p><h3 id="T："><a href="#T：" class="headerlink" title="T："></a>T：</h3><p>Tab——-table—表<br>TIM——-timer—定时器  </p><h3 id="U："><a href="#U：" class="headerlink" title="U："></a>U：</h3><p>UART———Universal Asynch. Receiver Transmitter—通用异步接收/发送装置<br>USART——-Universal Synchronou/Asynchronous Receiver/Transmitter—通用同步/异步串行接收/发送器<br>USB————Universal Serial Bus—通用串行总线<br>USBPRE—USB prescaler——USB预分频  </p><h3 id="W："><a href="#W：" class="headerlink" title="W："></a>W：</h3><p>WWDG—Window watchdog—窗口看门狗</p><h2 id="词汇部分"><a href="#词汇部分" class="headerlink" title="词汇部分"></a>词汇部分</h2><h3 id="A：-1"><a href="#A：-1" class="headerlink" title="A："></a>A：</h3><p>Acceleration—[əkˌseləˈreɪʃn]—加速度<br>Access—[ˈækses]—访问、进入<br>Accordingly—相应地<br>Activate—[ˈæktɪveɪt]—激活<br>add-on—附加物<br>address offset—地址偏移量<br>Alias—[ˈeɪliəs]—别名<br>Align—[əˈlaɪn]—校准，使一致<br>Alternate—[ˈɔ:ltərnət]—替代、备用<br>Arbitration—[ˌɑ:bɪˈtreɪʃn]—仲裁<br>Argument—[ˈɑ:ɡjumənt]—自变量<br>Array—[əˈreɪ]—数组<br>Assembler—[əˈsemblə®]—汇编器<br>Assert—[əˈsɜ:t]—断言  </p><h3 id="B：-1"><a href="#B：-1" class="headerlink" title="B："></a>B：</h3><p>Backslash—[ˈbækslæʃ]—(计算机符号)反斜线<br>Backup—备份<br>Brief—[bri:f]—任务简介<br>Buffer—[ˈbʌfə®]—缓存器，缓冲存储区  </p><h3 id="C：-1"><a href="#C：-1" class="headerlink" title="C："></a>C：</h3><p>Calibration—[ˌkælɪˈbreɪʃn]—校准<br>Call—调用<br>Capture—[ˈkæptʃə®]—捕获<br>Code—代码<br>Comments—注释<br>Compute—计算<br>Configure—[kənˈfɪɡə®]—配置<br>Constant—[ˈkɒnstənt]—常数<br>Counter—[ˈkaʊntə®]—计数器<br>Channel—[ˈtʃænl]—通道、源<br>Crystal—[ˈkrɪstl]—晶体  </p><h3 id="D：-1"><a href="#D：-1" class="headerlink" title="D："></a>D：</h3><p>Decode—[ˌdi:ˈkəʊd]—译码、解码<br>Decrement—[ˈdɛkrɪmənt]—减量，消耗<br>Default value—默认值<br>Depend on—根据<br>dependent variable–[dɪˌpendənt ˈveəriəbl]-因变量<br>Determine—[dɪˈtɜ:mɪn]—测定，查明<br>Differential—[ˌdɪfəˈrenʃl]—微分<br>Disassembly—反汇编  </p><h3 id="E：-1"><a href="#E：-1" class="headerlink" title="E："></a>E：</h3><p>Emulator—[ˈemjuleɪtə®]—仿真器<br>Enable—使能、启用<br>Entry—[ˈentri]—进入<br>Enumeration—[ɪˌnju:məˈreɪʃn]—枚举<br>Even—偶<br>Exceed—超过<br>Exception—[ɪkˈsepʃn]—异常<br>Execute—[ˈeksɪkju:t]—执行<br>Expanse—[ɪkˈspæns]—扩展<br>Export—[ɪkˈspɔ:t , ˈekspɔ:t]—输出、导出  </p><h3 id="F：-1"><a href="#F：-1" class="headerlink" title="F："></a>F：</h3><p>Falling edge—下降沿<br>Force—[fɔ:s]—强制<br>Frequency—[ˈfri:kwənsi]—频率  </p><h3 id="G：-1"><a href="#G：-1" class="headerlink" title="G："></a>G：</h3><p>Global variable—全局变量<br>Gyroscope—[ˈdʒaɪrəskəʊp]—陀螺仪  </p><h3 id="H："><a href="#H：" class="headerlink" title="H："></a>H：</h3><p>Halt—[hɔ:lt]—(使)停止<br>Handler—[ˈhændlə®]—处理程序<br>Hard Fault—硬件故障，硬故障<br>Hardware—硬件<br>Heap—[hi:p]—堆<br>Hint—[hɪnt]—提示  </p><h3 id="I：-1"><a href="#I：-1" class="headerlink" title="I："></a>I：</h3><p>Implement—[ˈɪmplɪments]—执行、工具<br>Indicate—[ˈɪndɪkeɪt]—表明<br>Infinite—[ˈɪnfɪnət]—无限的<br>Initial—[ɪˈnɪʃl]—最初的<br>Instructions—[ɪnˈstrʌkʃənz]—指令<br>Integral—[ˈɪntɪɡrəl]—积分<br>Interface—[ˈɪntəfeɪs]—接口  </p><h3 id="L：-1"><a href="#L：-1" class="headerlink" title="L："></a>L：</h3><p>Legacy—[ˈleɡəsi]—遗留<br>Local variable—局部变量<br>Loop—[lu:p]—循环  </p><h3 id="M：-1"><a href="#M：-1" class="headerlink" title="M："></a>M：</h3><p>Macro—宏，宏指令<br>Mapping—映射<br>Mask—屏蔽<br>Memory—[ˈmeməri]—存储器<br>Memory Manage—内存管理<br>Modify—[ˈmɒdɪfaɪɪŋ]—修改<br>Module—[ˈmɒdju:l]—模块<br>Mount on—安装  </p><h3 id="N：-1"><a href="#N：-1" class="headerlink" title="N："></a>N：</h3><p>Numeric—[nju(:)ˈmɛrɪk]—数（字，值）<br>Newline—换行符、新的一行  </p><h3 id="O：-1"><a href="#O：-1" class="headerlink" title="O："></a>O：</h3><p>Odd—奇<br>Offset—[ˈɒfset]—补偿<br>Operation—[ˌɒpəˈreɪʃn]—操作、运行<br>Oscillator—[ˈɒsɪleɪtə®]—振荡器  </p><h3 id="P：-1"><a href="#P：-1" class="headerlink" title="P："></a>P：</h3><p>Parallel—[ˈpærəlel]—并行<br>Parameter—[pəˈræmɪtə®]—参数<br>Parity—奇偶性<br>Perform—[pəˈfɔ:m]—执行<br>Permissions—[pəˈmɪʃənz]—权限<br>Preemption—[ˌpri:ˈempʃn]—抢占<br>Presentation—[ˌpreznˈteɪʃn]—显示、出示、演示<br>Priority Levels—[praɪˈɒrəti ˈlevlz]—优先级<br>Processor—[ˈprəʊsesə®]—处理器<br>Proportion—[prəˈpɔ:ʃn]—比例<br>Prototype—[ˈprəʊtətaɪp]—原型  </p><h3 id="R：-1"><a href="#R：-1" class="headerlink" title="R："></a>R：</h3><p>Recursive—[rɪˈkɜ:sɪv]—递归的、循环的<br>refer to—参阅<br>Remap—重新映射<br>Reset—重置<br>Rising edge—上升沿  </p><h3 id="S：-1"><a href="#S：-1" class="headerlink" title="S："></a>S：</h3><p>Schmitt Trigger—[ʃmɪt ˈtrɪɡər]—施密特触发器<br>Section—[ˈsekʃn]—部分，节<br>Select—[sɪˈlekt]—选择<br>Serial—[ˈsɪəriəl]—串行<br>service routine—服务程序<br>Setup—(软件或硬件的)安装，设置<br>Simplify—[ˈsɪmplɪfaɪ]—简化<br>Specified—[ˈspesɪfaɪd]—明确规定<br>Specifies—[ˈspesɪfaɪz]—指定<br>Suppression—[səˈpreʃn]—抑制<br>Stack—[stæk]—堆栈<br>Startup—启动<br>Stray—[streɪ]—孤立的、杂散的<br>Symbolic—[sɪmˈbɒlɪk]—象征性的  </p><h3 id="T：-1"><a href="#T：-1" class="headerlink" title="T："></a>T：</h3><p>Table—表<br>Tailor—[ˈteɪlə®]—专门制作，定做<br>Temperature—[ˈtemprətʃə®]—温度<br>Template—[ˈtempleɪt]—模板<br>Toggle—[ˈtɒɡl]—切换<br>Trigger—[ˈtrɪɡə®]—触发  </p><h3 id="U：-1"><a href="#U：-1" class="headerlink" title="U："></a>U：</h3><p>Uncomment—取消批注<br>Unique—[juˈni:k]—唯一的<br>Usage—[ˈju:sɪdʒ]—使用<br>Usart—通用同步异步收发器<br>Use—用途、使用  </p><h3 id="V："><a href="#V：" class="headerlink" title="V："></a>V：</h3><p>Vector—[ˈvektə®]—矢量<br>Velocity—速度<br>Voltage—[ˈvəʊltɪdʒ]—电压</p><h1 id="Date-2023-05-22-1"><a href="#Date-2023-05-22-1" class="headerlink" title="- Date:2023-05-22"></a>- Date:2023-05-22</h1><ul><li>Time:22:39</li><li>Subject: </li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="Cortex-M内核-amp-芯片"><a href="#Cortex-M内核-amp-芯片" class="headerlink" title="Cortex M内核 &amp; 芯片"></a>Cortex M内核 &amp; 芯片</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945058.png" alt="Pasted image 20230522224008|600"><h2 id="F1系统架构"><a href="#F1系统架构" class="headerlink" title="F1系统架构"></a>F1系统架构</h2></li><li>4个主动单元 + 4个被动单元</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945059.png" alt="Pasted image 20230522224227|600"><ol><li>AHB：高级高性能总线</li><li>APB：高级外围总线</li></ol></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945060.png" alt="Pasted image 20230522224605|600"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-hal</title>
      <link href="/posts/982d5dfa.html"/>
      <url>/posts/982d5dfa.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-05-25"><a href="#Date-2023-05-25" class="headerlink" title="- Date:2023-05-25"></a>- Date:2023-05-25</h1><ul><li>Time:15:57</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="基于CMSIS应用程序文件描述"><a href="#基于CMSIS应用程序文件描述" class="headerlink" title="基于CMSIS应用程序文件描述"></a>基于CMSIS应用程序文件描述</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030944008.png" alt="Pasted image 20230604222756|600"><h2 id="STM32开发文件结构分布"><a href="#STM32开发文件结构分布" class="headerlink" title="STM32开发文件结构分布"></a>STM32开发文件结构分布</h2></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030944009.png" alt="Pasted image 20230604222818|600"><h2 id="HAL库的用户配置文件（stm32f1xx-hal-conf-h）"><a href="#HAL库的用户配置文件（stm32f1xx-hal-conf-h）" class="headerlink" title="HAL库的用户配置文件（stm32f1xx_hal_conf.h）"></a>HAL库的用户配置文件（stm32f1xx_hal_conf.h）</h2></li><li>裁剪HAL库外设驱动源码（不进行编译）<ol><li>/#ifdef /#endif 的使用</li></ol></li><li>设置外部高速晶振频率（HSF）（根据开发板实际情况设置）</li><li>设置外部低速晶振频率（根据开发板实际情况设置）<h2 id="HAL库使用注意事项"><a href="#HAL库使用注意事项" class="headerlink" title="HAL库使用注意事项"></a>HAL库使用注意事项</h2></li><li>使用HAL库出现问题，还是得通过参考手册检查是否硬件操作是否有问题</li><li>尽量不通过修改库源码实现功能，这样不方便库更新</li><li>HAL库可能会存在错误，要有质疑精神</li><li>有些HAL库API函数执行效率偏低，我们可能会直接通过操作寄存器的方式代替</li></ol><h1 id="Date-2023-05-25-1"><a href="#Date-2023-05-25-1" class="headerlink" title="- Date:2023-05-25"></a>- Date:2023-05-25</h1><ul><li>Time:12:53</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-05]]</li></ul><hr><h2 id="CMSIS简介"><a href="#CMSIS简介" class="headerlink" title="CMSIS简介"></a>CMSIS简介</h2><ol><li>CMSIS (微控制器软件接口标准)：Cortex Microcontroller Software Interface Standard，是由ARM和与其合作的芯片厂商、软件工具厂商，共同制定的标准<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945752.png" alt="Pasted image 20230525151257|600"><h2 id="HAL库简介"><a href="#HAL库简介" class="headerlink" title="HAL库简介"></a>HAL库简介</h2></li></ol></li><li>ST 为了方便用户开发 STM32芯片开发提供了三种库：<ol><li>标准外设库 (Standard Peripheral Libraries)<ol><li>F0/F1/F3/F2/F4/L1</li><li>目前已停止维护</li></ol></li><li>HAL库(硬件抽象层)：Hardware Abstraction Layer<ol><li>全系列兼容</li><li>ST目前主推的库</li><li>兼容性、易移植性</li><li>效率低</li></ol></li><li>LL库：Low Layer<ol><li>全系列兼容</li><li>与HAL库捆绑发布</li><li>轻量级、效率高</li><li>不匹配部分复杂外设<h2 id="STM32Cube固件包浅析"><a href="#STM32Cube固件包浅析" class="headerlink" title="STM32Cube固件包浅析"></a>STM32Cube固件包浅析</h2><h3 id="STM32Cube固件包文件夹简介"><a href="#STM32Cube固件包文件夹简介" class="headerlink" title="STM32Cube固件包文件夹简介"></a>STM32Cube固件包文件夹简介</h3></li></ol></li></ol></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945753.png" alt="Pasted image 20230525151957|600"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945754.png" alt="Pasted image 20230525152058|600"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945755.png" alt="Pasted image 20230525152106|600"><h3 id="CMSIS文件夹关键文件"><a href="#CMSIS文件夹关键文件" class="headerlink" title="CMSIS文件夹关键文件"></a>CMSIS文件夹关键文件</h3></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945756.png" alt="Pasted image 20230525152122|600"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945757.png" alt="Pasted image 20230525152258|600"><h4 id="Device和Include文件夹的关键文件介绍"><a href="#Device和Include文件夹的关键文件介绍" class="headerlink" title="Device和Include文件夹的关键文件介绍"></a>Device和Include文件夹的关键文件介绍</h4></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945758.png" alt="Pasted image 20230525152330|600"></li><li>可以从cube固件包里面找<h2 id="HAL库框架结构"><a href="#HAL库框架结构" class="headerlink" title="HAL库框架结构"></a>HAL库框架结构</h2><h3 id="HAL库文件夹结构"><a href="#HAL库文件夹结构" class="headerlink" title="HAL库文件夹结构"></a>HAL库文件夹结构</h3></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945759.png" alt="Pasted image 20230525153514|600"><ol><li>Src(Source)：外设驱动源码</li><li>Inc(Include)：外设驱动源码头文件<h3 id="HAL库文件介绍"><a href="#HAL库文件介绍" class="headerlink" title="HAL库文件介绍"></a>HAL库文件介绍</h3></li></ol></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945760.png" alt="Pasted image 20230525153656|600"><h3 id="HAL库API函数和变量命名规则"><a href="#HAL库API函数和变量命名规则" class="headerlink" title="HAL库API函数和变量命名规则"></a>HAL库API函数和变量命名规则</h3></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945761.png" alt="Pasted image 20230525153716|600"><ol><li>初始化/反初始化函数:HAL_PPP_Init(),   HAL_PPP_DeInit()</li><li>外设读写函数:HAL_PPP_Read(),   HAL_PPP_Write(),   HAL_PPP_Transmit(),    HAL_PPP_Receive()</li><li>控制函数:HAL_PPP_Set (),     HAL_PPP_Get ()</li><li>状态和错误:HAL_PPP_GetState (),    HAL_PPP_GetError ()<h3 id="HAL库对寄存器位操作的相关宏定义"><a href="#HAL库对寄存器位操作的相关宏定义" class="headerlink" title="HAL库对寄存器位操作的相关宏定义"></a>HAL库对寄存器位操作的相关宏定义</h3></li></ol></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945762.png" alt="Pasted image 20230525154333|600"><h3 id="HAL库回调函数"><a href="#HAL库回调函数" class="headerlink" title="HAL库回调函数"></a>HAL库回调函数</h3></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945763.png" alt="Pasted image 20230525154615|600"><ol><li>此类函数通常被_weak修饰（弱函数），允许用户重新定义该函数</li></ol></li></ol><h1 id="Date-2023-06-04"><a href="#Date-2023-06-04" class="headerlink" title="- Date:2023-06-04"></a>- Date:2023-06-04</h1><ul><li>Time:22:41</li><li>Subject: none</li><li>Tags: #stm32<br>[[2023-06]]</li></ul><hr><h2 id="MAP文件浅析"><a href="#MAP文件浅析" class="headerlink" title="MAP文件浅析"></a>MAP文件浅析</h2><ol><li>MDK编译过程文件（11种）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945918.png" alt="Pasted image 20230604224248|600"></li></ol></li><li>MAP文件概念和作用<ol><li>MAP文件是MDK编译代码后，产生的集程序、数据及IO空间的一种映射列表文件</li><li>简单说就是包括了：各种.c文件、函数、符号等的地址、大小、引用关系等信息</li><li><font color="#ff0000">分析各.c文件占用FLASH 和 RAM的大小，方便优化代码</font></li></ol></li><li>MAP文件组成<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945919.png" alt="Pasted image 20230604224449|600"><h2 id="STM32启动过程"><a href="#STM32启动过程" class="headerlink" title="STM32启动过程"></a>STM32启动过程</h2></li></ol></li><li>STM32启动模式（F1/F4/F7/H7）（也称自举模式）<ol><li>M3/M4/M7等内核复位后，做的第一件事：<ol><li>从地址 0x0000 0000 处取出堆栈指针 MSP 的初始值，该值就是栈顶地址</li><li>从地址 0x0000 0004 处取出程序计数器指针 PC 的初始值，该值是复位向量</li></ol></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945920.png" alt="Pasted image 20230604225747|600"></li></ol></li><li>STM32启动模式（F1）<ol><li>在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945921.png" alt="Pasted image 20230604225826|600"></li></ol></li><li>STM32启动过程(内部FLASH启动为例)<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945922.png" alt="Pasted image 20230604230440|600"></li><li>.s启动文件介绍<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945923.png" alt="Pasted image 20230604230828|600"></li></ol></li><li>Reset_Handler函数介绍(汇编)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler   [WEAK]</span><br><span class="line">                IMPORT  __main</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                LDR   R0, =SystemInit</span><br><span class="line">                BLX   R0              </span><br><span class="line">                LDR   R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure><ol><li>EXPORT：标明全局属性，可被外部调用</li><li>IMPORT：申明来自外部文件，类extern</li><li>PROC：定义子程序</li><li>ENDP：表示子程序结束</li><li>WEAK：弱定义    <ol><li>堆栈简介</li></ol></li></ol></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945924.png" alt="Pasted image 20230604231214|600"></li><li>函数局部变量较多，嵌套关系复杂时，需加大栈大小（Stack_Size）！<h2 id="32启动过程图解"><a href="#32启动过程图解" class="headerlink" title="32启动过程图解"></a>32启动过程图解</h2></li></ol></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030945925.png" alt="Pasted image 20230604231507|600"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-gpio</title>
      <link href="/posts/6a0f884f.html"/>
      <url>/posts/6a0f884f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-06-08"><a href="#Date-2023-06-08" class="headerlink" title="- Date:2023-06-08"></a>- Date:2023-06-08</h1><ul><li>Time:20:49</li><li>Subject: none</li><li>Tags: #stm32 #GPIO<br>[[2023-06]]</li></ul><hr><h2 id="通用外设驱动模型（四步法）"><a href="#通用外设驱动模型（四步法）" class="headerlink" title="通用外设驱动模型（四步法）"></a>通用外设驱动模型（四步法）</h2><ol><li>初始化<ol><li>时钟设置：选择时钟源，启动时钟 </li><li>参数设置：gpio工作方式</li><li>io设置：除了gpio，如串口usart，</li><li>中断设置：开启，设置NVIC</li></ol></li><li>读函数（可选）<ol><li>从外设读取数据</li></ol></li><li>写函数（可选）<ol><li>往外设写入数据</li></ol></li><li>中断服务函数（可选）<ol><li>根据中断标志，处理外设各种中断事务<h2 id="GPIO配置步骤"><a href="#GPIO配置步骤" class="headerlink" title="GPIO配置步骤"></a>GPIO配置步骤</h2><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h3 id="使能时钟"><a href="#使能时钟" class="headerlink" title="使能时钟"></a>使能时钟</h3><font color="#ff0000">__HAL_RCC_GPIOx_CLK_ENABLE()</font><br>主要寄存器：<br>F1：RCC_APB2ENR //APB2总线上的<br>F4：RCC_AHB1ENR<br>F7：RCC_AHB1ENR<br>H7：RCC_AHB4ENR<br>开启GPIO时钟<h3 id="设置工作模式"><a href="#设置工作模式" class="headerlink" title="设置工作模式"></a>设置工作模式</h3><font color="#ff0000">HAL_GPIO_Init()</font><br>主要寄存器：<br>F1：CRL、CRH、ODR<br>F4/F7/H7：MODER、OTYPER、OSPEEDR、PUPDR<br>初始化GPIO<h3 id="设置输出状态（可选）"><a href="#设置输出状态（可选）" class="headerlink" title="设置输出状态（可选）"></a>设置输出状态（可选）</h3><font color="#ff0000">HAL_GPIO_WritePin()</font><br><font color="#ff0000">HAL_GPIO_TogglePin()</font><br>主要寄存器：<br>BSRR，控制IO输出高/低电平；BSRR，每次调用IO输出电平翻转一次<h3 id="读取输入状态（可选）"><a href="#读取输入状态（可选）" class="headerlink" title="读取输入状态（可选）"></a>读取输入状态（可选）</h3><font color="#ff0000">HAL_GPIO_ReadPin()</font><br>主要寄存器：<br>IDR，读取IO电平<h3 id="关键结构体简介"><a href="#关键结构体简介" class="headerlink" title="关键结构体简介"></a>关键结构体简介</h3>F1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> Pin;        <span class="comment">/* 引脚号 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Mode;   <span class="comment">/* 模式设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Pull;       <span class="comment">/* 上拉下拉设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Speed;  <span class="comment">/* 速度设置 */</span></span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>F4/F7/H7<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> Pin;              <span class="comment">/* 引脚号 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Mode;         <span class="comment">/* 模式设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Pull;            <span class="comment">/* 上拉下拉设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Speed;       <span class="comment">/* 速度设置 */</span></span><br><span class="line">  <span class="type">uint32_t</span> Alternate; <span class="comment">/* 复用功能 */</span></span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="Date-2023-06-08-1"><a href="#Date-2023-06-08-1" class="headerlink" title="- Date:2023-06-08"></a>- Date:2023-06-08</h1><ul><li>Time:19:32</li><li>Subject: none</li><li>Tags: #stm32 #GPIO<br>[[2023-06]]</li></ul><hr><h2 id="GPIO寄存器介绍"><a href="#GPIO寄存器介绍" class="headerlink" title="GPIO寄存器介绍"></a>GPIO寄存器介绍</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939351.png" alt="Pasted image 20230608193627|600"><br>x：A B….<br>yyy：寄存器简写</p><h3 id="端口配置-低-寄存器（CRL）-F1"><a href="#端口配置-低-寄存器（CRL）-F1" class="headerlink" title="端口配置 低 寄存器（CRL）- F1"></a>端口配置 <font color="#ff0000">低</font> 寄存器（CRL）- F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939352.png" alt="Pasted image 20230608195953|600"><br>需要上下表格同时看，3 2 1 0 控制一个io口，4bit控制一个io口，</p><h3 id="端口配置-高-寄存器（CRH）-F1"><a href="#端口配置-高-寄存器（CRH）-F1" class="headerlink" title="端口配置 高 寄存器（CRH）- F1"></a>端口配置 <font color="#ff0000">高</font> 寄存器（CRH）- F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939353.png" alt="Pasted image 20230608200615|600"><br>上面两个加起来控制16个io口，都起配置作用；每组 GPIO 下有 16 个 IO 口，一个寄存器共 32 位，每 4 个位控制 1 个 IO，所以才需要两个寄存器完成。</p><h3 id="工作模式配置补充-–-F1"><a href="#工作模式配置补充-–-F1" class="headerlink" title="工作模式配置补充 – F1"></a>工作模式配置补充 – F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939354.png" alt="Pasted image 20230608201001|600"><br>补充的原因：cnf1 cnf0位置配置上下拉输入，但是不确定，需要在odr寄存器中再设置</p><h3 id="端口输出数据寄存器（ODR）–-F1"><a href="#端口输出数据寄存器（ODR）–-F1" class="headerlink" title="端口输出数据寄存器（ODR）– F1"></a>端口输出数据寄存器（ODR）– F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939355.png" alt="Pasted image 20230608201200|600"><br>用于设置IO引脚输出的电平<br>PA10对应ODR10，设置功能对应的值看上图</p><h3 id="端口输入数据寄存器（IDR）–-F1"><a href="#端口输入数据寄存器（IDR）–-F1" class="headerlink" title="端口输入数据寄存器（IDR）– F1"></a>端口输入数据寄存器（IDR）– F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939356.png" alt="Pasted image 20230608202245|600"><br>用于判断IO引脚的电平，用于读取的外部输入的是高还是低的寄存器</p><h3 id="端口位设置-清除寄存器（BSRR）–-F1"><a href="#端口位设置-清除寄存器（BSRR）–-F1" class="headerlink" title="端口位设置/清除寄存器（BSRR）– F1"></a>端口位设置/清除寄存器（BSRR）– F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939357.png" alt="Pasted image 20230608202716|600"><br>比如再BS10设置为1，则ODR10位就输出高电平</p><h3 id="F4-F7-H7系列的GPIO相关寄存器略（看ppt"><a href="#F4-F7-H7系列的GPIO相关寄存器略（看ppt" class="headerlink" title="F4/F7/H7系列的GPIO相关寄存器略（看ppt"></a>F4/F7/H7系列的GPIO相关寄存器略（看ppt</h3><h3 id="ODR和BSRR寄存器控制输出有什么区别？"><a href="#ODR和BSRR寄存器控制输出有什么区别？" class="headerlink" title="ODR和BSRR寄存器控制输出有什么区别？"></a>ODR和BSRR寄存器控制输出有什么区别？</h3><p>ST官方给的答案：使用ODR，在读和修改访问之间产生中断时，可能会发生风险；BSRR则无风险。<br>BSRR  VS  ODR：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPIOB-&gt;ODR |= <span class="number">1</span> &lt;&lt; <span class="number">3</span>;           <span class="comment">/* PB3 = 1 */</span></span><br><span class="line">相当于ODR=ODR|(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)，先读取了原来的值，再进行操作</span><br><span class="line"></span><br><span class="line">GPIOB-&gt;BSRR = <span class="number">0x00000008</span>;      <span class="comment">/* PB3 = 1 */</span></span><br></pre></td></tr></table></figure><br>ODR修改：读-&gt;改-&gt;写<br>BSRR修改：              写<br>可能在 读改 或者 改写 的过程中有中断，发生问题<br>建议大家使用BSRR寄存器控制输出</p><h1 id="Date-2023-06-08-2"><a href="#Date-2023-06-08-2" class="headerlink" title="- Date:2023-06-08"></a>- Date:2023-06-08</h1><ul><li>Time:11:03</li><li>Subject: </li><li>Tags: #stm32 #GPIO<br>[[2023-06]]</li></ul><hr><h2 id="IO端口基本结构介绍"><a href="#IO端口基本结构介绍" class="headerlink" title="IO端口基本结构介绍"></a>IO端口基本结构介绍</h2><h3 id="F1的IO结构图"><a href="#F1的IO结构图" class="headerlink" title="F1的IO结构图"></a>F1的IO结构图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939773.png" alt="Pasted image 20230608110438|600"></p><h3 id="F4-F7-H7的IO结构图"><a href="#F4-F7-H7的IO结构图" class="headerlink" title="F4/F7/H7的IO结构图"></a>F4/F7/H7的IO结构图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939775.png" alt="Pasted image 20230608110411|600"></p><h3 id="施密特触发器简介"><a href="#施密特触发器简介" class="headerlink" title="施密特触发器简介"></a>施密特触发器简介</h3><p>施密特触发器就是一种整形电路，可以将非标准方波，整形成方波<br>特点：</p><ol><li>当输入电压高于正向阈值电压，输出为高；</li><li>当输入电压低于负向阈值电压，输出为低；</li><li>当输入在正负向阈值电压之间，输出不改变。<br>效果：整形！如正弦波转方波<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939776.png" alt="Pasted image 20230608111057|600"><h3 id="P-MOS-amp-N-MOS管简介"><a href="#P-MOS-amp-N-MOS管简介" class="headerlink" title="P-MOS &amp; N-MOS管简介"></a>P-MOS &amp; N-MOS管简介</h3>MOS管是压控型元件，通过控制栅源电压（ Vgs ）来实现导通或关闭。<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939777.png" alt="Pasted image 20230608112257|600"><br>Vgs=Vg-Vs，用1，0的逻辑来看也可以的<br>P是G接入高电平不导通，相当于两个1不导通<br>N则是两个0不导通，G接入高电平导通<h2 id="GPIO的八种模式分析"><a href="#GPIO的八种模式分析" class="headerlink" title="GPIO的八种模式分析"></a>GPIO的八种模式分析</h2><strong>从stm32f103参考手册中的章节可以找出来</strong><br>四个输入，四个输出<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939778.png" alt="Pasted image 20230608112801|600"><h3 id="GPIO工作模式：输入浮空"><a href="#GPIO工作模式：输入浮空" class="headerlink" title="GPIO工作模式：输入浮空"></a>GPIO工作模式：输入浮空</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939779.png" alt="Pasted image 20230608112900|600"><br>外部高阻态的时候<h3 id="GPIO工作模式：输入上拉"><a href="#GPIO工作模式：输入上拉" class="headerlink" title="GPIO工作模式：输入上拉"></a>GPIO工作模式：输入上拉</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939780.png" alt="Pasted image 20230608113146|600"><h3 id="GPIO工作模式：输入下拉"><a href="#GPIO工作模式：输入下拉" class="headerlink" title="GPIO工作模式：输入下拉"></a>GPIO工作模式：输入下拉</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939781.png" alt="Pasted image 20230608113208|600"><h3 id="GPIO工作模式：模拟功能"><a href="#GPIO工作模式：模拟功能" class="headerlink" title="GPIO工作模式：模拟功能"></a>GPIO工作模式：模拟功能</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939782.png" alt="Pasted image 20230608113310|600"><h3 id="GPIO工作模式：开漏输出"><a href="#GPIO工作模式：开漏输出" class="headerlink" title="GPIO工作模式：开漏输出"></a>GPIO工作模式：开漏输出</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939783.png" alt="Pasted image 20230608113316|600"><br>P-MOS的G端一直高电平，一直不导通，N端受输出控制控制，ODR给0，则输出控制高（<font color="#ff0000">输出控制的地方相当于对信号进行了取反操作</font>），mos导通（<font color="#ff0000">把VSS的低电平输出出去了</font>），给1则输出低，mos不导通（形成高阻态，没有意义，但是看后面），这样让N-MOS开或者关，<font color="#ff0000">同时外面I/O引脚处有个上拉电阻（必须），那么则会输出上拉电阻处的高电平，高阻态则可忽略掉，让整个引脚的电压情况随着N-MOS的情况改变</font><br> 相当于这样：<img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939784.png" alt="Pasted image 20230608191400|600"><br>f1是要自己搞外部上拉，其他的自带内部，可看前面的图<br>允许输入，ttl肖特基触发器接通了<br>ODR是输出数据寄存器，IDR就是上面输入的那个<h3 id="GPIO工作模式：开漏式复用功能"><a href="#GPIO工作模式：开漏式复用功能" class="headerlink" title="GPIO工作模式：开漏式复用功能"></a>GPIO工作模式：开漏式复用功能</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939785.png" alt="Pasted image 20230608113411|600"><br>片上外设控制，仍让需要外部上拉<h3 id="GPIO工作模式：推挽输出"><a href="#GPIO工作模式：推挽输出" class="headerlink" title="GPIO工作模式：推挽输出"></a>GPIO工作模式：推挽输出</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939786.png" alt="Pasted image 20230608113422|600"><br>与开漏有区别，两个mos分别在ODR 的0/1的时候作用<h3 id="GPIO工作模式：推挽式复用功能"><a href="#GPIO工作模式：推挽式复用功能" class="headerlink" title="GPIO工作模式：推挽式复用功能"></a>GPIO工作模式：推挽式复用功能</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939787.png" alt="Pasted image 20230608113433|600"></li></ol><h1 id="Date-2023-06-08-3"><a href="#Date-2023-06-08-3" class="headerlink" title="- Date:2023-06-08"></a>- Date:2023-06-08</h1><ul><li>Time:10:50</li><li>Subject: </li><li>Tags: #stm32 #GPIO<br>[[2023-06]]</li></ul><hr><h2 id="什么是GPIO"><a href="#什么是GPIO" class="headerlink" title="什么是GPIO"></a>什么是GPIO</h2><p>General Purpose Input Output，即通用输入输出端口，简称GPIO<br>作用：负责采集外部器件的信息或者控制外部器件工作，即输入输出<br>例子：<img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939457.png" alt="Pasted image 20230608105342|600"></p><h2 id="STM32-GPIO简介"><a href="#STM32-GPIO简介" class="headerlink" title="STM32 GPIO简介"></a>STM32 GPIO简介</h2><h3 id="GPIO特点"><a href="#GPIO特点" class="headerlink" title="GPIO特点"></a>GPIO特点</h3><ol><li>不同型号，IO口数量可能不一样，可通过选型手册快速查询</li><li>快速翻转，每次翻转最快只需要两个时钟周期（F1最高速度可以到50Mhz）</li><li>每个IO口都可以做中断</li><li>支持8种工作模式<h3 id="GPIO电器特性"><a href="#GPIO电器特性" class="headerlink" title="GPIO电器特性"></a>GPIO电器特性</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939458.png" alt="Pasted image 20230608105512|600"><br>TTL端口：标识FT，5v-3.3v<br>为什么是-0.3和3.6，因为有保护二极管，钳位，有压降和压升<h3 id="GPIO引脚分布"><a href="#GPIO引脚分布" class="headerlink" title="GPIO引脚分布"></a>GPIO引脚分布</h3><h4 id="STM32引脚类型："><a href="#STM32引脚类型：" class="headerlink" title="STM32引脚类型："></a>STM32引脚类型：</h4></li><li>电源引脚（v开头）、晶振引脚（低速标32，高速不确定）、复位引脚（nrst）、下载引脚、BOOT引脚（boot0 boot1）、GPIO引脚（p开头）<h4 id="不同芯片引脚分布情况"><a href="#不同芯片引脚分布情况" class="headerlink" title="不同芯片引脚分布情况"></a>不同芯片引脚分布情况</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939459.png" alt="Pasted image 20230608105642|600"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-cubemx</title>
      <link href="/posts/d231037d.html"/>
      <url>/posts/d231037d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-06-04"><a href="#Date-2023-06-04" class="headerlink" title="- Date:2023-06-04"></a>- Date:2023-06-04</h1><ul><li>Time:23:37</li><li>Subject: none</li><li>Tags: #stm32 #配置<br>[[2023-06]]</li></ul><hr><h1 id="STM32CubeMX简介"><a href="#STM32CubeMX简介" class="headerlink" title="STM32CubeMX简介"></a>STM32CubeMX简介</h1><ol><li>STM32CubeMX是ST开发的一款图形配置工具，可通过配置自动生成初始化代码</li><li>一个图形配置工具，搭配不同系列的STM32Cube固件包，即可支持不同系列的STM32芯片<h1 id="新建STM32CubeMX工程步骤"><a href="#新建STM32CubeMX工程步骤" class="headerlink" title="新建STM32CubeMX工程步骤"></a>新建STM32CubeMX工程步骤</h1><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939841.png" alt="Pasted image 20230604234829|600"><h2 id="一个小细节"><a href="#一个小细节" class="headerlink" title="一个小细节"></a>一个小细节</h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939842.png" alt="Pasted image 20230604234855|600"><br>选用basic，详细的配置看视频吧<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030939843.png" alt="Pasted image 20230605143431|600"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-中断</title>
      <link href="/posts/cad4ed3.html"/>
      <url>/posts/cad4ed3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-06-10"><a href="#Date-2023-06-10" class="headerlink" title="- Date:2023-06-10"></a>- Date:2023-06-10</h1><ul><li>Time:09:07</li><li>Subject: none</li><li>Tags: #stm32 #中断<br>[[2023-06]]</li></ul><hr><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><p>打断CPU执行正常的程序，转而处理紧急程序，然后返回原暂停的程序继续运行，就叫中断<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938710.png" alt="Pasted image 20230610090837|600"></p><h3 id="中断的作用和意义"><a href="#中断的作用和意义" class="headerlink" title="中断的作用和意义"></a>中断的作用和意义</h3><ol><li>实时控制：在确定时间内对相应事件作出响应，如：温度监控</li><li>故障处理：检测到故障，需要第一时间处理，如：电梯门夹人了</li><li>数据传输：不确定数据何时会来，如：串口数据接收<br>中断的意义：高效处理紧急程序，<font color="#ff0000">不会一直占用CPU资源</font><h3 id="STM32-GPIO外部中断简图"><a href="#STM32-GPIO外部中断简图" class="headerlink" title="STM32 GPIO外部中断简图"></a>STM32 GPIO外部中断简图</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938711.png" alt="Pasted image 20230610091024|600"></li></ol><h1 id="Date-2023-06-10-1"><a href="#Date-2023-06-10-1" class="headerlink" title="- Date:2023-06-10"></a>- Date:2023-06-10</h1><ul><li>Time:09:12</li><li>Subject: none</li><li>Tags: #stm32 #NVIC #中断<br>[[2023-06]]</li></ul><hr><h2 id="NVIC基本概念"><a href="#NVIC基本概念" class="headerlink" title="NVIC基本概念"></a>NVIC基本概念</h2><p>Nested vectored interrupt controller，嵌套向量中断控制器，属于内核（M3/4/7）<br>NVIC支持：256个中断（16内核 + 240外部），支持：256个优先级，允许裁剪！<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938136.png" alt="Pasted image 20230610091507|600"></p><h3 id="什么是中断向量表？"><a href="#什么是中断向量表？" class="headerlink" title="什么是中断向量表？"></a>什么是中断向量表？</h3><p>定义一块固定的内存，以4字节对齐，存放各个中断服务函数程序的首地址<br>中断向量表定义在启动文件，当发生中断，CPU会自动执行对应的中断服务函数<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938137.png" alt="Pasted image 20230610091612|600"></p><h2 id="NVIC相关寄存器介绍"><a href="#NVIC相关寄存器介绍" class="headerlink" title="NVIC相关寄存器介绍"></a>NVIC相关寄存器介绍</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938138.png" alt="Pasted image 20230610092001|600"></p><h2 id="NVIC工作原理"><a href="#NVIC工作原理" class="headerlink" title="NVIC工作原理"></a>NVIC工作原理</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938139.png" alt="Pasted image 20230610092200|600"></p><h2 id="STM32中断优先级基本概念"><a href="#STM32中断优先级基本概念" class="headerlink" title="STM32中断优先级基本概念"></a>STM32中断优先级基本概念</h2><ol><li><font color="#ff0000">抢占优先级</font>(pre)：高抢占优先级可以打断正在执行的低抢占优先级中断（这个优先考虑）</li><li><font color="#ff0000">响应优先级</font>(sub)：(子优先级)当抢占优先级相同时，响应优先级高的先执行，但是不能<font color="#ff0000">互相打断</font>，就是不能在别人执行的时候插进去，按谁先的顺序</li><li>抢占和响应都相同的情况下，<font color="#ff0000">自然优先级</font>越高的，先执行</li><li>自然优先级：中断向量表的优先级</li><li>数值越小，表示优先级越高<h2 id="STM32中断优先级分组"><a href="#STM32中断优先级分组" class="headerlink" title="STM32中断优先级分组"></a>STM32中断优先级分组</h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938140.png" alt="Pasted image 20230610110350|600"><br>几位表示有2的几次方个优先级可使用<br><font color="#ff0000">特别提示：一个工程中，一般只设置一次中断优先级分组。</font><br>参考：STM32F10xxx编程手册（英文版）.pdf，4.4.5节<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3>假设分组为2<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938141.png" alt="Pasted image 20230610110730|600"><br>EXTI1和RTC可以打断：EXTI0和Systick的中断，获得优先执行！<h2 id="STM32-NVIC的使用"><a href="#STM32-NVIC的使用" class="headerlink" title="STM32 NVIC的使用"></a>STM32 NVIC的使用</h2><h3 id="设置中断分组"><a href="#设置中断分组" class="headerlink" title="设置中断分组"></a>设置中断分组</h3>寄存器：AIRCR[10:8]，<br>HAL_NVIC_SetPriorityGrouping<h3 id="设置中断优先级"><a href="#设置中断优先级" class="headerlink" title="设置中断优先级"></a>设置中断优先级</h3>寄存器：IPRx bit[7:4]，<br>HAL_NVIC_SetPriority<h3 id="使能中断"><a href="#使能中断" class="headerlink" title="使能中断"></a>使能中断</h3>寄存器：ISERx，<br>HAL_NVIC_EnableIRQ<br>特别提醒：例程中，中断分组已经在HAL_Init()函数中设置了分组2<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);</span><br></pre></td></tr></table></figure><h2 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h2><h1 id="EXTI-1"><a href="#EXTI-1" class="headerlink" title="EXTI"></a>EXTI</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>External(Extended) interrupt/event Controller，外部(扩展)中断事件控制器<br>包含20个产生事件/中断请求的边沿检测器，即总共：20条EXTI线（F1）<h4 id="中断和事件的理解："><a href="#中断和事件的理解：" class="headerlink" title="中断和事件的理解："></a>中断和事件的理解：</h4>中断：要进入NVIC，有相应的中断服务函数，需要CPU处理<br>事件：不进入NVIC，仅用于内部硬件自动控制的，如：TIM、DMA、ADC<h4 id="EXTI支持的外部中断-事件请求"><a href="#EXTI支持的外部中断-事件请求" class="headerlink" title="EXTI支持的外部中断/事件请求"></a>EXTI支持的外部中断/事件请求</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938142.png" alt="Pasted image 20230610114128|600"><h3 id="EXTI主要特性"><a href="#EXTI主要特性" class="headerlink" title="EXTI主要特性"></a>EXTI主要特性</h3>F1/F4/F7系列<br>每条EXTI线都可以单独配置：选择类型（中断或者事件）、触发方式（上升沿，下降沿或者双边沿触发）、支持软件触发、开启/屏蔽、有挂起状态位<h3 id="EXTI工作原理（F1-F4-F7系列）"><a href="#EXTI工作原理（F1-F4-F7系列）" class="headerlink" title="EXTI工作原理（F1/F4/F7系列）"></a>EXTI工作原理（F1/F4/F7系列）</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938143.png" alt="Pasted image 20230610115021|600"><br>注：</li><li>/20 是f1有20条exit线，虽然32位，但是只有20条有效<br>①，边沿检测，检测输入信号变换<br>②，软件触发，swier置1，那么是软件触发，此处是或门，一个1就能过，置0则硬件触发<br>③，中断屏蔽/清除，都置1才可到nvic（与门）<br>④，事件屏蔽，都置1，给外设产生事件（少用）<br>了解寄存器：</li><li>EXTI_FTSR 下降沿</li><li>EXTI_RTSR 上升沿</li><li>EXTI_IMR 中断屏蔽</li><li>EXTI_PR 挂起<h2 id="EXTI和IO映射关系"><a href="#EXTI和IO映射关系" class="headerlink" title="EXTI和IO映射关系"></a>EXTI和IO映射关系</h2><h3 id="AFIO简介（F1）"><a href="#AFIO简介（F1）" class="headerlink" title="AFIO简介（F1）"></a>AFIO简介（F1）</h3>Alternate Function IO，即复用功能IO，主要用于重映射和外部中断映射配置</li><li>调试io配置  AFIO_MAPR[26:24]，配置JTAG/SWD的开关状态</li><li>重映射配置 AFIO_MAPR，部分外设IO重映射配置</li><li>（重点）外部中断配置 AFIO_EXTICR1~4，配置EXTI中断线0~15对应具体哪个IO口<br>特别注意：配置AFIO寄存器之前要使能AFIO时钟，方法如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__HAL_RCC_AFIO_CLK_ENABLE();      对应RCC_APB2ENR寄存器 位<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="EXTI-与-IO对应关系"><a href="#EXTI-与-IO对应关系" class="headerlink" title="EXTI 与 IO对应关系"></a>EXTI 与 IO对应关系</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938144.png" alt="Pasted image 20230610140831|600"><br>AFIO_EXTICR1的 EXTI0[3:0]位控制（4个位）（F1）<br> 配置好一个，如PG0，其他的Px0用不上了，是一一对应关系的<br>SYSCFG_EXTICR1的 EXTI0[3:0]位控制（F4/F7/H7）<br>注：图上的一列0为引脚号，abc…为分组号，x可为abc…<br>Px0映射到EXTI0<br>Px1映射到EXTI1<br>…<br>Px14映射到EXTI14<br>Px15映射到EXTI15<h2 id="如何使用中断"><a href="#如何使用中断" class="headerlink" title="如何使用中断"></a>如何使用中断</h2><h3 id="STM32-EXTI的配置步骤（外部中断）"><a href="#STM32-EXTI的配置步骤（外部中断）" class="headerlink" title="STM32 EXTI的配置步骤（外部中断）"></a>STM32 EXTI的配置步骤（外部中断）</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938145.png" alt="Pasted image 20230610153315|600"><br>其他外设可以直接进入EXTI<h3 id="STM32-EXTI的设置步骤（外部中断）"><a href="#STM32-EXTI的设置步骤（外部中断）" class="headerlink" title="STM32 EXTI的设置步骤（外部中断）"></a>STM32 EXTI的设置步骤（外部中断）</h3><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1></li><li>使能GPIO时钟<ol><li>使能GPIO时钟</li></ol></li><li>设置GPIO输入模式<ol><li>上/下拉/浮空输入</li></ol></li><li>使能AFIO/SYSCFG时钟<ol><li>设置AFIO/SYSCFG时钟开启寄存器</li></ol></li><li>设置EXTI和IO对应关系<ol><li>选择PA~PK到底哪组IO对应EXTI输入线，AFIO_EXTICR/ SYSCFG_EXTICR</li></ol></li><li>设置EXTI屏蔽，上/下沿<ol><li>设置EXTI对应通道的屏蔽和上升沿/下降沿触发，IMR、 RTSR/FTSR</li></ol></li><li>设置NVIC<ol><li>分3步，见前面内容，即：设置优先级分组、设置优先级、使能中断</li></ol></li><li>设计中断服务函数<ol><li>编写对应中断的中断服务函数！清中断标志！<br>注意：步骤2 - 5  使用HAL_GPIO_Init<font color="#ff0000">一步到位</font><h3 id="STM32-EXTI的HAL库设置步骤（外部中断）"><a href="#STM32-EXTI的HAL库设置步骤（外部中断）" class="headerlink" title="STM32 EXTI的HAL库设置步骤（外部中断）"></a>STM32 EXTI的<font color="#ff0000">HAL</font>库设置步骤（外部中断）</h3></li></ol></li><li>使能GPIO时钟<ol><li>__ HAL_RCC_GPIOx_CLK_ENABLE</li></ol></li><li>GPIO/AFIO(SYSCFG)/EXTI<ol><li>HAL_GPIO_Init  ，一步到位</li></ol></li><li>设置中断分组<ol><li>HAL_NVIC_SetPriorityGrouping，此函数仅需设置一次！</li></ol></li><li>设置中断优先级<ol><li>HAL_NVIC_SetPriority</li></ol></li><li>使能中断<ol><li>HAL_NVIC_EnableIRQ</li></ol></li><li>设计中断服务函数<ol><li>EXTIx_IRQHandler，中断服务函数，清中断标志！<font color="#ff0000">得去.s 文件里面找</font></li><li>STM32仅有：EXTI0~4、EXTI9_5(这个指5-9只有一个，后面同理)、EXTI15_10，7个外部中断服务函数<h3 id="通用外设驱动模型（四步法）"><a href="#通用外设驱动模型（四步法）" class="headerlink" title="通用外设驱动模型（四步法）"></a>通用外设驱动模型（四步法）</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938146.png" alt="Pasted image 20230613104503|600"><h3 id="HAL库中断回调处理机制介绍"><a href="#HAL库中断回调处理机制介绍" class="headerlink" title="HAL库中断回调处理机制介绍"></a>HAL库中断回调处理机制介绍</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938147.png" alt="Pasted image 20230613112318|600"><br>公用函数在gpio里面找，HAL_GPIO_EXTI_IRQHandler</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-时钟系统</title>
      <link href="/posts/6bd75491.html"/>
      <url>/posts/6bd75491.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-06-05"><a href="#Date-2023-06-05" class="headerlink" title="- Date:2023-06-05"></a>- Date:2023-06-05</h1><ul><li>Time:14:21</li><li>Subject: none</li><li>Tags: #stm32 #时钟<br>[[2023-06]]</li></ul><hr><h2 id="什么是时钟"><a href="#什么是时钟" class="headerlink" title="什么是时钟"></a>什么是时钟</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938780.png" alt="Pasted image 20230605142235|600"></p><ol><li>简单来说，时钟是具有周期性的脉冲信号，最常用的是占空比50%的方波</li><li>时钟是单片机的脉搏，搞懂时钟走向及关系，对单片机使用至关重要！<h2 id="认识时钟树（F1）"><a href="#认识时钟树（F1）" class="headerlink" title="认识时钟树（F1）"></a>认识时钟树（F1）</h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938781.png" alt="Pasted image 20230605142506|600"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938782.png" alt="Pasted image 20230605142425|600"><br>L：low<br>S：speed<br>I：internal<br>E：external<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938783.png" alt="Pasted image 20230605142543|600"><h3 id="时钟树简图"><a href="#时钟树简图" class="headerlink" title="时钟树简图"></a>时钟树简图</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938784.png" alt="Pasted image 20230605142739|600"></li><li>PLL：锁相环，倍频系数：2~3（PLLCLK）</li><li>HSE分频可以说/1或者/2，HSI分频/2，再来到PLL倍频</li><li>HCLK前分频也用1，保持72mhz</li><li>APB1则分频/2，<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938785.png" alt="Pasted image 20230605143203|600"></li><li>低速晶振<h3 id="HAL库内体现"><a href="#HAL库内体现" class="headerlink" title="HAL库内体现"></a>HAL库内体现</h3></li><li>时钟源、锁相环：HAL_RCC_OscConfig()</li><li>系统时钟、总线：HAL_RCC_ClockConfig()</li><li>使能外设时钟：<em> </em> HAL_RCC_PPP_CLK_ENABLE()   是一个宏定义，打开外设时使用时</li><li>扩展外设时钟(RTC/ADC/USB)：HAL_RCCEx_PeriphCLKConfig()<h3 id="STM32CubeMX时钟树（F103）"><a href="#STM32CubeMX时钟树（F103）" class="headerlink" title="STM32CubeMX时钟树（F103）"></a>STM32CubeMX时钟树（F103）</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938786.png" alt="Pasted image 20230605143431|600"></li></ol><h1 id="Date-2023-06-05-1"><a href="#Date-2023-06-05-1" class="headerlink" title="- Date:2023-06-05"></a>- Date:2023-06-05</h1><ul><li>Time:15:01</li><li>Subject: none</li><li>Tags: #stm32 #配置 #时钟<br>[[2023-06]]</li></ul><hr><h2 id="系统时钟配置步骤"><a href="#系统时钟配置步骤" class="headerlink" title="系统时钟配置步骤"></a>系统时钟配置步骤</h2><ol><li>配置HSE_VALUE<ol><li>告诉HAL库外部晶振频率，stm32xxxx_hal_conf.h</li></ol></li><li>调用SystemInit()函数（可选）<ol><li>在启动文件中调用， 在system_stm32xxxx.c定义</li></ol></li><li>选择时钟源，配置PLL<ol><li>通过HAL_RCC_OscConfig()函数设置</li></ol></li><li>选择系统时钟源，配置总线分频器<ol><li>通过HAL_RCC_ClockConfig()函数设置</li></ol></li><li>配置扩展外设时钟（可选）<ol><li>通过HAL_RCCEx_PeriphCLKConfig()函数设置<br>注：<br>3 + 4 + 5 = sys_stm32_clock_init()   //正点原子配置<h2 id="外设时钟使能和失能"><a href="#外设时钟使能和失能" class="headerlink" title="外设时钟使能和失能"></a>外设时钟使能和失能</h2><font color="#ff0000">我们要使用某个外设，必需先使能该外设时钟！！！</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL库使能某个外设时钟的方法，如：</span><br><span class="line">__HAL_RCC_GPIOA_CLK_ENABLE();        <span class="comment">/* 使能 GPIOA 时钟 */</span></span><br><span class="line">HAL库禁止某个外设时钟的方法，如：</span><br><span class="line">__HAL_RCC_GPIOA_CLK_DISABLE();        <span class="comment">/* 禁止 GPIOA 时钟 */</span></span><br></pre></td></tr></table></figure><h2 id="sys-stm32-clock-init-函数（F1）"><a href="#sys-stm32-clock-init-函数（F1）" class="headerlink" title="sys_stm32_clock_init 函数（F1）"></a>sys_stm32_clock_init 函数（F1）</h2>结合上一个md的图表来看，是对对应位的配置<h3 id="HAL-RCC-OscConfig-函数"><a href="#HAL-RCC-OscConfig-函数" class="headerlink" title="HAL_RCC_OscConfig()函数"></a>HAL_RCC_OscConfig()函数</h3>返回值：HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span>  OscillatorType;   <span class="comment">/* 选择需要配置的振荡器 */</span>  </span><br><span class="line">  <span class="type">uint32_t</span>  HSEState;   <span class="comment">/* HSE 状态 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  HSEPredivValue;   <span class="comment">/* HSE 预分频值 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  LSEState;   <span class="comment">/* LSE 状态 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  HSIState;   <span class="comment">/* HSI状态 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  HSICalibrationValue;   <span class="comment">/* HSI 校准值 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  LSIState;   <span class="comment">/* LSI 状态 */</span></span><br><span class="line">  RCC_PLLInitTypeDef  PLL;   <span class="comment">/* PLL 结构体 */</span></span><br><span class="line">&#125;RCC_OscInitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span>  PLLState;   <span class="comment">/* PLL 状态 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  PLLSource;   <span class="comment">/* PLL 时钟源 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  PLLMUL;   <span class="comment">/* PLL 倍频系数 */</span></span><br><span class="line">&#125;RCC_PLLInitTypeDef;</span><br></pre></td></tr></table></figure><h3 id="HAL-RCC-ClockConfig-函数"><a href="#HAL-RCC-ClockConfig-函数" class="headerlink" title="HAL_RCC_ClockConfig()函数"></a>HAL_RCC_ClockConfig()函数</h3>返回值：HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span>  ClockType;   <span class="comment">/* 要配置的时钟（SYSCLK/HCLK/PCLK1/PCLK2） */</span></span><br><span class="line">  <span class="type">uint32_t</span>  SYSCLKSource;   <span class="comment">/* 系统时钟源 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  AHBCLKDivider;   <span class="comment">/* AHB  时钟预分频系数 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  APB1CLKDivider;   <span class="comment">/* APB1 时钟预分频系数 */</span></span><br><span class="line">  <span class="type">uint32_t</span>  APB2CLKDivider;   <span class="comment">/* APB2 时钟预分频系数 */</span></span><br><span class="line">&#125;RCC_ClkInitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> FLatency</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  FLASH_LATENCY_0   0x00000000U   <span class="comment">/* FLASH 0个等待周期 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  FLASH_LATENCY_1   FLASH_ACR_LATENCY_0   <span class="comment">/* FLASH 1个等待周期 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  FLASH_LATENCY_2   FLASH_ACR_LATENCY_1   <span class="comment">/* FLASH 2个等待周期 */</span></span></span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-定时器</title>
      <link href="/posts/1ba7a976.html"/>
      <url>/posts/1ba7a976.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-07-18"><a href="#Date-2023-07-18" class="headerlink" title="- Date:2023-07-18"></a>- Date:2023-07-18</h1><ul><li>Time:19:32</li><li>Subject: none</li><li>Tags: #stm32 #定时器<br>[[2023-07]]</li></ul><hr><h2 id="软件定时原理"><a href="#软件定时原理" class="headerlink" title="软件定时原理"></a>软件定时原理</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938046.png" alt="Pasted image 20230718193416|500"></p><h2 id="定时器定时原理"><a href="#定时器定时原理" class="headerlink" title="定时器定时原理"></a>定时器定时原理</h2><p>定时器核心就是计数器<br>使用精准的时基，通过硬件的方式，实现定时功能<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938047.png" alt="Pasted image 20230718193624|500"></p><h2 id="STM32定时器分类"><a href="#STM32定时器分类" class="headerlink" title="STM32定时器分类"></a>STM32定时器分类</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938048.png" alt="Pasted image 20230718193851|500"></p><h2 id="定时器特性表"><a href="#定时器特性表" class="headerlink" title="定时器特性表"></a>定时器特性表</h2><h3 id="F1"><a href="#F1" class="headerlink" title="F1"></a>F1</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938049.png" alt="Pasted image 20230718193908|500"><br>8个定时器，可以计数0-65535数，</p><h2 id="STM32基本，通用，高级功能整体区"><a href="#STM32基本，通用，高级功能整体区" class="headerlink" title="STM32基本，通用，高级功能整体区"></a>STM32基本，通用，高级功能整体区</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938050.png" alt="Pasted image 20230718194641|500"></p><h2 id="Date-2023-07-18-1"><a href="#Date-2023-07-18-1" class="headerlink" title="- Date:2023-07-18"></a>- Date:2023-07-18</h2><ul><li>Time:19:47</li><li>Subject: none</li><li>Tags: #stm32 #定时器<br>[[2023-07]]</li></ul><hr><h2 id="基本定时器简介（了解）"><a href="#基本定时器简介（了解）" class="headerlink" title="基本定时器简介（了解）"></a>基本定时器简介（了解）</h2><ol><li>基本定时器 TIM6 TIM7</li><li>16位递增计数器（计数值：0~65535）</li><li>16位预分频器（分频系数：1~65536）<ol><li>因此设置为0的时候为1分频，1为2分频</li></ol></li><li>可用于触发DAC</li><li>在更新事件（计数器溢出）时，会产生中断/DMA请求<h2 id="基本定时器框图（熟悉）"><a href="#基本定时器框图（熟悉）" class="headerlink" title="基本定时器框图（熟悉）"></a>基本定时器框图（熟悉）</h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938042.png" alt="Pasted image 20230718195107|500"><br>经过psc得到计数器的工作频率，来一个时钟就加一<br>溢出条件，计数到影子寄存器里面的数字，psc和自动重转载寄存器都有影子，不能直接访问影子，但是起作用的就是影子，得产生一个事件的时候会把重装载值放到影子里面<br>u事件：update，更新事件，可以产生中断和mda（需要配置，默认不产生），默认产生更新事件，将预装载的寄存器值（psc，自动重装载寄存器）加载到影子，然后起作用<h2 id="定时器计数模式及溢出条件（熟悉）"><a href="#定时器计数模式及溢出条件（熟悉）" class="headerlink" title="定时器计数模式及溢出条件（熟悉）"></a>定时器计数模式及溢出条件（熟悉）</h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938043.png" alt="Pasted image 20230718205238|500"><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h3 id="递增模式"><a href="#递增模式" class="headerlink" title="递增模式"></a>递增模式</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938044.png" alt="Pasted image 20230718222029|500"><br>psc=1，arr=36<h3 id="递减模式"><a href="#递减模式" class="headerlink" title="递减模式"></a>递减模式</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938045.png" alt="Pasted image 20230718223659|500"><h3 id="中心对齐模式"><a href="#中心对齐模式" class="headerlink" title="中心对齐模式"></a>中心对齐模式</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938046.png" alt="Pasted image 20230718223715|500"><br>psc=0，arr=6<br>CNT=ARR-1=5、CNT=1<br>类似斯密特触发器的感觉<br>递增时溢出，上溢<br>递减时溢出，下溢<h2 id="定时器中断实验相关寄存器（了解）"><a href="#定时器中断实验相关寄存器（了解）" class="headerlink" title="定时器中断实验相关寄存器（了解）"></a>定时器中断实验相关寄存器（了解）</h2><h3 id="TIM6-和TIM7-控制寄存器-1-TIMx-CR1"><a href="#TIM6-和TIM7-控制寄存器-1-TIMx-CR1" class="headerlink" title="TIM6 和TIM7 控制寄存器 1(TIMx_CR1)"></a>TIM6 和TIM7 控制寄存器 1(TIMx_CR1)</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938047.png" alt="Pasted image 20230718233653|500"><br>没有缓存，直接就改（减少操作寄存器的误差，需要一些时间）<br>有缓存，当触发事件的时候才会更改<h3 id="TIM6-和TIM7-DMA-中断使能寄存器-TIMx-DIER"><a href="#TIM6-和TIM7-DMA-中断使能寄存器-TIMx-DIER" class="headerlink" title="TIM6 和TIM7 DMA/中断使能寄存器(TIMx_DIER)"></a>TIM6 和TIM7 DMA/中断使能寄存器(TIMx_DIER)</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938048.png" alt="Pasted image 20230718234437|500"><br>用于使能更新中断<h3 id="TIM6-和TIM7-状态寄存器-TIMx-SR"><a href="#TIM6-和TIM7-状态寄存器-TIMx-SR" class="headerlink" title="TIM6 和TIM7 状态寄存器(TIMx_SR)"></a>TIM6 和TIM7 状态寄存器(TIMx_SR)</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938049.png" alt="Pasted image 20230718234511|500"><br>用于判断是否发生了更新中断，由硬件置1，软件清零<h3 id="TIM6-和TIM7-计数器-TIMx-CNT"><a href="#TIM6-和TIM7-计数器-TIMx-CNT" class="headerlink" title="TIM6 和TIM7 计数器(TIMx_CNT)"></a>TIM6 和TIM7 计数器(TIMx_CNT)</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938050.png" alt="Pasted image 20230718234535|500"><br>计数器实时数值，可用于设置计时器初始值，范围：0~65535<h3 id="TIM6-和TIM7-预分频器-TIMx-PSC"><a href="#TIM6-和TIM7-预分频器-TIMx-PSC" class="headerlink" title="TIM6 和TIM7 预分频器(TIMx_PSC)"></a>TIM6 和TIM7 预分频器(TIMx_PSC)</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938051.png" alt="Pasted image 20230718234555|500"><br>用于设置预分频系数，范围：0~65535，实际预分频系数等于PSC+1<h3 id="TIM6-和TIM7-自动重装载寄存器-TIMx-ARR"><a href="#TIM6-和TIM7-自动重装载寄存器-TIMx-ARR" class="headerlink" title="TIM6 和TIM7 自动重装载寄存器(TIMx_ARR)"></a>TIM6 和TIM7 自动重装载寄存器(TIMx_ARR)</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938052.png" alt="Pasted image 20230718234613|500"><br>用于设置自动重装载值，范围：0~65535<h2 id="定时器溢出时间计算方法（掌握）"><a href="#定时器溢出时间计算方法（掌握）" class="headerlink" title=" 定时器溢出时间计算方法（掌握）"></a><font color="#ff0000"> 定时器溢出时间计算方法（掌握）</font></h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938053.png" alt="Pasted image 20230718234751|500"><br>T<sub>out</sub>是定时器溢出时间<br>F<sub>t</sub>是定时器的时钟源频率（未分频）<br>ARR是自动重装载寄存器的值<br>PSC是预分频器寄存器的值<h2 id="定时器中断实验配置步骤（掌握）"><a href="#定时器中断实验配置步骤（掌握）" class="headerlink" title="定时器中断实验配置步骤（掌握）"></a>定时器中断实验配置步骤（掌握）</h2><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1></li><li>配置定时器基础工作参数<ol><li>HAL_TIM_Base_Init()</li></ol></li><li>定时器基础MSP初始化<ol><li>HAL_TIM_Base_MspInit()     配置NVIC、CLOCK等</li></ol></li><li>使能更新中断并启动计数器<ol><li>HAL_TIM_Base_Start_IT()放在init里面</li></ol></li><li>设置优先级，使能中断（msp_init里面写）<ol><li>HAL_NVIC_SetPriority()、 HAL_NVIC_EnableIRQ()</li></ol></li><li>编写中断服务函数<ol><li>TIMx_IRQHandler()  (.s文件里面找到)等-&gt;HAL_TIM_IRQHandler()</li></ol></li><li>编写定时器更新中断回调函数<ol><li>HAL_TIM_PeriodElapsedCallback()（空函数，自己去重定义）<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938054.png" alt="Pasted image 20230719090532|500"><h3 id="关键结构体介绍"><a href="#关键结构体介绍" class="headerlink" title="关键结构体介绍"></a>关键结构体介绍</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TIM_TypeDef *Instance;            <span class="comment">/* 外设寄存器基地址 */</span></span><br><span class="line">    TIM_Base_InitTypeDef Init;     <span class="comment">/* 定时器初始化结构体*/</span></span><br><span class="line">     ...</span><br><span class="line">&#125;TIM_HandleTypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> Prescaler;                      <span class="comment">/* 预分频系数PSC */</span></span><br><span class="line">    <span class="type">uint32_t</span> CounterMode;             <span class="comment">/* 计数模式(基本定时器无效) */</span></span><br><span class="line">    <span class="type">uint32_t</span> Period;                           <span class="comment">/* 自动重载值 ARR */</span></span><br><span class="line">    <span class="type">uint32_t</span> ClockDivision;             <span class="comment">/* 时钟分频因子（基本定时器无效） */</span></span><br><span class="line">    <span class="type">uint32_t</span> RepetitionCounter;   <span class="comment">/* 重复计数器寄存器的值（高级才用用） */</span></span><br><span class="line">    <span class="type">uint32_t</span> AutoReloadPreload; <span class="comment">/* 自动重载预装载使能 */</span></span><br><span class="line">&#125; TIM_Base_InitTypeDef;</span><br></pre></td></tr></table></figure><h2 id="编程实战：定时器中断实验（掌握）"><a href="#编程实战：定时器中断实验（掌握）" class="headerlink" title="编程实战：定时器中断实验（掌握）"></a>编程实战：定时器中断实验（掌握）</h2></li></ol></li></ol><h1 id="Date-2023-07-19"><a href="#Date-2023-07-19" class="headerlink" title="- Date:2023-07-19"></a>- Date:2023-07-19</h1><ul><li>Time:10:06</li><li>Subject: none</li><li>Tags: #stm32#定时器<br>[[2023-07]]</li></ul><hr><h2 id="通用定时器简介"><a href="#通用定时器简介" class="headerlink" title="通用定时器简介"></a>通用定时器简介</h2><ol><li>TIM2/TIM3 /TIM4 /TIM5</li><li>特性<ol><li>16位递增、递减、中 心对齐计数器（计数值：0~65535）</li><li>16位预分频器（分频系数：1~65536）</li><li>可用于触发DAC、ADC</li><li>在更新事件、触发事件、输入捕获、输出比较时，会产生中断/DMA请求</li><li>4个独立通道，可用于：输入捕获、输出比较、输出PWM、单脉冲模式</li><li>使用外部信号控制定时器且可实现多个定时器互连的同步电路（级联）</li><li>支持编码器和霍尔传感器电路等</li></ol></li><li><h2 id="通用定时器框图"><a href="#通用定时器框图" class="headerlink" title="通用定时器框图"></a>通用定时器框图</h2><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938178.png" alt="Pasted image 20230719105107|500"><br>触发时可到itr0的地方作为其他时钟的时钟源（级联）<br>输入捕获可以用于测量脉冲时间<br>写入比较值，计数器的值和影子的比较后，产生比较事件occ1l（也会有比较中断）<br>左右两边的ch通道是分时复用<h2 id="计数器时钟源"><a href="#计数器时钟源" class="headerlink" title="计数器时钟源"></a>计数器时钟源</h2><h1 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h1><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938179.png" alt="Pasted image 20230720095902|500"><br>通道一是双边沿检测，上升和下降沿都检测，检测两个<br>TI1FP1/2经过边沿检测器，只能选择上升或者下降的，记一个数<br>ITR用于级联，其他触发的事件进而作为时钟源<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938180.png" alt="Pasted image 20230720103046|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938181.png" alt="Pasted image 20230720103054|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938182.png" alt="Pasted image 20230720103103|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938183.png" alt="Pasted image 20230720103257|500"><h2 id="通用定时器PWM输出"><a href="#通用定时器PWM输出" class="headerlink" title="通用定时器PWM输出"></a>通用定时器PWM输出</h2><h1 id="pwm"><a href="#pwm" class="headerlink" title="pwm"></a>pwm</h1><h3 id="通用定时器输出比较部分框图介绍"><a href="#通用定时器输出比较部分框图介绍" class="headerlink" title="通用定时器输出比较部分框图介绍"></a>通用定时器输出比较部分框图介绍</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938184.png" alt="Pasted image 20230720111001|500"><h4 id="捕获-比较通道1的主电路—-输出部分"><a href="#捕获-比较通道1的主电路—-输出部分" class="headerlink" title="捕获/比较通道1的主电路—-输出部分"></a>捕获/比较通道1的主电路—-输出部分</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938185.png" alt="Pasted image 20230720111039|500"><h4 id="捕获-比较通道的输出部分（通道1）"><a href="#捕获-比较通道的输出部分（通道1）" class="headerlink" title="捕获/比较通道的输出部分（通道1）"></a>捕获/比较通道的输出部分（通道1）</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938186.png" alt="Pasted image 20230720111101|500"><br>不同的通道，可以输出不同占空比的pwm波，可以配置某个io口为通道1/2/3/4的输出输入口，从而达到效果<h3 id="通用定时器输出PWM原理"><a href="#通用定时器输出PWM原理" class="headerlink" title="通用定时器输出PWM原理"></a>通用定时器输出PWM原理</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938187.png" alt="Pasted image 20230720111133|500"><br>假设：递增计数模式<br>ARR：自动重装载寄存器的值<br>CCRx：捕获/比较寄存器x的值<br>当CNT &lt; CCRx，IO输出0<br>当CNT &gt;= CCRx，IO输出1<br><font color="#ff0000">PWM波周期或频率由ARR决定，PWM波占空比由CCRx决定</font><h3 id="PWM模式"><a href="#PWM模式" class="headerlink" title="PWM模式"></a>PWM模式</h3><h4 id="PWM模式1"><a href="#PWM模式1" class="headerlink" title="PWM模式1"></a>PWM模式1</h4>递增：CNT &lt; CCRx，输出有效电平<pre><code>   CNT &gt;= CCRx，输出无效电平</code></pre>递减：CNT &gt; CCRx，输出无效电平<pre><code>   CNT &lt;= CCRx，输出有效电平</code></pre><h4 id="PWM模式2"><a href="#PWM模式2" class="headerlink" title="PWM模式2"></a>PWM模式2</h4>递增：CNT &lt; CCRx，输出无效电平<pre><code>   CNT &gt;= CCRx，输出有效电平</code></pre>递减：CNT &gt; CCRx，输出有效电平<pre><code>   CNT &lt;= CCRx，输出无效电平</code></pre><font color="#ff0000">注：有/无效状态由TIMx_CCER决定</font><br>CCxP=0：OCx高电平有效（默认）<br>CCxP=1：Ocx低电平有效<h4 id="坐标图"><a href="#坐标图" class="headerlink" title="坐标图"></a>坐标图</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938188.png" alt="Pasted image 20230720111824|500"><h3 id="通用定时器PWM输出实验配置步骤"><a href="#通用定时器PWM输出实验配置步骤" class="headerlink" title="通用定时器PWM输出实验配置步骤"></a>通用定时器PWM输出实验配置步骤</h3><h1 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h1></li><li>配置定时器基础工作参数，初始化函数内（自己定义一个函数，然后把下面的函数放里面）<ol><li>HAL_TIM_PWM_Init()</li></ol></li><li>定时器PWM输出MSP初始化<ol><li>HAL_TIM_PWM_MspInit()     配置NVIC、CLOCK、GPIO等</li></ol></li><li>配置PWM模式/比较值等（这个主要来看）在初始化函数里面写<ol><li>HAL_TIM_PWM_ConfigChannel()</li></ol></li><li>使能输出并启动计数器 在初始化函数里面写<ol><li>HAL_TIM_PWM_Start()</li></ol></li><li>修改比较值控制占空比(可选)<ol><li>__ HAL_TIM_SET_COMPARE()（宏）</li></ol></li><li>使能通道预装载(可选)<ol><li>__ HAL_TIM_ENABLE_OCxPRELOAD()（宏）<br>设置句柄，定义句柄钟的初始化结构体和基地址，看基本的定时器<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938189.png" alt="Pasted image 20230720112341|500"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">uint32_t</span> OCMode;     <span class="comment">/* 输出比较模式选择 8钟 */</span></span><br><span class="line">   <span class="type">uint32_t</span> Pulse;               <span class="comment">/* 设置比较值 CCRX */</span></span><br><span class="line">   <span class="type">uint32_t</span> OCPolarity;       <span class="comment">/* 设置输出比较极性 CCXP*/</span></span><br><span class="line">   <span class="type">uint32_t</span> OCNPolarity;    <span class="comment">/* 设置互补输出比较极性(高级定时器才有tim1 8) */</span></span><br><span class="line">   <span class="type">uint32_t</span> OCFastMode;   <span class="comment">/* 使能或失能输出比较快速模式（少用） */</span></span><br><span class="line">   <span class="type">uint32_t</span> OCIdleState;     <span class="comment">/* 空闲状态下OC1输出 （高级里的互补输出）*/</span></span><br><span class="line">   <span class="type">uint32_t</span> OCNIdleState;  <span class="comment">/* 空闲状态下OC1N输出 （高级里的互补输出） */</span></span><br><span class="line">&#125; TIM_OC_InitTypeDef;</span><br></pre></td></tr></table></figure><h2 id="通用定时器输入捕获实验"><a href="#通用定时器输入捕获实验" class="headerlink" title="通用定时器输入捕获实验"></a>通用定时器输入捕获实验</h2><h3 id="通用定时器输入捕获部分框图介绍（熟悉）"><a href="#通用定时器输入捕获部分框图介绍（熟悉）" class="headerlink" title="通用定时器输入捕获部分框图介绍（熟悉）"></a>通用定时器输入捕获部分框图介绍（熟悉）</h3><h4 id="捕获-比较通道的输入部分（通道1）"><a href="#捕获-比较通道的输入部分（通道1）" class="headerlink" title="捕获/比较通道的输入部分（通道1）"></a>捕获/比较通道的输入部分（通道1）</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938190.png" alt="Pasted image 20230722113040|500"><h4 id="捕获-比较通道1的主电路—-输入部分"><a href="#捕获-比较通道1的主电路—-输入部分" class="headerlink" title="捕获/比较通道1的主电路—-输入部分"></a>捕获/比较通道1的主电路—-输入部分</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938191.png" alt="Pasted image 20230722113108|500"><br>cc1g软件产生捕获<br>cc1e硬件检测捕获<h3 id="通用定时器输入捕获脉宽测量原理"><a href="#通用定时器输入捕获脉宽测量原理" class="headerlink" title="通用定时器输入捕获脉宽测量原理"></a>通用定时器输入捕获脉宽测量原理</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938192.png" alt="Pasted image 20230722113631|500"><br>以捕获测量高电平脉宽为例，纵坐标为计数器的值，横坐标事件<br>假设：递增计数模式<br>ARR：自动重装载寄存器的值<br>CCRx1：t1时间点CCRx的值（设置为上升沿，吧检测到的时间的计数存到ccrx，接着清零，然后设置下降沿检测）<br>CCRx2：t2时间点CCRx的值<br><font color="#ff0000">高电平期间，计时器计数的个数：N * (ARR+1) + CCRx2</font><br>先算出计数频率是F<sub>t</sub>/（psc+1）再取倒数为记一个数的时间，然后乘以上面的总个数即可<h3 id="通用定时器输入捕获实验配置步骤"><a href="#通用定时器输入捕获实验配置步骤" class="headerlink" title="通用定时器输入捕获实验配置步骤"></a>通用定时器输入捕获实验配置步骤</h3><h1 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h1></li></ol></li><li>配置定时器基础工作参数（在gtim_timx_cap_chy_init里，需要提前配置定时器句柄，外部设置<ol><li>HAL_TIM_IC_Init()</li></ol></li><li>定时器输入捕获MSP初始化（重定义HAL_TIM_IC_MspInit<ol><li>HAL_TIM_IC_MspInit()     配置NVIC、CLOCK、GPIO等</li></ol></li><li>配置输入通道映射、捕获边沿等（在gtim_timx_cap_chy_init里，在内设置ic通道句柄<ol><li>HAL_TIM_IC_ConfigChannel()</li></ol></li><li>设置优先级，使能中断（在msp里面<ol><li>HAL_NVIC_SetPriority()、 HAL_NVIC_EnableIRQ()</li></ol></li><li>使能定时器更新中断（宏）（在自己定义的gtim_timx_cap_chy_init里<ol><li>__ HAL_TIM_ENABLE_IT()</li></ol></li><li>使能捕获、捕获中断及计数器（在gtim_timx_cap_chy_init<ol><li>HAL_TIM_IC_Start_IT()</li></ol></li><li>编写中断服务函数（r如TIM5_IRQHandler（.s里面找），再把它define为GTIM_TIMX_CAP_IRQHandler<ol><li>TIMx_IRQHandler()等  -&gt; HAL_TIM_IRQHandler()</li></ol></li><li>编写更新中断和捕获回调函数（重新定义下面两个<ol><li>HAL_TIM_PeriodElapsedCallback() HAL_TIM_IC_CaptureCallback()<h4 id="相关HAL库函数介绍"><a href="#相关HAL库函数介绍" class="headerlink" title="相关HAL库函数介绍"></a>相关HAL库函数介绍</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938193.png" alt="Pasted image 20230722115254|500"><h4 id="关键结构体-HAL-TIM-IC-ConfigChannel"><a href="#关键结构体-HAL-TIM-IC-ConfigChannel" class="headerlink" title="关键结构体(HAL_TIM_IC_ConfigChannel)"></a>关键结构体(HAL_TIM_IC_ConfigChannel)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ICPolarity;    <span class="comment">/* 输入捕获触发方式选择，比如上升、下降沿捕获 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ICSelection; <span class="comment">/* 输入捕获选择，用于设置映射关系 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ICPrescaler; <span class="comment">/* 输入捕获分频系数(几次上升沿触发一次捕获事件) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ICFilter;         <span class="comment">/* 输入捕获滤波器设置 */</span></span><br><span class="line">&#125; TIM_IC_InitTypeDef;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-串口</title>
      <link href="/posts/7a29335c.html"/>
      <url>/posts/7a29335c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-06-13"><a href="#Date-2023-06-13" class="headerlink" title="- Date:2023-06-13"></a>- Date:2023-06-13</h1><ul><li>Time:14:38</li><li>Subject: none</li><li>Tags: #stm32 #通信<br>[[2023-06]]</li></ul><hr><h2 id="数据通信的基础概念"><a href="#数据通信的基础概念" class="headerlink" title="数据通信的基础概念"></a>数据通信的基础概念</h2><h3 id="串行-并行通信"><a href="#串行-并行通信" class="headerlink" title="串行/并行通信"></a>串行/并行通信</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937743.png" alt="Pasted image 20230613144010|500"></p><h3 id="单工-半双工-全双工通信"><a href="#单工-半双工-全双工通信" class="headerlink" title="单工/半双工/全双工通信"></a>单工/半双工/全双工通信</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937744.png" alt="Pasted image 20230613144034|500"></p><h3 id="同步-异步通信"><a href="#同步-异步通信" class="headerlink" title="同步/异步通信"></a>同步/异步通信</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937745.png" alt="Pasted image 20230613144049|500"></p><h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><ol><li>比特率：每秒钟传送的比特数，单位bit/s</li><li>波特率：每秒钟传送的码元数，单位Baud</li><li>比特率 = 波特率 * log2 M ，M表示每个码元承载的信息量</li><li>二进制系统中，波特率数值上等于比特率<h3 id="常见的串行通信接口"><a href="#常见的串行通信接口" class="headerlink" title="常见的串行通信接口"></a>常见的串行通信接口</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937746.png" alt="Pasted image 20230613144144|500"><h2 id="串口-RS-232"><a href="#串口-RS-232" class="headerlink" title="串口(RS-232)"></a>串口(RS-232)</h2><h1 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h1><h3 id="什么是串口"><a href="#什么是串口" class="headerlink" title="什么是串口"></a>什么是串口</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937747.png" alt="Pasted image 20230613144336|500"><h3 id="RS-232电平与COMS-TTL电平对比"><a href="#RS-232电平与COMS-TTL电平对比" class="headerlink" title="RS-232电平与COMS/TTL电平对比"></a>RS-232电平与COMS/TTL电平对比</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937748.png" alt="Pasted image 20230613144510|500"><h3 id="设备间的RS-232通信示意图"><a href="#设备间的RS-232通信示意图" class="headerlink" title="设备间的RS-232通信示意图"></a>设备间的RS-232通信示意图</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937749.png" alt="Pasted image 20230613144531|500"><h3 id="STM32串口与电脑USB口通信示意图"><a href="#STM32串口与电脑USB口通信示意图" class="headerlink" title="STM32串口与电脑USB口通信示意图"></a>STM32串口与电脑USB口通信示意图</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937750.png" alt="Pasted image 20230613144651|500"><h3 id="RS-232异步通信协议"><a href="#RS-232异步通信协议" class="headerlink" title="RS-232异步通信协议"></a>RS-232异步通信协议</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937751.png" alt="Pasted image 20230613144726|500"><br>lsb:最低有效位，位0<br>msb:最高有效位，位7<h2 id="STM32的USART"><a href="#STM32的USART" class="headerlink" title="STM32的USART"></a>STM32的USART</h2><h1 id="usart"><a href="#usart" class="headerlink" title="usart"></a>usart</h1><h3 id="STM32的USART简介"><a href="#STM32的USART简介" class="headerlink" title="STM32的USART简介"></a>STM32的USART简介</h3>Universal synchronous asynchronous receiver transmitter，通用同步异步收发器usart<br>Universal asynchronous receiver transmitter，通用异步收发器uart<br>USART/UART都可以与外部设备进行全双工异步通信<br>USART，我们常用的也是异步通信<h3 id="STM32的USART主要特征"><a href="#STM32的USART主要特征" class="headerlink" title="STM32的USART主要特征"></a>STM32的USART主要特征</h3></li><li>全双工异步通信</li><li>单线半双工通信</li><li>单独的发送器和接收器使能位</li><li>可配置使用DMA的多缓冲器通信</li><li>多个带标志的中断源<blockquote><p>参考：STM32xxxx参考手册（中文版）.pdf    USART相关章节</p><h3 id="如何快速查看STM32某个外设的数量及其对应的引脚"><a href="#如何快速查看STM32某个外设的数量及其对应的引脚" class="headerlink" title="如何快速查看STM32某个外设的数量及其对应的引脚?"></a>如何快速查看STM32某个外设的数量及其对应的引脚?</h3><p>参考：ST MCU 最新选型手册.pdf<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937752.png" alt="Pasted image 20230613145116|500"></p><h3 id="STM32F1-F4-F7的USART框图"><a href="#STM32F1-F4-F7的USART框图" class="headerlink" title="STM32F1/F4/F7的USART框图"></a>STM32F1/F4/F7的USART框图</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937753.png" alt="Pasted image 20230613145320|500"><br> 需要了解的点：<br>①，发送/接收数据的流程<br>②，相关寄存器作用<br>③，设置波特率</p><h3 id="STM32F1-F4-F7-H7的USART框图简化版"><a href="#STM32F1-F4-F7-H7的USART框图简化版" class="headerlink" title="STM32F1/F4/F7/H7的USART框图简化版"></a>STM32F1/F4/F7/H7的USART框图简化版</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937754.png" alt="Pasted image 20230613145804|500"></p><h3 id="设置USART-UART波特率（F1）"><a href="#设置USART-UART波特率（F1）" class="headerlink" title="设置USART/UART波特率（F1）"></a>设置USART/UART波特率（F1）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937755.png" alt="Pasted image 20230613151937|500"><br>波特率计算公式：baud=f<sub>ck</sub> /(16∗USARTDIV)，算出usartdiv就可以算出上面的div_mantissa(整数部分)，fraction就是小数部分，也可以算出来，然后写道寄存器里面去<br>其中”f<sub>ck</sub>“是串口的时钟，如：USART1的时钟是PCLK2,其他串口都是PCLK1（上图）</p><h3 id="如何使用寄存器操作的方式设置波特率-USART1为例"><a href="#如何使用寄存器操作的方式设置波特率-USART1为例" class="headerlink" title="如何使用寄存器操作的方式设置波特率 - USART1为例"></a>如何使用寄存器操作的方式设置波特率 - USART1为例</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937756.png" alt="Pasted image 20230615212901|500"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> mantissa;</span><br><span class="line"><span class="type">uint16_t</span> fraction;</span><br><span class="line">mantissa=<span class="number">39</span>;</span><br><span class="line">fraction=<span class="number">0.0625</span>*<span class="number">16</span>+<span class="number">0.5</span>=<span class="number">0x01</span>;          <span class="comment">/* USARTDIV = DIV_Mantissa + (DIV_Fraction/16) */</span></span><br><span class="line">USART1-&gt;BRR = (mantissa &lt;&lt; <span class="number">4</span>) + fraction;</span><br></pre></td></tr></table></figure><h3 id="波特率设置通用公式推演（F1）"><a href="#波特率设置通用公式推演（F1）" class="headerlink" title="波特率设置通用公式推演（F1）"></a>波特率设置通用公式推演（F1）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937757.png" alt="Pasted image 20230615213037|500"></p><h3 id="USART寄存器介绍（F1）可略"><a href="#USART寄存器介绍（F1）可略" class="headerlink" title="USART寄存器介绍（F1）可略"></a>USART寄存器介绍（F1）可略</h3><h4 id="控制寄存器1（CR1）"><a href="#控制寄存器1（CR1）" class="headerlink" title="控制寄存器1（CR1）"></a>控制寄存器1（CR1）</h4><p>该寄存器需要完成的配置：<br>位13：使能USART<br>位12：配置8个数据位<br>位10：禁止检验控制<br>位5：使能接收缓冲区非空中断<br>位3：使能发送<br>位2：使能接收</p><h4 id="控制寄存器2（CR2）"><a href="#控制寄存器2（CR2）" class="headerlink" title="控制寄存器2（CR2）"></a>控制寄存器2（CR2）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937758.png" alt="Pasted image 20230615213352|500"><br>该寄存器需要完成的配置：配置1个停止位</p><h4 id="控制寄存器3（CR3）"><a href="#控制寄存器3（CR3）" class="headerlink" title="控制寄存器3（CR3）"></a>控制寄存器3（CR3）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937759.png" alt="Pasted image 20230615213533|500"><br>该寄存器需要完成的配置：配置不选择半双工模式</p><h4 id="数据寄存器（DR）"><a href="#数据寄存器（DR）" class="headerlink" title="数据寄存器（DR）"></a>数据寄存器（DR）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937760.png" alt="Pasted image 20230615213555|500"><br>设置好控制和波特率寄存器后，往该寄存器写入数据即可发送，接收数据则读该寄存器</p><h4 id="状态寄存器（SR）"><a href="#状态寄存器（SR）" class="headerlink" title="状态寄存器（SR）"></a>状态寄存器（SR）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937761.png" alt="Pasted image 20230615213623|500"><br>根据TC位可以知道能否发数据，根据RXNE位知道是否收到数据</p><h3 id="需要配置的时序总结（需要查看进行配置）"><a href="#需要配置的时序总结（需要查看进行配置）" class="headerlink" title="需要配置的时序总结（需要查看进行配置）"></a>需要配置的时序总结（需要查看进行配置）</h3><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937762.png" alt="Pasted image 20230615213650|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937763.png" alt="Pasted image 20230615213658|500"></p><h3 id="HAL库外设初始化MSP回调机制（了解）"><a href="#HAL库外设初始化MSP回调机制（了解）" class="headerlink" title="HAL库外设初始化MSP回调机制（了解）"></a>HAL库外设初始化MSP回调机制（了解）</h3><h1 id="MSP"><a href="#MSP" class="headerlink" title="MSP"></a>MSP</h1><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937764.png" alt="Pasted image 20230615214018|500"></p><h4 id="HAL库外设初始化MSP回调机制-USART为例"><a href="#HAL库外设初始化MSP回调机制-USART为例" class="headerlink" title="HAL库外设初始化MSP回调机制- USART为例"></a>HAL库外设初始化MSP回调机制- USART为例</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937765.png" alt="Pasted image 20230615214206|500"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_MspInit</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef gpio_init_struct;</span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)                <span class="comment">/* 如果是串口1，进行串口1 MSP初始化 */</span></span><br><span class="line">    &#123;</span><br><span class="line">  <span class="comment">/* （1）使能USART1和对应IO时钟，（2）初始化IO，（3）使能USART1中断，设置优先级 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HAL库中断回调机制（了解）"><a href="#HAL库中断回调机制（了解）" class="headerlink" title="HAL库中断回调机制（了解）"></a>HAL库中断回调机制（了解）</h3><h1 id="IRQ"><a href="#IRQ" class="headerlink" title="IRQ"></a>IRQ</h1><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937766.png" alt="Pasted image 20230615214309|500"><br>中断服务函数在.s里面找到</p><h4 id="HAL库中断回调机制-USART为例（F1）"><a href="#HAL库中断回调机制-USART为例（F1）" class="headerlink" title="HAL库中断回调机制 - USART为例（F1）"></a>HAL库中断回调机制 - USART为例（F1）</h4><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937767.png" alt="Pasted image 20230615214329|500"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UART中断回调函数：</span><br><span class="line">HAL_UART_TxCpltCallback();                      <span class="comment">/* 发送完成回调函数 */</span></span><br><span class="line">HAL_UART_TxHalfCpltCallback();                  <span class="comment">/* 半发送完成回调函数 */</span></span><br><span class="line">HAL_UART_RxCpltCallback();                      <span class="comment">/* 接收完成回调函数（这个多用） */</span></span><br><span class="line">HAL_UART_RxHalfCpltCallback();                  <span class="comment">/* 半接收完成回调函数 */</span></span><br><span class="line">HAL_UART_ErrorCallback();                       <span class="comment">/* UART错误回调函数 */</span></span><br><span class="line">HAL_UART_AbortCpltCallback();                   <span class="comment">/* UART中止回调函数 */</span></span><br><span class="line">HAL_UART_AbortTransmitCpltCallback();           <span class="comment">/* UART发送中止回调函数 */</span></span><br><span class="line">HAL_UART_AbortReceiveCpltCallback();            <span class="comment">/* UART接收中止回调函数 */</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937768.png" alt="Pasted image 20230615214502|500"></p></blockquote></li></ol><h1 id="Date-2023-06-18"><a href="#Date-2023-06-18" class="headerlink" title="- Date:2023-06-18"></a>- Date:2023-06-18</h1><ul><li>Time:20:26</li><li>Subject: none</li><li>Tags: #stm32 #配置<br>[[2023-06]]</li></ul><hr><h2 id="USART-UART异步通信配置步骤（掌握）"><a href="#USART-UART异步通信配置步骤（掌握）" class="headerlink" title="USART/UART异步通信配置步骤（掌握）"></a>USART/UART异步通信配置步骤（掌握）</h2><ol><li>配置串口工作参数<ol><li>HAL_UART_Init()</li></ol></li><li>串口底层初始化<ol><li>HAL_UART_MspInit()    配置GPIO、NVIC、CLOCK等 <font color="#ff0000">上一个笔记里面有</font></li></ol></li><li>开启串口异步接收中断<ol><li>HAL_UART_Receive_IT()</li></ol></li><li>设置优先级，使能中断<ol><li>HAL_NVIC_SetPriority()、 HAL_NVIC_EnableIRQ()</li></ol></li><li>编写中断服务函数 <ol><li>USARTx_IRQHandler()、 UARTx_IRQHandler()</li></ol></li><li>串口数据发送<ol><li>USART_DR， HAL_UART_Transmit()<h3 id="HAL库相关函数介绍"><a href="#HAL库相关函数介绍" class="headerlink" title="HAL库相关函数介绍"></a>HAL库相关函数介绍</h3></li></ol></li><li>HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef * huart)<ol><li>handletypedef命名的是句柄<br>关键结构体（F1）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>    <span class="type">uint32_t</span> BaudRate;   <span class="comment">/* 波特率 */</span></span><br><span class="line">     <span class="type">uint32_t</span> WordLength;   <span class="comment">/* 字长 */</span></span><br><span class="line">     <span class="type">uint32_t</span> StopBits;   <span class="comment">/* 停止位 */</span></span><br><span class="line">     <span class="type">uint32_t</span> Parity;   <span class="comment">/* 奇偶校验位 */</span></span><br><span class="line">     <span class="type">uint32_t</span> Mode;   <span class="comment">/* UART 模式 */</span></span><br><span class="line">     <span class="type">uint32_t</span> HwFlowCtl;   <span class="comment">/* 硬件流设置 */</span></span><br><span class="line">     <span class="type">uint32_t</span> OverSampling;   <span class="comment">/* 过采样设置 */</span></span><br><span class="line">&#125;UART_InitTypeDef</span><br></pre></td></tr></table></figure></li></ol></li><li>HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef <em> huart , uint8_t </em> pData , uint16_t Size)<ol><li>作用：以中断的方式接收指定字节的数据</li><li>形参 1 是 UART_HandleTypeDef 结构体类型指针变量</li><li>形参 2 是指向接收数据缓冲区</li><li>形参 3 是要接收的数据大小，以字节为单位</li></ol></li><li>HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef <em> huart,  uint8_t </em> pData, uint16_t Size, uint32_t Timeout)<ol><li>作用：以阻塞的方式发送指定字节的数据(必须发送完才能接受，和上面有区别)</li><li>形参 1 ：UART_HandleTypeDef 结构体类型指针变量</li><li>形参 2：指向要发送的数据地址</li><li>形参 3：要发送的数据大小，以字节为单位</li><li>形参 4：设置的超时时间，以ms单位<h2 id="IO引脚复用功能（掌握）"><a href="#IO引脚复用功能（掌握）" class="headerlink" title="IO引脚复用功能（掌握）"></a>IO引脚复用功能（掌握）</h2><h1 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h1><h3 id="何为复用？"><a href="#何为复用？" class="headerlink" title="何为复用？"></a>何为复用？</h3></li></ol></li><li>通用：IO端口的输入或输出是由GPIO外设控制，我们称之为通用</li><li>复用：IO端口的输入或输出是由其它非GPIO外设控制，我们称之为复用<h3 id="STM32F1的IO引脚复用"><a href="#STM32F1的IO引脚复用" class="headerlink" title="STM32F1的IO引脚复用"></a>STM32F1的IO引脚复用</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938307.png" alt="Pasted image 20230618205358|500"><br>参考：STM32F103ZET6（中文版）.pdf     第3小节  引脚定义<h3 id="IO引脚复用映射示意图"><a href="#IO引脚复用映射示意图" class="headerlink" title="IO引脚复用映射示意图"></a>IO引脚复用映射示意图</h3><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938308.png" alt="Pasted image 20230618205911|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938309.png" alt="Pasted image 20230618205915|500"><br>温馨提示：IO引脚与AF(0~15)具体定义关系，需要参考对应的芯片数据手册<h4 id="GPIO-复用功能低位寄存器-AFRL"><a href="#GPIO-复用功能低位寄存器-AFRL" class="headerlink" title="GPIO 复用功能低位寄存器(AFRL)"></a>GPIO 复用功能低位寄存器(AFRL)</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938310.png" alt="Pasted image 20230618210110|500"><h4 id="GPIO-复用功能高位寄存器-AFRH"><a href="#GPIO-复用功能高位寄存器-AFRH" class="headerlink" title="GPIO 复用功能高位寄存器(AFRH)"></a>GPIO 复用功能高位寄存器(AFRH)</h4><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030938311.png" alt="Pasted image 20230618210120|500"><br>摘自：STM32F4xx参考手册_V4（中文版）.pdf，7.4.9节 7.4.10<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>51单片机知识归档</title>
      <link href="/posts/2e5210af.html"/>
      <url>/posts/2e5210af.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2023-05-22"><a href="#Date-2023-05-22" class="headerlink" title="- Date:2023-05-22"></a>- Date:2023-05-22</h1><ul><li>Time:22:17</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-05]]</li></ul><hr><h2 id="直流电机介绍"><a href="#直流电机介绍" class="headerlink" title="直流电机介绍"></a>直流电机介绍</h2><ol><li>直流电机是一种将电能转换为机械能的装置。一般的直流电机有两个电极，当电极正接时，电机正转，当电极反接时，电机反转</li><li>直流电机主要由永磁体（定子）、线圈（转子）和换向器组成</li><li>除直流电机外，常见的电机还有步进电机、舵机、无刷电机、空心杯电机等</li></ol><h2 id="电机驱动电路"><a href="#电机驱动电路" class="headerlink" title="电机驱动电路"></a>电机驱动电路</h2><ol><li>大功率直接驱动<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937135.png" alt="Pasted image 20230521222110|500"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937136.png" alt="Pasted image 20230521222117|500"></li></ol></li><li>H 桥驱动<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937137.png" alt="Pasted image 20230521222246|500"></li><li>可以正反转动</li></ol></li></ol><h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><ol><li>PWM（Pulse Width Modulation）即脉冲宽度调制，在具有惯性的系统中，可以通过对一系列<font color="#ff0000">脉冲的宽度进行调制</font>，来<font color="#ff0000">等效</font>地获得所需要的<font color="#ff0000">模拟参量</font>，常应用于电机控速、开关电源等领域</li><li>PWM 重要参数：<ol><li>频率 = 1 / TS            占空比 = TON（打开的时间） / TS（总时间）           精度 = 占空比变化步距（一格一格的调整，格子越小月细致）</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937138.png" alt="Pasted image 20230521222713|500"></li><li>紫线为等效的线</li></ol></li><li>产生 pwm 方法<ol><li>模型结构<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937139.png" alt="Pasted image 20230521224437|500"></li></ol></li><li>波形<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937140.png" alt="Pasted image 20230521224452|500"></li></ol></li></ol></li></ol><h1 id="Date-2023-04-29"><a href="#Date-2023-04-29" class="headerlink" title="- Date:2023-04-29"></a>- Date:2023-04-29</h1><ul><li>Time:12:52</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><p>51 自带 uart（Universal Asynchronous Receiver Transmitter，通用异步收发器）</p><h2 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准"></a>电平标准</h2><p>电平标准是数据 1 和数据 0 的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：<br>TTL 电平：+5V 表示 1，0V 表示 0<br>RS232 电平：-3~-15V 表示 1，+3~+15V 表示 0<br>RS485 电平：两线压差+2~+6V 表示 1，-2~-6V 表示 0（差分信号）</p><h2 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h2><ol><li>两端的设备的 TXD（发送）和 RXD（接受）交叉连接，单向可以一条，vcc，gnd 必须接</li><li>点平标准不一样的时候要加转换芯片</li></ol><h2 id="通信接口比较"><a href="#通信接口比较" class="headerlink" title="通信接口比较"></a>通信接口比较</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030934282.png" alt="Pasted image 20230429110126|500"></li></ol><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>全双工：通信双方可以在同一时刻互相传输数据<br>半双工：通信双方可以互相传输数据，但必须分时复用一根数据线<br>单工：通信只能有一方发送到另一方，不能反向传输<br>异步：通信双方各自约定通信速率<br>同步：通信双方靠一根时钟线来约定通信速率，有时钟线<br>总线：连接各个设备的数据传输线路（类似于一条马路，把路边各住户连接起来，使住户可以相互交流）</p><h2 id="51-单片机的-uart"><a href="#51-单片机的-uart" class="headerlink" title="51 单片机的 uart"></a>51 单片机的 uart</h2><ol><li>我们的低端单片机只能一个</li><li>四个工作模式<ol><li>模式 0：同步移位寄存器</li><li>模式 1：8 位 UART，波特率可变（常用）</li><li>模式 2：9 位 UART，波特率固定</li><li>模式 3：9 位 UART，波特率可变</li></ol></li><li><strong>串口模式图</strong><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030934283.png" alt="Pasted image 20230429124914|400"></li><li>SBUF：串口数据缓存寄存器，物理上是两个独立的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器，读操作时，读出的是接收寄存器</li></ol></li><li><strong>相关寄存器</strong><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030934284.png" alt="Pasted image 20230429125026|400"></li></ol></li></ol><h1 id="Date-2023-04-29-1"><a href="#Date-2023-04-29-1" class="headerlink" title="- Date:2023-04-29"></a>- Date:2023-04-29</h1><ul><li>Time:12:52</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单片机，英文 Micro Controller Unit，简称 MCU<br>里面有电脑的各个组成部分，有 CPU、RAM、ROM、定时器、中断系统、通讯接口，可以构成一个计算机系统，一个袖珍计算机，但是它小，功能实现比较完整<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937223.png" alt="Pasted image 20230423211439|500"><br>其可以完成的任务：信息采集（依靠传感器）、处理（依靠 CPU）和硬件设备（例如电机，LED 等）的控制，在我们比赛的时候处处都快体现（如机械臂，麦克纳姆轮）<br>我当前学的用的是 51 单片机，也就是 stc51 单片机，stc 是公司，<br>stm32 单片机 比赛用的</p><h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h2><ol><li>LED 灯</li><li>引脚 P1_0 P1 gnd vcc 对应有功能</li><li>串口 与电脑进行通讯，电脑也参与到工作来</li><li>定时器，用于计时系统，隔一段时间进行操作<ol><li>中断系统：为了应急事件设计的，先处理应急的，暂停其他的，再回来</li><li>寄存器：连接软硬件的媒介，单片机的放在 ram，然后 ram 后面接着导线，寄存器相当于一个复杂机器的“操作按钮”，软件上设置了，实际的硬件电路能发生相应的功能</li></ol></li><li>keil4 keil5 用来写代码的平台</li><li>c 语言，单片机的程序语言</li></ol><h1 id="Date-2023-04-29-2"><a href="#Date-2023-04-29-2" class="headerlink" title="- Date:2023-04-29"></a>- Date:2023-04-29</h1><ul><li>Time:12:51</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><h2 id="定时器框架"><a href="#定时器框架" class="headerlink" title="定时器框架"></a>定时器框架</h2><p>时钟（提供计数单元的时钟脉冲）-&gt; 计数单元（时钟计数）-&gt;中断系统（产生中断，执行定时任务）</p><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><ol><li>模式 0：13 位定时器<br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937963.png" alt="Pasted image 20230423155323|500"><br>相当于一个计数器</li><li>模式 1：16 位定时器/计数器（常用）<ol><li>sysclk ：系统时钟，也就是晶振周期，</li><li>12T 12 分频，1 微秒，这样记一次数</li><li>6T 类似</li><li>C/T=0 count 选择上下的模式</li></ol></li></ol><h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><ol><li>发生紧急事情，先暂停其他处理紧急，然后再回去，cpu 优先相依那个中断源请求问题，所以中断源就有优先级别</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937964.png" alt="Pasted image 20230423161243|500"></li><li>相当于可以同时进行两个任务（断点）</li></ol><h2 id="定时器相关寄存器"><a href="#定时器相关寄存器" class="headerlink" title="定时器相关寄存器"></a>定时器相关寄存器</h2><ol><li>定时器/计数器 0 和 1 的相关寄存器<ol><li>特殊的 ram 存储器，每个寄存器连着导线，控制电路连接的方式</li><li>可位寻址，可以单独设置；</li><li>不可位寻址，统一设置；</li></ol></li></ol><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937965.png" alt="Pasted image 20230521224952|500"></p><h2 id="驱动电路"><a href="#驱动电路" class="headerlink" title="驱动电路"></a>驱动电路</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937553.png" alt="Pasted image 20230501103127|500"></li></ol><h2 id="ULN2003"><a href="#ULN2003" class="headerlink" title="ULN2003"></a>ULN2003</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937554.png" alt="Pasted image 20230501103255|500"></li><li>增大驱动能力</li><li>与门 或门 非门 ，如下：<img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937555.png" alt="Pasted image 20230501103511|500"></li></ol><h2 id="乐理部分"><a href="#乐理部分" class="headerlink" title="乐理部分"></a>乐理部分</h2><h1 id="Date-2023-05-18"><a href="#Date-2023-05-18" class="headerlink" title="- Date:2023-05-18"></a>- Date:2023-05-18</h1><ul><li>Time:23:53</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-05]]</li></ul><hr><h2 id="AT24C02"><a href="#AT24C02" class="headerlink" title="AT24C02"></a>AT24C02</h2><ol><li>AT24C02 是一种可以实现掉电不丢失的存储器，可用于保存单片机运行时想要永久保存的数据信息</li><li>存储介质：E2PROM</li></ol><h2 id="内部结构框图"><a href="#内部结构框图" class="headerlink" title="内部结构框图"></a>内部结构框图</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937651.png" alt="Pasted image 20230519000430|500"></p><ol><li>eeprom 的左边 x DEC 就是 decoder 编码器；下面就是输出端；上面用于擦除</li><li>data word 地址寄存器</li></ol><h2 id="I2C-总线（i-方-c）"><a href="#I2C-总线（i-方-c）" class="headerlink" title="I2C 总线（i 方 c）"></a>I2C 总线（i 方 c）</h2><ol><li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）半双工通信</li><li>同步 半双工 带数据应答</li><li>通用的 I2C 总线，可以使各种设备的通信标准统一</li><li>I2C 总线（Inter IC BUS）是由 Philips 公司开发的一种通用数据总线</li></ol><h2 id="I2C-电路规范"><a href="#I2C-电路规范" class="headerlink" title="I2C 电路规范"></a>I2C 电路规范</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937652.png" alt="Pasted image 20230519224809|500"></li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937653.png" alt="Pasted image 20230519224814|500"></li><li>所有 I2C 设备的 SCL 连在一起，SDA 连在一起</li><li>设备的 SCL 和 SDA 均要配置成开漏输出模式</li><li>SCL 和 SDA 各添加一个上拉电阻，阻值一般为 4.7KΩ 左右</li><li>开漏输出和上拉电阻的共同作用实现了“线与”的功能，<font color="#ff0000">此设计主要是为了解决多机通信互相干扰的问题</font></li></ol><h2 id="I2C-时序结构"><a href="#I2C-时序结构" class="headerlink" title="I2C 时序结构"></a>I2C 时序结构</h2><ol><li>起始条件：<font color="#ff0000">SCL 高电平期间，SDA 从高电平切换到低电平</font><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937654.png" alt="Pasted image 20230519230113|500"></li></ol></li><li>终止条件：<font color="#ff0000">SCL 高电平期间，SDA 从低电平切换到高电平</font><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937655.png" alt="Pasted image 20230519230123|500"></li></ol></li><li>发送一个字节：SCL 低电平期间，<font color="#ff0000">主机</font>将数据位依次放到 SDA 线上（高位在前），然后拉高 SCL，从机将在 SCL 高电平期间读取数据位(读取 b7 下面的两个脉冲)，所以 SCL 高电平期间 SDA 不允许有数据变化（方框内的下面两个脉冲得保持不变），依次循环上述过程 8 次(b7-b0)，即可发送一个字节<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937656.png" alt="Pasted image 20230519230412|500"></li></ol></li><li>接收一个字节：SCL 低电平期间，<font color="#ff0000">从机</font>将数据位依次放到 SDA 线上（高位在前），然后拉高 SCL，<font color="#ff0000">主机将在 SCL 高电平期间读取数据位</font>，所以 SCL 高电平期间 SDA 不允许有数据变化，依次循环上述过程 8 次，即可接收一个字节（主机在接收之前，需要释放 SDA，把控制权交给从机）紫色是从机控制的时候<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937657.png" alt="Pasted image 20230519233248|500"></li></ol></li><li>发送应答(SA)：在接收完一个字节之后，主机在下一个时钟发送一位数据，<font color="#ff0000">数据 0 表示应答，数据 1 表示非应答</font>（ACK 就是应答）</li><li>接收应答(RA)：在发送完一个字节之后，主机在下一个时钟接收一位数据，判断从机是否应答，<font color="#ff0000">数据 0 表示应答，数据 1 表示非应答</font>（主机在接收之前，需要<font color="#ff0000">释放 SDA，也就是 sda 置高电平，控制权交给从机</font>）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937658.png" alt="Pasted image 20230519233803|500"></li></ol></li></ol><h2 id="I2C-数据帧"><a href="#I2C-数据帧" class="headerlink" title="I2C 数据帧"></a>I2C 数据帧</h2><ol><li>发送一帧数据<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937659.png" alt="Pasted image 20230519234146|500"></li><li>a6-3 在这个芯片规定为 1010 无法改变（相当于身份）后三位可以见到在原理图，都是接地的，为 0，最后一位决定功能，带横线接 gnd 起作用</li><li><font color="#ff0000">向谁发什么</font></li></ol></li><li>接受一帧数据<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937660.png" alt="Pasted image 20230519235731|500"></li><li><font color="#ff0000">向谁收什么</font></li></ol></li><li>先发送再接收数据帧（复合格式）<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937661.png" alt="Pasted image 20230519235841|500"></li><li>先说（发）再收取数据，对于传感器来说不必要，但是对于其他的，主机给了什么指令，就让从机回复些什么东西；实现的是 <font color="#ff0000">向谁收指定的什么</font></li></ol></li><li>字节写<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937662.png" alt="Pasted image 20230520000310|500"></li><li>在 WORD ADDRESS（字地址）处写入数据 DATA</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937663.png" alt="Pasted image 20230520000838|500"></li><li>手册上的时序，可以参照思考对照一下，下面也是</li></ol></li><li>随机读<ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937664.png" alt="Pasted image 20230520000337|500"></li><li>读出在 WORD ADDRESS 处的数据 DATA</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937665.png" alt="Pasted image 20230520000827|500"></li></ol></li><li><font color="#ff0000">注</font>：AT24C02 的固定地址为 1010，可配置地址本开发板上为 000（原理图中的 a0-a2），所以 SLAVE ADDRESS+W 为 0xA0 (Write 接地起作用)，SLAVE ADDRESS+R 为 0xA1（Read 接高电平起作用）</li></ol><h1 id="Date-2023-04-29-3"><a href="#Date-2023-04-29-3" class="headerlink" title="- Date:2023-04-29"></a>- Date:2023-04-29</h1><ul><li>Time:17:43</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><p>RTC(Real Time Clock)：实时时钟，是一种集成电路，通常称为时钟芯片</p><h2 id="电路-1"><a href="#电路-1" class="headerlink" title="电路"></a>电路</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937877.png" alt="Pasted image 20230429203500|500"><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937878.png" alt="Pasted image 20230429203524|500"></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937879.png" alt="Pasted image 20230429204346|500"></p><ol><li>前两列命令字的结果，命令是什么，就是上面<font color="#ff0000">对</font><font color="#ff0000">应</font>的功能</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937880.png" alt="Pasted image 20230429205534|500"></li></ol><h2 id="时序定义"><a href="#时序定义" class="headerlink" title="时序定义"></a>时序定义</h2><ol><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937881.png" alt="Pasted image 20230429210957|500"></li><li>第一位读取 write 还是 read，要是 read，则就把后面的那一段作为读取，从时钟芯片读取，write 就是下面的第二段，把它写入到里面去</li><li>一个时钟周期是一系列的上升沿伴随下降沿.要输入数据在时钟的上升沿数据必须有效，而 且在下降沿要输出数据位.如果 CE 输入为低电平,则所有数据传输终止,并且 I/O 口成高阻 抗状态.图 4 显示了数据传输. 在上电时, CE 必须为逻辑 0 直到 VCC 大于 2v，同样，SCLK 必须为逻辑 0 当 CE 变成逻辑 1 状态.</li></ol><h2 id="bcd-码"><a href="#bcd-码" class="headerlink" title="bcd 码"></a>bcd 码</h2><ol><li>用 4 位二进制数来表示 1 位十进制数</li><li>BCD 码转十进制：DEC=BCD/16 * 10+BCD%16; （2 位 BCD）</li><li>十进制转 BCD 码：BCD=DEC/10 * 16+DEC%10; （2 位 BCD）</li><li>在十六进制中的体现：0x13 表示 13，0x85 表示 85，0x1A 不合法</li></ol><h1 id="Date-2023-04-29-4"><a href="#Date-2023-04-29-4" class="headerlink" title="- Date:2023-04-29"></a>- Date:2023-04-29</h1><ul><li>Time:14:34</li><li>Subject: 自动化</li><li>Tags: #51 单片机<br>[[2023-04]]</li></ul><hr><ol><li><strong>显示原理</strong><br><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937218.png" alt="Pasted image 20230429143429|500"></li></ol><h2 id="74HC595"><a href="#74HC595" class="headerlink" title="74HC595"></a>74HC595</h2><ol><li>74HC595 是串行输入并行输出的移位寄存器，可用 3 根线输入串行数据，8 根线输出并行数据，多片级联后，可输出 16 位、24 位、32 位等，常用于 IO 口扩展。</li><li><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937219.png" alt="Pasted image 20230429145026|500"></li><li>SER: 输入数据，serclk：移动位置，一层层往下，上面补充</li><li>先最上面 1 下一格子，然后最上面 0，现在 1 在第二行，然后两个再下沿，补第一层</li><li>qh‘ 放到下一个芯片的寄存器里面（当 8 位满了之后）</li><li>低电平工作</li></ol><h2 id="srf-sbit"><a href="#srf-sbit" class="headerlink" title="srf sbit"></a>srf sbit</h2><ol><li>sfr（special function register）：<ol><li>特殊功能寄存器声明 例：sfr P0 = 0x80; <font color="#ff0000">声明 P0 口寄存器，物理地址为 0x80</font></li></ol></li><li>sbit（special bit）： 2. 特殊位声明例：sbit P0_1 = 0x81;    或     sbit P0_1 = P0^1; <font color="#ff0000"> 声明 P0 寄存器的第 1 位</font></li><li>可位寻址/不可位寻址：在单片机系统中，操作任意寄存器或者某一位的数据时，必须给出其物理地址，又因为一个寄存器里有 8 位，所以位的数量是寄存器数量的 8 倍，单片机无法对所有位进行编码，故每 8 个寄存器中，只有一个是可以位寻址的。对不可位寻址的寄存器，若要只操作其中一位而不影响其它位时，可用“&amp;=”、“|=”、“^=”的方法进行位操作</li></ol><h2 id="代码习惯"><a href="#代码习惯" class="headerlink" title="代码习惯"></a>代码习惯</h2><ol><li>函数和变量命名建议小写开头，结构体建议大写开头，常量建议全大写</li></ol><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><img src="https://pic-chris.oss-cn-guangzhou.aliyuncs.com/img/202407030937220.png" alt="Pasted image 20230429175356|500"></p><ol><li>首先要知道这个: <strong>加横线一般表示这个接口低电平工作</strong></li><li>OE:<br>open enable 直译(打开使能)<br>说人话(打开此芯片的开关)<br>带上横线的意思用人话说就是(输入低电平这个芯片才能工作)</li><li>SRCLR:<br>serial clear 直译(连续清零/串行清零)<br>说人话(这个芯片数据清空)<br>带上横线的意思用人话说就是(输入低电平这个芯片里面的数据清空)<br>所以说你要用的话得接个高电平才能工作(毕竟你不能让芯片一直清空你准备的数据信号是不是)</li><li>SER: serial 直译(连续/串行)<br>说人话解释(这个接口就是商场大门,排成一条长队的数据就从这个接口进)<br>这个接数据输入的 IO 口</li><li>SRCLK : serial clock 直译(连续时钟/串行时钟)<br>说人话解释(这个就是可以通行的绿色标志,数据从 SER 口排着队,这里大喊一声(具体操作就是给他一个高点平),贵客一位! 然后数据就从这里进一位)<br>感觉和水龙头也挺像的,开一下关一下,水和数据似得.打开走一点,打开走一点,打开走一点…<br>要用的话就是 给高电平一下 走一个位(bit) 给高电平一下走一个位(bit)</li><li>RCLK: receive clock 直译(接收时钟)<br>说人话解释(连着上面的说了啊,一个一个顾客进来凑够了一桌子 8 个人,不能让他们站着啊,你得让他们坐下来,这个就是请坐,你们一块坐下吧)<br>诶,这就输出了这个接口就是把当前的 8 个位,一块儿给输出的 要用的话就是给 给高电平一下,输出存的那几个位</li><li>QA-QH:<br>就是桌子旁边的座位,这是输出口 最后进来的位在最前面 QA 座位 第二个进来位在第二个 QB 座位</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一章英语阅读原文（更新中）</title>
      <link href="/posts/29eadd43.html"/>
      <url>/posts/29eadd43.html</url>
      
        <content type="html"><![CDATA[<h1 id="The-best-bosses-know-how-to-subtract-work"><a href="#The-best-bosses-know-how-to-subtract-work" class="headerlink" title="The best bosses know how to subtract work"></a><strong>The best bosses know how to subtract work</strong></h1><hr><ul><li>Start Time: 13:02</li><li>End Time: 15:02</li><li>[[第一章英语阅读原文#<strong>The best bosses know how to subtract work</strong>|note]]<br>Companies are used to celebrating addition. Profits, customers and share prices should go up rather than fall. Innovation is the adding of new products. Larger numbers are a measure of career success: managers climb the corporate ladder by taking on more reports, running <strong>heftier</strong> budgets and <strong>trousering</strong> bigger salaries.</li></ul><p>Genuine superstars don’t just add. They multiply. The best software programmers are tagged as “10x developers”, for <strong>supposedly</strong> being ten times more productive than their peers.</p><p>Firms are not always opposed to subtraction. There are good kinds of cuts: carbon emissions, most obviously. Reducing costs is a necessary part of management, though not a welcome one. But the value of doing less is underestimated. <em>The best bosses are those who take things away as well as add them on.</em></p><p>That means clearing time for employees to get work done. Meetings are almost always called by bosses. Some are useful; many of them have all the <strong>pizzazz</strong> and impact of a speed-awareness course.</p><p><strong>Shopify</strong>, an e-commerce firm, began the year by deleting 12,000 <strong>recurring</strong> meetings from corporate calendars, and asking everyone to think carefully before <strong>reinstating</strong> them. The company reports a rise in productivity as a result of the <strong>cull</strong>.</p><p>The only thing worse than having too many meetings is not being invited to them at all. So whenever meetings do take place, surprisingly large numbers of people can <strong>turn up</strong>. Minus-minded managers will give employees permission not to attend if they are not needed.</p><p><strong>By the same token</strong>, good bosses will send messages when necessary, not every time a bright idea <strong>pops into</strong> their head. They will reduce the tempo of work, by leaving employees time to concentrate. They will be clear if something is urgent or not.</p><p>A recent study by Laura Giurge of London Business School and Vanessa Bohns of Cornell University found that receivers of an email routinely overestimate how quickly its sender expects a reply.</p><p>Subtraction is not just about removing day-to-day distractions. It’s also about taking decisions to kill off projects and products that are going nowhere, and to <strong>focus efforts on the most important bits of</strong> the business.</p><p>Peter Drucker, the <strong>doyen</strong> of management theorists, was an <strong>advocate</strong> of “planned abandonment”, so that resources that <strong>are tied up in marginal activities</strong> <strong>are freed for</strong> more profitable use. <strong>Executives</strong> should, he advised, <strong>routinely</strong> ask the same question of every aspect of the business: “If we did not do this already, would we go into it now knowing what we now know?”</p><p>In “The Case for Good Jobs”, a new book, Zeynep Ton of MIT Sloan School of Management argues that doing less can often make commercial sense. Costco, a <strong>well-regarded</strong> American <strong>retailer</strong> that believes in the “intelligent loss of sales”, has a deliberately limited product range. That means it can focus its buying power more effectively, forecast demand more <strong>accurately</strong> and use its employees’ time more productively.</p><p>Less may not sound like a great outcome for customers, but at some point choice is deeply <strong>wearying</strong>. <em>When you have spent more time trying to decide what to watch on a streaming service than it takes to go to the cinema and watch “Oppenheimer” twice, scarcity</em> <strong>seems pretty attractive</strong>.</p><h1 id="Research-Few-Corporate-Spinoffs-Deliver-Value"><a href="#Research-Few-Corporate-Spinoffs-Deliver-Value" class="headerlink" title="Research: Few Corporate Spinoffs Deliver Value"></a><strong>Research: Few Corporate Spinoffs Deliver Value</strong></h1><hr><ul><li>Start Time: 14:28</li><li>End Time: 14:51<br>[[第一章笔记英语阅读笔记#<strong>Research Few Corporate Spinoffs Deliver Value</strong>|note]]<br>Barely a month goes by without a major company announcing that it is breaking up its business into <strong>spun-out</strong> public companies. Kellogg, GSK, Johnson &amp; Johnson, General Electric, and IBM all recently made such announcements. While it is too soon to predict the effectiveness of any single recently announced deal, this intensified focus on separations raises some critical questions about the value created from a spin-off. What is it that these companies are hoping to achieve? What challenges will they face? How will they create <strong>shareholder</strong> value in light of these challenges?</li></ul><p>We analyzed more than 350 public <strong>spin-offs</strong> valued at greater than $1 billion between 2000 and 2020. The most unexpected thing we learned was that 50% of companies pursuing a separation fail to create any new shareholder value two years down the road, and 25% destroy a significant amount of shareholder value in the process. This happens despite their stated <strong>intentions</strong> to create value through greater management focus, additional growth opportunities, targeted capital allocation, and investment profiles that match a more specific investor base.</p><p>The evidence is <strong>overwhelming</strong>. Among the companies in our study, the average separation delivered as little as a 5% increase in combined market cap two years after spinning off. The range of performance was significant. Companies in the bottom <strong>quartile</strong> completed separations that actually destroyed value by as much as 50% of the combined market cap.</p><p>At the same time, while most companies saw little for their efforts, top-quartile separations performed exceptionally well, with 75% higher combined market cap two years after the separation. Think of the experience of industrial company Arconic, which spun off Howmet Aerospace in April 2020. Fifteen months later the combined market cap of both companies had <strong>risen by</strong> more than 150%. Or consider Baxter’s spin-off of Baxalta in 2015, in which combined market cap rose by 30% in one year before Baxalta was acquired by Shire.</p><p>The huge <strong>disparity</strong> in performance between winners and losers led us to focus our research on what leading companies do that results in such dramatic outperformance—as well as on the <strong>missteps</strong> that <strong>trip up</strong> other companies.</p><p>What we see is that many companies <strong>doom</strong> their separations from the start with a faulty <strong>premise</strong>. They assume the mere act of spinning off a business is sufficient to achieve a higher multiple, and <em>they define success <strong>shortsightedly</strong> as getting to day one as fast as possible</em>. In fact, investors know there are sometimes significant dis-synergies and one-time costs from breaking up. They want to see that the profit-and-loss (P&amp;L) shape, operating model, and growth <strong>trajectory</strong> of one or both entities are great enough to <strong>offset</strong> those costs and sufficiently different enough from past performance to <strong>warrant</strong> a higher multiple.</p><p>Some companies already run separate operations, with no shared functions and systems, and can break apart easily and relatively quickly. Most companies, however, face a high level of <strong>entanglement</strong> across support functions and even operations. Untangling can take several months to several years and often includes service agreements of varying durations. In addition, the complex regulatory and legal requirements make the process even more complex.</p><h1 id="Kindness-Can-Have-Unexpectedly-Positive-Consequences"><a href="#Kindness-Can-Have-Unexpectedly-Positive-Consequences" class="headerlink" title="Kindness Can Have Unexpectedly Positive Consequences"></a><strong>Kindness Can Have Unexpectedly Positive Consequences</strong></h1><hr><ul><li>Start Time: 15:02</li></ul><p>[[第一章笔记英语阅读笔记#<strong>Kindness Can Have Unexpectedly Positive Consequences</strong>|note]]<br>Scientists who study happiness know that being kind to others can improve well-being. Acts as simple as buying a cup of coffee for someone can boost a person’s mood, for example. Everyday life <strong>affords many opportunities for</strong> such actions, yet people do not always take advantage of them. In a set of studies published online in the <em>Journal of Experimental Psychology: General</em>, Nick Epley, a behavioral scientist at the University of Chicago Booth School of Business, and I examined a possible explanation. <em>We found that people who perform random acts of kindness do not always realize how much of an impact they are having on another individual.</em> People <strong>consistently</strong> and systematically underestimate how others value these acts.</p><p>Across multiple experiments involving approximately 1,000 participants, people performed a random act of kindness—that is, an action done with the primary intention of making someone else (who isn’t expecting the gesture) feel good. Those who perform such actions expect nothing <strong>in return</strong>. From one procedure to the next, the specific acts of kindness varied. For instance, in one experiment, people wrote notes to friends and family “just because.” In another, they gave cupcakes away. Across these experiments, we asked both the person performing a kind act and the one receiving it to fill out questionnaires. We asked the person who had acted with kindness to report their own experience and predict their <strong>recipient</strong>’s response. We wanted to understand how valuable people perceived these acts to be, so both the performer and recipient had to rate how “big” the act seemed. <strong>In some cases</strong>, we also <strong>inquired about</strong> the actual or perceived cost in time, money or effort. <strong>In all cases</strong>, we compared the performer’s expectations of the recipient’s mood with the recipient’s actual experience.</p><p>Across our investigations, several robust patterns emerged. <strong>For one</strong>, both performers and recipients of the acts of kindness were in more positive moods than normal after these exchanges. <strong>For another</strong>, it was clear that performers undervalued their impact: recipients felt significantly better than the kind actors expected. The recipients also <strong>reliably</strong> rated these acts as “bigger” than the people performing them did. We initially studied acts of kindness done for familiar people, such as friends, classmates or family. But we found that participants underestimated their positive impact on strangers as well. In one experiment, participants at an ice-skating rink in a public park gave away hot chocolate on a cold winter’s day. Again the experience was more positive than the givers anticipated for the recipients, who were people that just happened to be nearby. While the people giving the hot chocolate saw the act as relatively <strong>inconsequential</strong>, it really mattered to the recipients.</p><p>Our research also <strong>revealed</strong> one reason that people may underestimate their action’s impact. When we asked one set of participants to estimate how much someone would like getting a cupcake simply for participating in a study, for example, their predictions <strong>were well-calibrated with</strong> recipient reactions. But when people received cupcakes through a random act of kindness, the cupcake givers underestimated how positive their recipients would feel. Recipients of these unexpected actions tend to focus more on warmth than performers do. Our work suggests that simply being part of a positive, <strong>prosocial</strong> <strong>interaction</strong> is meaningful beyond whatever it is a person receives. People understand that cupcakes can make folks feel good, to be sure, but it <strong>turns out</strong> that cupcakes given in kindness can make them feel surprisingly good. When someone is thinking primarily about the tasty treat they are giving away, they may not realize that the warmth of that gesture is an extra <strong>ingredient</strong> that can make the cupcake even sweeter.</p><p><em>Missing the importance of warmth may <strong>stand in the way of</strong> being kinder in daily life.</em> People generally want to perform kind actions—in fact, many of our participants noted that they’d like to do so more often. But our data suggest that underestimating the impact of one’s actions may reduce the likelihood of kindness. If people undervalue this impact, they might not bother to carry out these warm, prosocial behaviors. Furthermore, the <strong>consequences</strong> of these acts may go beyond a single recipient: kindness can be <strong>contagious</strong>. In another experiment, we had people play an economic game that allowed us to examine what are sometimes called “pay it forward” effects. In this game, participants allocated money between themselves and a person whom they would never meet. People who had just been on the receiving end of a kind act gave <strong>substantially</strong> more to an <strong>anonymous</strong> person than those who had not. Meanwhile the person who performed the initial act did not recognize that their generosity would <strong>spill over</strong> in these <strong>downstream</strong> interactions.</p><p>These findings suggest that what might seem small when we are deciding whether or not to do something nice for someone else could matter a great deal to the person we do it for. <em>Given that these warm gestures can enhance our own mood and brighten the day of another person, why not choose kindness when we can?</em></p><h1 id="Why-falling-asleep-with-the-lights-on-is-bad-for-your-health"><a href="#Why-falling-asleep-with-the-lights-on-is-bad-for-your-health" class="headerlink" title="Why falling asleep with the lights on is bad for your health"></a><strong>Why falling asleep with the lights on is bad for your health</strong></h1><hr><ul><li>Start Time: 16:09</li><li>End Time: 16:24<br>[[第一章英语阅读原文#<strong>Why falling asleep with the lights on is bad for your health</strong>|note]]<br>Many of us are surrounded by light at night — from <strong>streetlights streaming through</strong> our windows to televisions and smartphones by our beds. And now research shows that <strong>exposure to</strong> light at night in the hours before bedtime and even during sleep can be <strong>detrimental</strong> to our health.</li></ul><p>Light is a key regulator of our brain’s biological clock, known as the suprachiasmaticnucleus. “<em>Light is powerful <strong>in that</strong> it can synchronize rhythms and, at the wrong time, it can desynchronize rhythms</em>,” said Phyllis Zee, neurologist and director of the Center for Circadian and Sleep Medicine at Northwestern University Feinberg School of Medicine.</p><p>In one 2022 study, Zee and her colleagues tested how light exposure would affect the biology of 20 young healthy adults as they slept. One group spent a night asleep in <strong>dim</strong> light, similar to dusk, followed by a night with the overhead lights on. The overhead lights <strong>emitted a glow</strong> that was roughly equivalent to hotel hallway lighting — bright, but not sufficient for comfortable reading, Zee said. A control group spent both nights sleeping in dim light.</p><p>Participants who slept with the lights on reported that they slept fine, but brain recordings showed that they spent less time in slow wave and rapid eye movement sleep, which are more restful stages critical for cognitive functioning. The effects on their metabolism and heart were even more striking. Blood samples <strong>indicated that</strong> a single night sleeping under room light increased participants’ <strong>insulin</strong> <strong>resistance</strong>, which is important for blood sugar control, the following morning. But most surprising to the researchers was how the light exposure affected heart rate. “It was high the entire night,” Zee said. “That’s what was bizarre.”</p><p><em>These results suggest that, even with our eyes closed, our brain can be aware of relatively low light, which may cause the brain’s autonomic “fight-or-flight” system to become “low-key revved up,”</em> Zee said. “It’s almost like in preparation to run or having to wake up.” Though this study <strong>was conducted with</strong> a small sample size of young and healthy people, other recent research suggests that light exposure during sleep may be even more detrimental to older individuals. In another 2022 study involving over 550 adults 63 and older, Zee and her colleagues found that any light exposure during sleep was associated with higher <strong>prevalence</strong> of obesity, diabetes and hypertension.</p><p>Other research indicated that sleeping with even a little light in the room decreased sleep quality. Kenji Obayashi, a researcher studying the epidemiology of circadian rhythms at Nara Medical Universityin Japan, conducted a 2019 study involving over 1,100 older participants that found light exposure in the hours before waking up was associated with more sleep disturbances. “We know that even moderate levels of light at night, like you may see coming in from the windows outside or your night light or hallway light, seems to affect your brain,” Zee said.</p><h1 id="To-live-longer-pick-up-the-pace-just-three-minutes-a-day-study-shows"><a href="#To-live-longer-pick-up-the-pace-just-three-minutes-a-day-study-shows" class="headerlink" title="To live longer, pick up the pace just three minutes a day, study shows"></a><strong>To live longer, pick up the pace just three minutes a day, study shows</strong></h1><hr><ul><li>Start Time: 16:24</li><li>End Time: 16:40<br>[[第一章英语阅读原文#<strong>To live longer, pick up the pace just three minutes a day, study shows</strong>|note]]<br>Hurry to the bus stop. Rush up the stairs. Play tag with your kids. Romp with the dog. Vacuum the living room with a little extra zing. Increasing the vigor and gusto of our daily activities could <strong>have a substantial impact on</strong> our longevity, according to a fascinating new study of movement intensity and mortality.</li></ul><p>The study finds that as few as three minutes a day of <strong>vigorous</strong> everyday activity is linked to a 40 percent lower risk of premature death in adults, even when they do not otherwise exercise at all. “It is fantastic” research, said Ulrik Wisloff, the director of the K.G. Jebsen Center for Exercise in Medicine at the Norwegian University of Science and Technology in Trondheim. He has <strong>extensively</strong> studied activity and longevity but <strong>was not involved</strong> in the new study.</p><p>The study’s results join <strong>mounting</strong> scientific evidence that adding a little <strong>intensity</strong> to our lives <strong>pays big dividends for</strong> our health, without requiring extra equipment, instruction, gym memberships or time. The idea that how we move influences how long we live is hardly new. Plenty of research <em>links regular exercise with longer life spans</em>, including the formal public health exercise guidelines, which recommend at least 150 minutes a week of moderate exercise for health and longevity.</p><p>More-focused research, though, suggests intensifying some of our exercise — making sure our heart rates and breathing rise — <strong>amplifies</strong> the health benefits. In a large-scale 2006 study from Wisloff’s lab, for instance, just 30 minutes a week of intense exercise dropped the risk of dying from heart disease by about half in men and women, compared to people who were sedentary. Similarly, a study published last year in JAMA Internal Medicine concluded that people who occasionally pushed themselves during exercise were about 17 percent less likely to die <strong>prematurely</strong> than other people who did the same amount of exercise, but at a gentler, moderate pace.</p><p>Both of these studies, though, and similar, past research were based on people’s subjective recall of how much and how hard they exercised. They also were exercise studies, making them <strong>inherently</strong> of interest mostly to people who exercise or would like to, which does not represent the greater part of humanity. “If we’re honest, most people are allergic to the word ‘exercise,’” said Emmanuel Stamatakis, a professor of physical activity and health studies at the University of Sydney in Australia, who led the new study.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux命令学习</title>
      <link href="/posts/ed5f8cc8.html"/>
      <url>/posts/ed5f8cc8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Date-2024-01-05"><a href="#Date-2024-01-05" class="headerlink" title="- Date:2024-01-05"></a>- Date:2024-01-05</h1><ul><li>Time:21:44</li><li>Subject: </li><li>Tags: #linux<br>[[2024-01]]</li></ul><hr><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><ul><li><code>*</code> 匹配0个或者多个字符</li><li><code>?</code> 匹配一个字符</li><li><code>[abcd]</code> 匹配abcd中任意一个字符</li><li><code>[a-z]</code> 匹配a-z任意一个字符</li><li><code>[!abc]</code> 不匹配括号内任意一个字符，或者用 <code>^</code> 代替 <code>!</code></li></ul><h1 id="linux的文件目录"><a href="#linux的文件目录" class="headerlink" title="linux的文件目录"></a>linux的文件目录</h1><blockquote><p>[!note]</p><ul><li>磁盘结构——树状，与Windows不同</li><li><code>ls /</code> 把根的目录显示出</li><li><code>sudo apt-get install openssh -server</code>安装ssh服务</li><li><code>sudo service ssh start</code>启动ssh命令</li><li><code>/etc/init.d/ssh restart</code>重启ssh服务<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2></li><li>bin<ul><li>存放命令</li><li>binary的缩写</li></ul></li><li>boot<ul><li>系统启动所需的目录</li></ul></li><li>dev<ul><li>设备文件，把设备抽象成文件</li><li>device缩写</li></ul></li><li>etc<ul><li>系统所需的配置文件</li></ul></li><li>home<ul><li>存放用户文件的目录，可以是不同用户的</li></ul></li><li>lib<ul><li>动态库，给应用程序使用</li><li>library缩写</li></ul></li><li>lost+found<ul><li>异常关机产生的</li></ul></li><li>media<ul><li>自动挂载的设备</li></ul></li><li>mnt<ul><li>手动挂载的目录</li><li>一般是空的，需要手动创建目录</li></ul></li><li>opt<ul><li>安装的文件的目录</li><li>类似usr目录</li></ul></li><li>proc<ul><li>放进程有关的信息</li><li>process</li></ul></li><li>root<ul><li>root用户的文件</li></ul></li><li>sbin<ul><li>super usr</li><li>系统管理员会用的命令</li></ul></li><li>usr<ul><li>用户程序的资源</li><li>类似program files<ul><li>bin 用户所用的程序</li><li>sbin 超级用户使用的高级程序</li><li>src 内核源码</li></ul></li></ul></li><li>var<ul><li>存放经常修改的文件 如日志</li></ul></li><li>srv<ul><li>系统服务启动后用到的数据<h1 id="终端中不同颜色的含义"><a href="#终端中不同颜色的含义" class="headerlink" title="终端中不同颜色的含义"></a>终端中不同颜色的含义</h1></li></ul></li><li>白色 普通文件</li><li><font color="#00b0f0">蓝色 目录</font></li><li><font color="#00b050">绿色 可执行文件</font></li><li><font color="#4bacc6">青色 链接文件</font> ln文件</li><li><font color="#ff0000">红色 压缩文件</font></li><li><font color="#ffc000">黄色 设备文件</font></li><li><font color="#7f7f7f">灰色 其他文件</font><h1 id="终端中的快捷键"><a href="#终端中的快捷键" class="headerlink" title="终端中的快捷键"></a>终端中的快捷键</h1><h2 id="终端中ctrl类"><a href="#终端中ctrl类" class="headerlink" title="终端中ctrl类"></a>终端中ctrl类</h2></li><li>ctrl f 向前光标</li><li>ctrl b 向后光标</li><li>ctrl a 行首</li><li>ctrl e 行尾</li><li>ctrl p 上翻页（感觉和上下键的一样）</li><li>ctrl n 下翻页</li><li>ctrl h 删除前一个字符（就是bcak键）</li><li>ctrl d 删除光标的字符，就是对应的，不同上面的</li><li>ctrl u 删除光标前所有内容（不包括光标的字符）</li><li>ctrl k 删除光标至末尾的内容（包括光标的字符）</li><li>ctrl w 删除光标前单词（空格隔开）</li><li>ctrl y 快速恢复擦除的文本<h2 id="终端中tab"><a href="#终端中tab" class="headerlink" title="终端中tab"></a>终端中tab</h2></li><li>补全输入的命令/路径（唯一的时候会补全，否则会下面）</li><li>提示可能要输入的命令/路径<h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1></li><li>对于d<font color="#ff0000">rwx</font><font color="#00b050">rwx</font><font color="#0070c0">rw-</font><ul><li><font color="#ff0000">所有者</font> <font color="#00b050">用户组</font> <font color="#0070c0">其他人</font></li></ul></li><li>权限类型<ul><li>r 可读</li><li>w 可写</li><li>x 可执行/可切换目录</li><li><ul><li>无权限<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1>[!tip]<br>十分重要，但不局限于这些<h2 id="一般类"><a href="#一般类" class="headerlink" title="一般类"></a>一般类</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3></li></ul></li></ul></li><li>查看帮助手册，比如查看命令的使用方法，或者应用程序<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4></li><li>-f 显示简短描述信息（先使用这个，这样可以知道这个名字下是不是有同名的函数/命令）</li><li>-k 根据关键词搜索手册，和这个相关的都会出来</li><li>-w 显示手册文件所在位置<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4>[!note]<br>先打参数 再打需要操作的word</li><li><code>man -f sleep</code></li><li><code>man 3 sleep</code> 看第三个章节的sleep （因为使用-f查看时发现有多个sleep，默认看的是1）<h4 id="快捷用法"><a href="#快捷用法" class="headerlink" title="快捷用法"></a>快捷用法</h4></li><li>/word 在帮助文档中搜索word关键词<ul><li>n 下一个</li><li>shift n 上一个<h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3></li></ul></li><li>比man更复杂，有多页，有超链接<h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4></li><li>-w 显示物理位置</li><li>-f 指定要访问的info</li><li>-n 在首个浏览过的info文件中指定节点</li><li>-O 跳转至命令行选项节点<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4></li><li>n 显示下一节点的内容</li><li>p 显示上一节点的内容</li><li>l 返回上一个访问节点的内容</li><li>空格 向前一页</li><li>back 向后一页</li><li>b/e 一个节点内容的开始/结束</li><li>h 打开info教程</li><li>d 回到info的初始节点</li><li>回车 跳转到链接文本</li><li>q 退出<h3 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h3></li><li>查询命令执行的功能是什么</li><li>相当于把man -f的结果打印出来<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4></li><li>改变已有文件的时间戳属性</li><li>创建新的空文件<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4></li><li>-a 改变读取时间的记录（access change）</li><li>-m 改变修改时间的记录（modify change）</li><li>-c 不创建新文件</li><li>-t 设置文件时间记录，格式和date命令相同 <code>touch -t 2201011030.55 file</code> 2022年1月1日10点30分55秒</li><li>-r 使用参考文件的时间记录 <code>touch file -r ref_file</code></li><li>-d 使用指定字符串表示时间式 <code>touch -d &quot;tomorrow&quot; file</code><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3></li><li>创建目录makedir，使用很多<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4></li><li>-p 递归创建多级目录</li><li>-m 建立目录同时设置权限</li><li>-v 显示目录创建过程<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4></li><li>多个目录<ul><li><code>mkdir dir1 dir2 dir3</code> 创建多个笔记</li><li><code>mkdir dir&#123;5..7&#125;</code> 创建5到7的目录</li><li><code>mkdir -p dir7/dir8/dir9</code> 文件夹里面又有文件夹</li></ul></li><li><code>mkdir -m 700 dir1/dir10</code> 700权限的递归目录<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3></li><li>删除文件，remove<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4></li><li>-r 递归删除，把子目录的文件也删除</li><li>-f 忽略不存在的文件，不会出现警告信息</li><li>-v 显示执行的过程</li><li>-i 删除前会问是否进行操作<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4></li><li><code>rm -rf *</code> 删除该目录下所有文件</li><li><code>rm -r dir</code> 删除这个目录</li><li><code>rm file.txt</code> 删掉这个文件<h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3></li><li>删除空目录<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4></li><li>-p 递归方式删除所有父级目录</li><li>-v 显示过程<h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4></li><li><code>rmdr -p dir1/dir2/dir3</code> 递归删除多重目录<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3></li><li>移动文件</li><li>重命名文件<h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4></li><li>-i 存在同名，询问覆盖</li><li>-f 直接覆盖，不询问</li><li>-b 存在同名，覆盖前创建备份</li><li>-u 当源文件比目标的新，或者目标文件不存在，才执行移动的操作<h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4></li><li><code>mv file.txt newnew.txt</code> 重命名</li><li><code>mv file.txt /dir</code> 移动到dir目录</li><li><code>mv dir1 dir2</code> 把dir1移动到dir2中，存在的时候才会移动，不存在就是重命名</li><li><code>mv -i file1.txt file2.txt</code> 提示是否覆盖</li><li><code>mv * ../</code> 移动当前文件夹下所有文件到上一目录</li><li><code>mv dir3/* dir2</code> 将当前目录的一个子目录文件移动到另外一个子目录里面<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3></li><li>复制文件和目录<h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4></li><li>-f 目标文件存在，直接覆盖，<font color="#ffc000">默认就是-f，不会提示</font></li><li>-i 目标文件存在，询问是否覆盖</li><li>-a 一般复制目录的时候用，保留链接，文件属性，并复制目录下的所有内容</li><li>-r 递归复制文件和目录</li><li>-b 覆盖已存在的文件目标前将目标文件备份</li><li>-v 详细显示操作的过程<h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4></li><li><code>cp file1.txt file2.txt</code> 复制文件</li><li><code>cp -r dir1 dir2</code> 复制目录</li><li><code>cp -a dir1 dir2</code> 保留所有属性复制<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3></li><li>切换目录<h4 id="特殊目录"><a href="#特殊目录" class="headerlink" title="特殊目录"></a>特殊目录</h4></li><li><code>~</code> 用户家目录</li><li><code>.</code> 当前目录</li><li><code>..</code> 当前目录的上一级目录</li><li><code>/</code> 根目录</li><li><code>-</code> 上一次所在的目录<h4 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h4></li><li>起始路径为<code>/</code>的为<font color="#ffc000">绝对路径</font></li><li>不是<code>/</code>的是<font color="#ffc000">相对路径</font><h4 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h4></li><li><code>cd dir</code> 切换到当前的dir目录</li><li><code>cd ../../</code> 切换到上上级目录</li><li><code>cd</code> 切换到家目录</li><li><code>cd ~</code> 切换到上一次的目录</li></ul></blockquote><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><ul><li>打印当前路径，打印的是<font color="#ffc000">绝对路径</font></li><li>print working directory<h4 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h4></li><li><code>pwd</code> 直接显示<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3></li><li>显示目录信息</li><li>list<h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4></li><li>-a 显示所有文件和目录（包括隐藏文件）</li><li>-l 长格式列出文件和目录信息</li><li>-r 相反次序显示（默认按英文字母显示）</li><li>-t 根据修改时间排序</li><li>-h 以人类可读的格式显示数字大小，会有kb/mb/gb，不然就是直接比特显示</li><li>-A 同 -a 但不列出<code>. 和 ..</code>这个是当前目录和父目录，-a会列出</li><li>-S 根据文件大小排序</li><li>-R 递归列出所有子目录</li><li>-F 在列出的文件名称后加一符号；<ul><li>可执行文件多个<code>*</code></li><li>目录多个<code>/</code><h4 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h4></li></ul></li><li><code>ls -a</code> 列出所有文件，包括隐藏文件</li><li><code>ls -l</code> 显示详细信息</li><li><code>ls /</code> 列出根目录<code>/</code>下的所有文件</li><li><code>ls -lR</code> 列出当前目录所有文件，包括子目录</li><li><code>ls -l f*</code> 列出带f开头的文件详细信息</li><li><code>ls -ltr</code> 列出所有文件，时间的倒序显示</li><li><code>ls -AF</code> 显示所有文件和目录，并且加上特定独好区分文件</li><li><code>ls -lh</code> 列出详细信息并显示文件大小<h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3></li><li>以树状图列出目录内容<h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4></li><li>-a 显示所有文件和目录（加上隐藏文件）</li><li>-L 层级限制</li><li>-t 根据更改时间排序</li><li>-r 更改时间倒叙</li><li>-f 在每个文件或目录之前，显示完整的相对路径名称</li><li>-d 显示目录名称而非内容</li><li>-p 显示权限信息<h4 id="例子-9"><a href="#例子-9" class="headerlink" title="例子"></a>例子</h4></li><li><code>tree -L 2</code> 显示n层目录<h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3></li><li>显示文件或者文件系统的详细信息<h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4></li><li>-L 支持符号链接</li><li>-f 显示文件系统的信息</li><li>-t 简洁方式输出<h4 id="三种时间"><a href="#三种时间" class="headerlink" title="三种时间"></a>三种时间</h4></li><li>acess time 访问时间<ul><li>读取（more/less/cat/tail），修改时（vim/nano）改变</li></ul></li><li>modify time 修改时间<ul><li>修改时改变</li></ul></li><li>change tiem 状态改变时间<ul><li>修改，文件属性变化的改变（chmod/chown）<h2 id="文件操作-工具类"><a href="#文件操作-工具类" class="headerlink" title="文件操作/工具类"></a>文件操作/工具类</h2><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3></li></ul></li><li>用字符串替换的方式批量改变文件名<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4></li><li><code>rename &#39;s/oldname/newname/&#39; files</code><ul><li>files 是修改的文件，可以是多个，用通配符表示<h4 id="通配符-1"><a href="#通配符-1" class="headerlink" title="通配符"></a>通配符</h4></li></ul></li><li><code>?</code> 替代单个字符</li><li><code>*</code> 替代多个字符<h4 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h4></li><li>-n 模拟运行</li><li>-v 输出每步的执行信息</li><li>-f 强制执行<h4 id="例子-10"><a href="#例子-10" class="headerlink" title="例子"></a>例子</h4></li><li><code>rename &#39;s/.txt/.doc/ myfile.txt&#39;</code> 把.txt改成了.doc</li><li><code>rename -n &#39;s/file/file0/&#39; file*</code> 模拟把file开头的所有文件都改成file0开头<h3 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h3></li><li>更改文件属性<h4 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h4></li><li>-R 递归处理目录下所有文件</li><li>-v 设置文件或目录版本</li><li>-V 显示指令执行过程</li><li><ul><li>开启某个权限</li></ul></li><li><ul><li>关闭某个权限（属性）</li></ul></li><li>= 指定某个权限<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4></li><li>略 太多了<h4 id="例子-11"><a href="#例子-11" class="headerlink" title="例子"></a>例子</h4></li><li><code>chattr +i file.txt</code> 防止修改</li><li><code>chattr -i file.txt</code> 解锁</li><li><code>chattr +a file.txt</code> 只允许最佳内容</li><li><code>chattr -R +i dir</code> 给一个目录所有文件添加限制</li><li><code>lsattr file.txt</code> 查看文件属性<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3></li><li>识别文件类型<h4 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h4></li><li>-b 列出文件类型，不显示文件名称</li><li>-c 详细限制执行过程</li><li>-f 指定名称文件，显示多个文件类型信息</li><li>-L 直接显示符号连接指向的文件类型</li><li>-m 指定魔法数字文件</li><li>-z 尝试区解读压缩包的内容</li><li>-i 显示MIME类型<h3 id="md5sum"><a href="#md5sum" class="headerlink" title="md5sum"></a>md5sum</h3></li><li>生成和校验文件的md5值<h4 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h4></li><li>-b 以二进制模式读取文件</li><li>-t 以文本模式读入文件内容</li><li>-c 根据已知的md5，对现存的文件进行校验<h4 id="例子-12"><a href="#例子-12" class="headerlink" title="例子"></a>例子</h4></li><li><code>md5sum file.txt &gt; file.md5</code> 将生成的md5值重定向到指定文件（md5文件）</li><li><code>md5sum -c file.md5</code> 直接对file文件进行md5验证</li><li><code>md5sum -c --status file.md5</code> <code>ech$?</code> 校验但是不显示任何输出，echo返回码表示成功与否<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3></li><li>搜索指定文件<h4 id="例子-13"><a href="#例子-13" class="headerlink" title="例子"></a>例子</h4></li><li><code>find / -name *.conf</code> 全盘搜索以conf结尾的文件</li><li><code>find /etc -size +1k</code> 搜索/etc目录下大于1k大小的文件</li><li><code>find . -type f</code> 搜索当前目录所有文件</li><li><code>find . -perm 664 -exec ls -l &#123;&#125; \;</code> 搜索664权限文件并列出</li><li><code>find .</code> 列出当前目录和文件</li><li><code>find . -iname &quot;*.txt&quot;</code> 搜索后缀为txt的，有i就是包括大写的</li><li><code>find . ! -name &quot;*.txt&quot;</code> 反过来</li><li><code>find . -mtime -7 -exec rm -i &#123;&#125; \;</code> 搜索7天内被修改的文件，并询问删除<h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3></li><li>查找命令文件所在位置</li><li>搜索在path变量中<h4 id="例子-14"><a href="#例子-14" class="headerlink" title="例子"></a>例子</h4></li><li><code>which bash</code> 找bash在哪<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3></li><li>查找命令二进制程序、源码和man手册相关文件的路径<h4 id="例子-15"><a href="#例子-15" class="headerlink" title="例子"></a>例子</h4></li><li><code>whereis ls</code> 找出所有</li><li><code>whereis -b ls</code> 只找二进制程序</li><li><code>whereis -m ls</code> 只找man手册页路径<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3></li><li>快速查找文件或者目录<h4 id="例子-16"><a href="#例子-16" class="headerlink" title="例子"></a>例子</h4></li><li><code>locate file.txt</code> 找带 <code>file.txt</code> 的所有文件</li><li><code>locate /etc/sh</code></li><li><code>locate whereis</code></li><li><code>locate -i locate/f</code> 查找该路径下f开头的文件，-i不区分大小写<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3></li><li>Change owner</li><li>改变用户和用户组<h4 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h4></li><li>-c 显示变更信息</li><li>-R 目录下所有都改变<h4 id="例子-17"><a href="#例子-17" class="headerlink" title="例子"></a>例子</h4></li><li><code>sudo chown alvin:alvin file.txt</code> 把这个文件的用户组和用户改成alvin</li><li><code>sudo chown :alvin file.txt</code> 改用户组</li><li><code>sudo chown -R alvin:alvin dir</code> 把指定目录和其他子文件都该了<h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3></li><li>改变用户组</li><li>和chown很像<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3></li><li>Change mod</li><li>改变文件权限<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4></li><li>符号模式<ul><li>对象<ul><li>u user 文件所有者</li><li>g group 文件所有组所在组</li><li>o others 其他用户</li><li>A all 所有用户，相当于ugo</li></ul></li><li>操作<ul><li><ul><li>加权限</li></ul></li><li><ul><li>去除权限</li></ul></li><li>= 重新设置权限</li></ul></li><li>权限<ul><li>r 读</li><li>w 写</li><li>x 执行</li></ul></li></ul></li><li>数字模式<ul><li>类似二进制的代码，加起来，数字代表权限<h4 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h4></li></ul></li><li>-R 递归处理所有文件<h4 id="例子-18"><a href="#例子-18" class="headerlink" title="例子"></a>例子</h4></li><li><code>chmod a+r file.txt</code> 设置都可读</li><li><code>chmod -R a+r</code> 全部设置可读取</li><li><code>chmod u+x file.txt</code> 文件拥有者才能执行</li><li><code>chmod ug+w,0-w file.txt</code> 所有者和同组可写，其他人不可写</li><li><code>chmod a+r,a+w,a+x file.txt</code> <code>chmod 777 file.txt</code> 设置所有人都可读可写可执行</li><li><code>chmod 755 file.txt</code> 拥有者可读可写可执行，其他人可读可执行</li><li><code>chmod 9=rw,go= file.txt</code> 拥有者可读可写，其他人没有权限<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3></li><li>文本搜索工具<h4 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h4></li><li>-i 忽略大小写</li><li>-c 输出匹配行的数量</li><li>-l 只列出符合的文件名，不输出匹配行</li><li>-n 列出所有匹配行，显示行号</li><li>-h 查询多文件时不显示文件名</li><li>-s 不显示不存在，不匹配的错误信息</li><li>-v 显示不包含匹配文本的所有行</li><li>-w 匹配整词</li><li>-x 匹配整行</li><li>-r 递归搜索</li><li>-q 禁止输出任何结果，退出状态标识是否成功</li><li>-b 打印距离文件头部偏移量，字节为单位</li><li>-o 于-b结合使用</li><li>-F 匹配固定字符串的内容</li><li>-E 支持扩展的正则表达式<h4 id="例子-19"><a href="#例子-19" class="headerlink" title="例子"></a>例子</h4></li><li><code>grep -rl hello *</code> 目录下及其子目录搜hello</li><li><code>grep root /etc/passwd /etc/shadow</code> 搜索多个文件中的内容root<h3 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h3></li><li>性能更好且优化的grep -E</li><li>可使用正则表达式<h4 id="例子-20"><a href="#例子-20" class="headerlink" title="例子"></a>例子</h4></li><li><code>egrep &#39;a+&#39; file.txt</code> 找包含一个以上a的内容</li><li><code>egrep &#39;linux|666 file.txt&#39;</code> 包含linux或者666</li><li><code>egrep &#39;(linux)+&#39; file.txt</code> 包含多个linux整体的内容</li><li><code>egrep &#39;^#&#39; file.txt</code> 查找 <code>#</code> 开头的内容</li><li><code>egrep &#39;linux$&#39; file.txt</code> 查找linux结尾的内容</li><li><code>egrep &#39;(ab)&#123;3&#125; file.txt&#39;</code> 查找连续出现三次ab的内容</li><li><code>egrep &#39;ab[cd]&#39; file.txt</code> 查找包括abc或者abd的内容<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3></li><li>查看文件内容<h4 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h4></li><li>-n 显示行数</li><li>-s 去除重复的空行</li><li>-b 显示行数，空行不算</li><li>-E 每行结束显示$</li><li>-T 将tab显示为 <code>^I</code><h4 id="例子-21"><a href="#例子-21" class="headerlink" title="例子"></a>例子</h4></li><li><code>cat -b file.txt</code> 显示行数</li><li><code>cat file.txt &gt; file1.txt #</code> 重定向内容<ul><li>若file1不存在则创建，内容被覆盖</li><li>换成 <code>&gt;&gt;</code> 就变成追加到末尾，不会覆盖</li></ul></li><li><code>cat file1.txt file2.txt &gt; combine.txt</code> 合并文件</li><li><code>cat &gt; file.txt</code> 创建文件，完成后ctrl+d保存<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3></li><li>分页显示内容，只能往下翻，不能往前<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4></li><li>回车 下一行</li><li>空格下一页<h4 id="例子-22"><a href="#例子-22" class="headerlink" title="例子"></a>例子</h4></li><li><code>more -c -10 ~/.bashrc</code> 清屏操作，每次十行显示</li><li><code>more -s +10 ~/.bashrc</code> 从第十行开始，连续两行空白，合并成一行空白显示<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3></li><li>分页显示，可以上下翻页<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4></li><li>回车/j 下一行</li><li>k 上一行</li><li>空格/f 下页</li><li>b 上一页</li><li>q 退出</li><li>/xx 搜索<ul><li>n 下一个</li><li>Shift n 上一个<h4 id="例子-23"><a href="#例子-23" class="headerlink" title="例子"></a>例子</h4></li></ul></li><li><code>less abc def</code> 查看两个文件<ul><li><code>:n</code> 浏览下一个文件</li><li><code>:p</code> 浏览前一个文件</li></ul></li><li><code>history | less</code> 以less命令分页查看history命令，用管道<h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3></li><li>添加行号显示<h4 id="例子-24"><a href="#例子-24" class="headerlink" title="例子"></a>例子</h4></li><li><code>nl -b t file.txt</code> 空行没有行号，默认没有</li><li><code>nl -b a -n rz -w 3 file.txt</code> 行号右边显示，加0填充，宽度为3，空行有行号<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3></li><li>文件分割<h4 id="例子-25"><a href="#例子-25" class="headerlink" title="例子"></a>例子</h4></li><li><code>split -2 file2.txt</code> 每两行分成一个文件</li><li><code>split -b 10k file2.txt</code> 每10kb切割</li><li><code>split -b 10k -d -a 3 file2.txt</code> 数字后缀，宽度为3</li><li><code>split -b 10k -d -a 3 file2.txt split_file</code> 指定前缀<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3></li><li>比较文件的差异<h4 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h4></li><li>-y 并列方式显示</li><li>-c 显示全文，标出不同之处</li><li>-u 合并的方式显示不同</li><li>-W 设置宽度<h4 id="显示提示"><a href="#显示提示" class="headerlink" title="显示提示"></a>显示提示</h4></li><li>a -add</li><li>c -change</li><li>d -delete</li><li>| 前后两个文件内容不同</li><li><code>&lt; 后面比前面少了一行</code></li><li><code>&gt; 后面比前面多了一行</code></li><li><ul><li>后面比前面多了一行</li></ul></li><li><ul><li>后面比前面少了一行</li></ul></li><li>! 有差别的行<h4 id="例子-26"><a href="#例子-26" class="headerlink" title="例子"></a>例子</h4></li><li><code>diff -y -W 50 file1.txt file2.txt</code> 并排格式输出</li><li><code>diff -c file1.txt file2.txt</code> 上下文格式输出</li><li><code>diff file1.txt file2.txt &gt; file.patch</code> 生成补丁</li><li><code>patch file1.txt file.patch</code> 打补丁<h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3></li><li>转换或者删除文件中的字符<h4 id="参数-18"><a href="#参数-18" class="headerlink" title="参数"></a>参数</h4></li><li>-c 反选字符</li><li>-d 删除集合中的字符</li><li>-s 缩减连续字符成指定单个字符<h4 id="例子-27"><a href="#例子-27" class="headerlink" title="例子"></a>例子</h4></li><li><code>tr -d &quot;[a-z]&quot;</code> 删除小写字母</li><li><code>tr -d 0-9</code> 删除数字</li><li><code>tr -d -c &#39;0-9 \n&#39;</code> 删除不在集合中的字符</li><li><code>tr -s &#39;\n&#39;</code> 压缩重复空白行<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3></li><li>查看磁盘使用空间<h4 id="参数-19"><a href="#参数-19" class="headerlink" title="参数"></a>参数</h4></li><li>-a 显示目录中所有文件大小</li><li>-h 易读方式显示</li><li>-s 看目录占用大小<h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3></li><li>查看磁盘空间使用情况<h4 id="参数-20"><a href="#参数-20" class="headerlink" title="参数"></a>参数</h4></li><li>-a 显示所有文件系统</li><li>-h 易读显示</li><li>-i 显示inode信息</li><li>-t&lt;文件系统类型&gt; 显示指定文件系统类型的文件系统</li><li>-T 输出时显示系统类型<h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3></li><li>强制将更改的内容立刻写入磁盘<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3></li><li>挂载文件系统<h4 id="参数-21"><a href="#参数-21" class="headerlink" title="参数"></a>参数</h4></li><li>-o 挂载方式<ul><li>loop 用来把一个文件当成硬盘分区挂载接上系统</li><li>ro 只读方式挂载</li><li>rw 读写方式挂载</li><li>iocharset 指定访问文件系统所用字符集</li></ul></li><li>-t 指定挂载类型<h4 id="例子-28"><a href="#例子-28" class="headerlink" title="例子"></a>例子</h4></li><li><code>mount -t tmpfs</code> 查看当前系统挂载的所有文件系统信息</li><li><code>sudo mount /dev/sdb /mnt/udisk</code> 把U盘挂载</li><li><code>sudo mount -0 loop /home/xxiso /mnt/iso</code> 把ISO镜像挂载<h3 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h3></li><li>卸载文件系统<h4 id="例子-29"><a href="#例子-29" class="headerlink" title="例子"></a>例子</h4></li><li><code>umount -v /dev/sdb</code> 设备名卸载</li><li><code>umount -v /media/chris/xxx</code> 挂载点卸载<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3></li><li>打包/解压工具<h4 id="参数-22"><a href="#参数-22" class="headerlink" title="参数"></a>参数</h4></li><li>-c 新建打包文件</li><li>-x 解压</li><li>-f 指定需要处理的文件</li><li>-z 通过gzip方式压缩 <code>.tar.gz</code> 为后缀</li><li>-v 显示过程</li><li>-t 查看打包文件内容</li><li>-C dir 指定压缩/解压目录<h4 id="例子-30"><a href="#例子-30" class="headerlink" title="例子"></a>例子</h4></li><li><code>tar -zcvf file.tar *.txt</code> 所有txt打包压缩</li><li><code>tar -zxvf file.tar.gz</code> 解压到当前目录<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3></li><li>压缩<h4 id="参数-23"><a href="#参数-23" class="headerlink" title="参数"></a>参数</h4></li><li>-v 显示执行过程</li><li>-d 更新包内内容</li><li>-r 递归处理<h4 id="例子-31"><a href="#例子-31" class="headerlink" title="例子"></a>例子</h4></li><li><code>zip -r dir.zip dir</code></li><li><code>zip files.zip *.txt</code></li><li><code>zip -dv files.zip newfile.txt</code> 添加新文件进去压缩包<h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3></li><li>解压<h4 id="参数-24"><a href="#参数-24" class="headerlink" title="参数"></a>参数</h4></li><li>-l 显示压缩包包含文件</li><li>-v 显示过程</li><li>-d &lt;目录&gt; 解压到指定位置<h4 id="例子-32"><a href="#例子-32" class="headerlink" title="例子"></a>例子</h4></li><li><code>unzip -v file.zip</code> 显示文件列表包含压缩比率</li><li><code>unzip files.zip -d udir/</code> 解压指定目录<h3 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h3></li><li>对文本高效率压缩<h4 id="参数-25"><a href="#参数-25" class="headerlink" title="参数"></a>参数</h4></li><li>-d 解开压缩文件</li><li>-k 保留源文件</li><li>-l 列出压缩文件信息</li><li>-r 递归</li><li>-v 显示执行过程</li><li>-t 测试压缩包<h2 id="系统类"><a href="#系统类" class="headerlink" title="系统类"></a>系统类</h2><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3></li><li>显示系统信息<h4 id="参数-26"><a href="#参数-26" class="headerlink" title="参数"></a>参数</h4></li><li>-a 显示所有</li><li>-m 显示架构</li><li>-n 主机名称</li><li>-s 内核</li><li>-r 内核发行版本号</li><li>-v 内核版本</li><li>-p 处理器</li><li>-o 操作系统名称</li><li>-i 显示硬件平台<h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h3></li><li>设置系统主机名</li><li>略<h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3></li><li>显示系统启动时间和负载信息<h4 id="参数-27"><a href="#参数-27" class="headerlink" title="参数"></a>参数</h4></li><li>-p 正常运行时间</li><li>-s 系统启动时间<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3></li><li>显示内存使用量<h4 id="参数-28"><a href="#参数-28" class="headerlink" title="参数"></a>参数</h4></li><li>略<h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3></li><li>控制shell程序的资源<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3></li><li>切换系统运行级别<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3></li><li>控制系统服务<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3></li><li>显示虚拟内存状态<h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3></li><li>监视出入输出设备和CPU使用情况<h3 id="ipcs"><a href="#ipcs" class="headerlink" title="ipcs"></a>ipcs</h3></li><li>显示进程间通讯设备信息<h2 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h2><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3></li><li>显示并设置路由<h4 id="例子-33"><a href="#例子-33" class="headerlink" title="例子"></a>例子</h4></li><li><code>route add -net 244.0.0.0 netmask 24.0.0.0 dev ens33</code> 添加网关/设置网关</li><li><code>route -n</code> 显示当前路由</li><li><code>route add -net 244.0.0.0 netmask 24.0.0.0 reject</code> 屏蔽一条路由<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3></li><li>测试网络连通性<h4 id="参数-29"><a href="#参数-29" class="headerlink" title="参数"></a>参数</h4></li><li>-c 指定发送报文数目</li><li>-i 指定发送间隔</li><li>-s 设置大小</li><li>-t 设置TTL大小<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3></li><li>追踪数据包在网络上传输的全部路径<h4 id="参数-30"><a href="#参数-30" class="headerlink" title="参数"></a>参数</h4></li><li>-m &lt;数量&gt;设置检测数据包最大存活数值ttl的大小</li><li>-n 直接使用ip</li><li>-p &lt;端口&gt; 指定udp端口</li><li>-q 探测包个数<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3></li><li>查询修改网络信息</li><li>Network interface configuring</li><li>设置重启后失效<h4 id="参数-31"><a href="#参数-31" class="headerlink" title="参数"></a>参数</h4></li><li>Add 设置设备ipv6</li><li>Del 上传</li><li>Down 关闭指定设备</li><li>Up 启动<h3 id="ifup-ifdown"><a href="#ifup-ifdown" class="headerlink" title="ifup/ifdown"></a>ifup/ifdown</h3></li><li>激活/禁用网络接口<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3></li><li>查看网络状态<h4 id="参数-32"><a href="#参数-32" class="headerlink" title="参数"></a>参数</h4></li><li>-a 显示连线中所有socket</li><li>-p 显示正在使用socket的程序识别码和程序名称</li><li>-l 仅列出监听的服务状态</li><li>-t 显示tcp的情况</li><li>-u udp</li><li>-i 显示网络界面信息表单</li><li>-r 显示路由表信息</li><li>-n 直接使用ip地址，不通过域名服务器</li><li>-x unix端口</li><li>-s 所有端口<h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3></li><li>显示活动套接字信息</li><li>很强大，东西太多了<h4 id="例子-34"><a href="#例子-34" class="headerlink" title="例子"></a>例子</h4></li><li><code>ss -at</code> 显示tcp套接字</li><li><code>ss -s</code> 显示套接字使用情况</li><li><code>ss -lp | grep 6010</code> 找出端口/套接字应用程序</li><li><code>ss -tlr</code> 解析IP和端口号<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3></li><li>远程登入服务器<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3></li><li>安全远程连接工具<h4 id="参数-33"><a href="#参数-33" class="headerlink" title="参数"></a>参数</h4></li><li>-l &lt;登录名&gt; 指定用户名</li><li>-p &lt;端口&gt; 指定端口<h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3></li><li>文件传输协议客户端<h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3></li><li>安全的ftp<h4 id="参数-34"><a href="#参数-34" class="headerlink" title="参数"></a>参数</h4></li><li>-r 下载目录的时候使用，递归<h4 id="例子-35"><a href="#例子-35" class="headerlink" title="例子"></a>例子</h4></li><li><code>sftp -P 30 chris@192.168.2.34</code> 可以不跟端口<h3 id="lftp"><a href="#lftp" class="headerlink" title="lftp"></a>lftp</h3></li><li>优秀的文件客户端</li><li>支持各种协议<h4 id="例子-36"><a href="#例子-36" class="headerlink" title="例子"></a>例子</h4></li><li><code>get file.txt</code> <code>mget file*.txt</code> <code>mget -c *.txt</code> 下载</li><li><code>mirror dir</code> 下载整个目录</li><li><code>mirror -R dir</code> 上传目录</li><li><code>mput new*.txt</code> <code>put file.txt</code> 上传<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3></li><li>下载文件<h4 id="参数-35"><a href="#参数-35" class="headerlink" title="参数"></a>参数</h4></li><li>-i 下载指定文件中列出的地址</li><li>-O 下载后重命名</li><li>-c 打开断点续传</li><li>-b 启动后转入后台执行</li><li>-P 只当保存路径<h4 id="例子-37"><a href="#例子-37" class="headerlink" title="例子"></a>例子</h4></li><li><code>wget --limit-rate=300k -O newname.zip https://xx/xx.zip</code></li><li><code>tail -f wget-log</code> 查看下载进度<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3></li><li>远程拷贝文件<h4 id="参数-36"><a href="#参数-36" class="headerlink" title="参数"></a>参数</h4></li><li>-r 递归复制目录</li><li>-p 保留源文件的时间，模式属性</li><li>-P 指定传输的端口号<h4 id="例子-38"><a href="#例子-38" class="headerlink" title="例子"></a>例子</h4></li><li><code>scp chris@ip:/home/file.txt /myhome/</code> 复制文件到指定目录<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3></li><li>强大的文件传输工具<h4 id="参数-37"><a href="#参数-37" class="headerlink" title="参数"></a>参数</h4></li><li>-o 指定新的本地文件名</li><li>-O 保留远程文件的原始名</li><li>-u 通过服务端配置的用户名和密码授权访问</li><li>-A 设置用户代理标头信息</li><li>-b 设置cookie信息</li><li>-C 断点续传</li><li>-s 静默模式</li><li>-T 上传文件<h4 id="例子-39"><a href="#例子-39" class="headerlink" title="例子"></a>例子</h4></li><li><code>curl -T newfile.txt -u root:key ftp://xxxxx/xx/dir</code> 上传</li><li><code>curl -o myname.zip https://xxx/xx.zip</code> 下载并重命名<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3></li><li>查询域名<h4 id="参数-38"><a href="#参数-38" class="headerlink" title="参数"></a>参数</h4></li><li>-a 详细信息</li><li>-v 显示执行过程<h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3></li><li>监听网络流量</li><li>内容太多了<h4 id="例子-40"><a href="#例子-40" class="headerlink" title="例子"></a>例子</h4></li><li><code>tcpdump -i ens33</code> 指定网络接口数据包</li><li><code>tcpdump -c 10 -q</code> 精简显示10个包</li><li><code>tcpdump host www.xxxx.xx</code></li><li><code>tcpdump -i any port 22 -A</code> 监听指定端口，并文本显示<h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3></li><li>设置路由器，建立连接, 端口扫描等等，很强大</li><li>瑞士军刀，netcat<h4 id="参数-39"><a href="#参数-39" class="headerlink" title="参数"></a>参数</h4></li><li>-v 显示执行过程</li><li>-w&lt;超时时间&gt; 设置等待连线时间</li><li>-u udp协议<h4 id="例子-41"><a href="#例子-41" class="headerlink" title="例子"></a>例子</h4></li><li><code>nc-v -z -w2 192xxxxip 1-100</code> 扫描端口范围</li><li><code>nc ip port</code> 连接端口<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3></li><li>创建并设置信息<h4 id="参数-40"><a href="#参数-40" class="headerlink" title="参数"></a>参数</h4></li><li>-m 自动创建家目录</li><li>-M 不要创建家目录</li><li>-s 指定用户登录后使用的shell<h4 id="例子-42"><a href="#例子-42" class="headerlink" title="例子"></a>例子</h4></li><li><code>useradd -m -s /bin/bash user2</code> 常用创建方法</li><li><code>useradd -g group username</code> 指定组id<h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3></li><li>修改密码<h4 id="参数-41"><a href="#参数-41" class="headerlink" title="参数"></a>参数</h4></li><li>-d 删除密码</li><li>-l 锁定用户密码值，不可改</li><li>-u 解锁，可以改</li><li>-e 下次登录强制修改密码</li><li>-k 到期还能用</li><li>-S 查询密码状态<h4 id="例子-43"><a href="#例子-43" class="headerlink" title="例子"></a>例子</h4></li><li><code>passwd -l chris</code> 锁定密码<h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3></li><li>删除用户<h4 id="例子-44"><a href="#例子-44" class="headerlink" title="例子"></a>例子</h4></li><li><code>userdel -r chris</code> 把家目录和账号都删掉<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3></li><li>切换用户<h4 id="例子-45"><a href="#例子-45" class="headerlink" title="例子"></a>例子</h4></li><li><code>su -c whoami alivin</code> 执行whoami之后退后原来的</li><li><code>su - chris</code> 切换账号并改到chris的家目录<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3></li><li>管理员身份执行<h4 id="例子-46"><a href="#例子-46" class="headerlink" title="例子"></a>例子</h4></li><li><code>sudo -l</code> 列出当前用户权限<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3></li><li>显示id<h4 id="例子-47"><a href="#例子-47" class="headerlink" title="例子"></a>例子</h4></li><li><code>id -g chris</code> 显示所属组的id<h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3></li><li>修改用户信息<h4 id="例子-48"><a href="#例子-48" class="headerlink" title="例子"></a>例子</h4></li><li><code>usermod -u 1234 chris</code> 修改uid</li><li><code>usermod -l harry chris</code> 修改名字成harry</li><li><code>usermod -L chris</code> 锁定<h3 id="groups-groupadd-groupdel"><a href="#groups-groupadd-groupdel" class="headerlink" title="groups groupadd groupdel"></a>groups groupadd groupdel</h3></li><li>组管理<h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3></li><li>打印当前登录用户<h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3></li><li>查看当前登录用户信息（所有人）<h4 id="参数-42"><a href="#参数-42" class="headerlink" title="参数"></a>参数</h4></li><li>-a 全面信息</li><li>-b 系统最近启动工商局</li><li>-l 系统登录进程</li><li>-H 带有标题打印用户名，终端，时间</li><li>-u 已登录用户列表</li><li>-q 列出所有用户数量和名称<h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3></li><li>现在登录用户<h4 id="参数-43"><a href="#参数-43" class="headerlink" title="参数"></a>参数</h4></li><li>-h 不打印头信息</li><li>-u 显示当前进程和cpu时间时忽略用户名</li><li>-s 短输出</li><li>-f 从哪登录</li><li>-o 老式输出</li><li>-i 显示ip而不是主机名<h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3></li><li>显示用户或终端的登录情况<h4 id="例子-49"><a href="#例子-49" class="headerlink" title="例子"></a>例子</h4></li><li><code>last -n 5 -a -i</code> 最后一列显示ip，显示5行<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3></li><li>显示当前登录的用户<h2 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3></li><li>实时显示进程动态<h4 id="参数-44"><a href="#参数-44" class="headerlink" title="参数"></a>参数</h4></li><li>-d 指定刷新间隔</li><li>-c 切换显示命令名称和完整命令行</li><li>-p 通过监控进程id看一个</li><li>-n 信息更新最大次数<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4></li><li>c 显示进程绝对路径</li><li>P cpu排序</li><li>M 内存排序<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3></li><li>显示进程状态<h4 id="参数-45"><a href="#参数-45" class="headerlink" title="参数"></a>参数</h4></li><li>-A 显示所有进程信息<h4 id="例子-50"><a href="#例子-50" class="headerlink" title="例子"></a>例子</h4></li><li><code>ps -aux</code> 显示所有程序</li><li><code>ps -axf</code> 树形显示进程</li><li><code>ps -u chris</code> 指定用户</li><li><code>ps -aux | less</code> 配合less<h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3></li><li>树状图显示进程<h4 id="参数-46"><a href="#参数-46" class="headerlink" title="参数"></a>参数</h4></li><li>-a 显示完整指令</li><li>-c 不使用精简表示法</li><li>-G 使用VT100终端机的列绘图字符</li><li>-h 特表指明正在执行的程序<h3 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h3></li><li>检索进程<h4 id="参数-47"><a href="#参数-47" class="headerlink" title="参数"></a>参数</h4></li><li>-d 设置字符用于分割id</li><li>-f 模式参数仅用于匹配进程名</li><li>-l 列出名字和id</li><li>-u 匹配指定有效用户id进程<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3></li><li>查看进程打开的文件<h4 id="例子-51"><a href="#例子-51" class="headerlink" title="例子"></a>例子</h4></li><li><code>lsof +d /home</code> 显示指定目录中被调用的文件信息</li><li><code>lsof -c bash</code> 只当某个程序的信息</li><li><code>lsof +D /home</code> 递归显示</li><li><code>lsof /bin/bash</code> 查看谁在用这个文件<h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><h3 id="jobs-bg-fg"><a href="#jobs-bg-fg" class="headerlink" title="jobs/bg/fg"></a>jobs/bg/fg</h3></li><li>终端任务调度<h4 id="例子-52"><a href="#例子-52" class="headerlink" title="例子"></a>例子</h4></li><li><code>jobs -l</code> 列出当前shell任务</li><li><code>fg 2</code> 调至前台</li><li><code>ctrl+z</code> 后台</li><li><code>bg 2</code> 后台<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3></li><li>发送信号到进程<h4 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h4></li><li>9 终止</li><li>3 退出ctrl \</li><li>2 终端ctrl+c</li><li>1 终端断线</li><li>15 终止</li><li>19 暂停</li><li>18 继续<h4 id="例子-53"><a href="#例子-53" class="headerlink" title="例子"></a>例子</h4></li><li><code>kill -9 18889</code> 杀死进程<h3 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h3></li><li>杀死进程</li><li>也能发送信号<h4 id="参数-48"><a href="#参数-48" class="headerlink" title="参数"></a>参数</h4></li><li>-l 打印所有信号</li><li>-u 杀死指定用户进程<h4 id="例子-54"><a href="#例子-54" class="headerlink" title="例子"></a>例子</h4></li><li><code>killall sleep</code> 杀死所有sleep进程<h3 id="nice-renice"><a href="#nice-renice" class="headerlink" title="nice/renice"></a>nice/renice</h3></li><li>调整进程优先级<h4 id="参数-49"><a href="#参数-49" class="headerlink" title="参数"></a>参数</h4></li><li>-n 接数值</li><li>-g 指定进程组</li><li>-p 改变优先级等级</li><li>-u 指定开启进程的用户名<h4 id="例子-55"><a href="#例子-55" class="headerlink" title="例子"></a>例子</h4></li><li><code>nice -15 vim &amp;</code> <code>nice -n 15 vim &amp;</code> 设置优先级</li><li><code>renice 6 -p 6666</code> 把6666进程改优先值<h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3></li><li>后台运行，不显示终端<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><h3 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h3></li><li>包管理器<h4 id="例子-56"><a href="#例子-56" class="headerlink" title="例子"></a>例子</h4></li><li><code>sudo apt update upgrade</code></li><li><code>sudo apt upgrade vim</code></li><li><code>sudo apt install bat</code> 安装</li><li><code>sudo apt remove bat</code> 卸载</li><li><code>sudo apt show bat</code> 展示软件包信息</li><li><code>sudo apt autoremove</code> 自动清理依赖和库文件</li><li><code>sudo apt list --installed</code> 列出已安装的软件包<h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3></li><li>类似的，用apt<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3></li><li>显示设置环境变量</li><li>仅仅本次登录<h4 id="例子-57"><a href="#例子-57" class="headerlink" title="例子"></a>例子</h4></li><li><code>export -p</code> 列出</li><li><code>export MYenv=7</code> 定义环境变量</li><li><code>export PATH=$PATH:/usr/local/mysql/bin</code> 修改变量<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4></li><li><code>/etc/porfile</code> 所有用户</li><li><code>~/.bashrc</code> 当前用户<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3></li><li>更新环境变量</li><li>可以用 <code>.</code> 来代替<h4 id="例子-58"><a href="#例子-58" class="headerlink" title="例子"></a>例子</h4></li><li><code>. ~/.bashrc</code> 读取和执行bashrc文件<h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3></li><li>输出字符串<h4 id="例子-59"><a href="#例子-59" class="headerlink" title="例子"></a>例子</h4></li><li><code>echo $PATH</code> $把path提取出来打印</li><li><code>echo &quot;hello&quot; &gt; file.txt</code> 定向到文件</li><li><code>echo -e &quot;a\nb\nc&quot;</code> 开启转义</li><li>Echo `date` 能执行命令，显示结果<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3></li><li>清理屏幕<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3></li><li>管理命令记录<h4 id="参数-50"><a href="#参数-50" class="headerlink" title="参数"></a>参数</h4></li><li>-c 清空记录</li><li>-d 删除指定序号的记录</li><li>-n 读取命令记录<h4 id="例子-60"><a href="#例子-60" class="headerlink" title="例子"></a>例子</h4></li><li><code>!2039</code> 重新执行2039命令</li><li><code>!!</code> 执行上一条<h3 id="login-logout"><a href="#login-logout" class="headerlink" title="login/logout"></a>login/logout</h3></li><li>登入登出<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3></li><li>退出终端/ssh</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自动控制原理第一章</title>
      <link href="/posts/a48157de.html"/>
      <url>/posts/a48157de.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-2自动控制基本原理"><a href="#1-2自动控制基本原理" class="headerlink" title="1.2自动控制基本原理"></a>1.2自动控制基本原理</h1><h2 id="人工控制与自动控制"><a href="#人工控制与自动控制" class="headerlink" title="人工控制与自动控制"></a>人工控制与自动控制</h2><ul><li>操作人员完成控制——人工控制</li><li>自动控制模仿了人工控制</li><li>自动控制元件<ul><li>给定元件</li><li>测量元件</li><li>比较元件</li><li>校正元件</li><li>执行元件<h2 id="1-2-2开环控制与闭环控制"><a href="#1-2-2开环控制与闭环控制" class="headerlink" title="1.2.2开环控制与闭环控制"></a>1.2.2开环控制与闭环控制</h2></li></ul></li><li>归为基本控制方式<h3 id="1-开环控制系统"><a href="#1-开环控制系统" class="headerlink" title="1.开环控制系统"></a>1.开环控制系统</h3></li><li>方块 表示系统中的功能元件</li><li>箭头有向线段 元件之间的输入输出传递方向</li><li>外部干扰较弱，精度要求不高场合</li><li>特征：没有反向的信号回传；抗干扰能力差；成本低<h3 id="闭环控制系统"><a href="#闭环控制系统" class="headerlink" title="闭环控制系统"></a>闭环控制系统</h3></li><li>信息在系统内的传递形成了闭合环路</li><li>通道<ul><li>前向通道：信号从输入到输出方向传递的通路</li><li>反馈通道：输出到输入</li></ul></li><li>闭环控制系统利用反馈信号获得比较偏差来产生控制作用，故也称为反馈控制系统。</li><li>内部参数精度没有这么高；增加了反馈元件和比较元件；结构比较复杂，搞不好会震荡</li><li>系统是自动控制还是手动控制与系统是开环还是闭环<strong>无关</strong>。<h2 id="反馈控制系统的基本要求"><a href="#反馈控制系统的基本要求" class="headerlink" title="反馈控制系统的基本要求"></a>反馈控制系统的基本要求</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3></li><li>稳定性是指系统受扰动后<strong>重新恢复平衡</strong>的能力</li><li>稳定是衰减过程，等幅振荡（临界稳定过程）；不稳定为发散过程<h3 id="快速性"><a href="#快速性" class="headerlink" title="快速性"></a>快速性</h3></li><li>稳定的系统对平衡状态的<strong>恢复或跟随</strong>的速度</li><li>影响因素<ul><li>扰动</li><li>任务需要改变平衡状态<h3 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a>准确性</h3></li></ul></li><li>跟随期待量的能力</li><li>系统输出量的期望值与实际值之差称为稳态误差，越小稳态精度越高；为零就是无差系统，不为零就是有差系统<h1 id="反馈系统的组成"><a href="#反馈系统的组成" class="headerlink" title="反馈系统的组成"></a>反馈系统的组成</h1><h2 id="按构成系统的基本元件划分"><a href="#按构成系统的基本元件划分" class="headerlink" title="按构成系统的基本元件划分"></a>按构成系统的基本元件划分</h2></li><li>测量元件：测量，量纲转换</li><li>比较元件：形成偏差</li><li>校正元件：基于偏差产生控制命令</li><li>执行元件：执行控制命令</li><li>放大元件：对信号家乡放大</li><li>被控对象：受控对象<h2 id="按系统内部基本功能环节划分"><a href="#按系统内部基本功能环节划分" class="headerlink" title="按系统内部基本功能环节划分"></a>按系统内部基本功能环节划分</h2></li><li>传感器：测量</li><li>控制器：产生执行的控制信号</li><li>执行机构：执行器，控制/调节被控过程</li><li>被控对象：被控过程<h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h2></li><li>p11 略<h1 id="控制系统分类"><a href="#控制系统分类" class="headerlink" title="控制系统分类"></a>控制系统分类</h1><h2 id="按参考输入信号特征分类"><a href="#按参考输入信号特征分类" class="headerlink" title="按参考输入信号特征分类"></a>按参考输入信号特征分类</h2><h3 id="恒值控制系统"><a href="#恒值控制系统" class="headerlink" title="恒值控制系统"></a>恒值控制系统</h3></li><li>输入信号恒定<h3 id="随动控制系统"><a href="#随动控制系统" class="headerlink" title="随动控制系统"></a>随动控制系统</h3></li><li>伺服系统</li><li>参考输入信号为预先未知的函数<h3 id="程序控制系统"><a href="#程序控制系统" class="headerlink" title="程序控制系统"></a>程序控制系统</h3></li><li>参考输入信号是预先设定的函数曲线<h2 id="按系统环节间信号传递形式分类"><a href="#按系统环节间信号传递形式分类" class="headerlink" title="按系统环节间信号传递形式分类"></a>按系统环节间信号传递形式分类</h2><h3 id="连续时间控制系统"><a href="#连续时间控制系统" class="headerlink" title="连续时间控制系统"></a>连续时间控制系统</h3></li><li>环节间的信号传递为t的连续函数<h3 id="离散时间控制系统"><a href="#离散时间控制系统" class="headerlink" title="离散时间控制系统"></a>离散时间控制系统</h3></li><li>脉冲序列/数字编码序列形式</li><li>差分方程描述</li><li>控制器输入输出为数字量，A/D<h3 id="网络化控制系统"><a href="#网络化控制系统" class="headerlink" title="网络化控制系统"></a>网络化控制系统</h3></li><li>不连续信号——一个个包含数据和网络控制信息的数据包<h2 id="按描述系统的动态方程分类"><a href="#按描述系统的动态方程分类" class="headerlink" title="按描述系统的动态方程分类"></a>按描述系统的动态方程分类</h2><h3 id="线性系统"><a href="#线性系统" class="headerlink" title="线性系统"></a>线性系统</h3></li><li>满足线性叠加原理<h3 id="非线性系统"><a href="#非线性系统" class="headerlink" title="非线性系统"></a>非线性系统</h3></li><li>非线性微分方程<h3 id="定常系统"><a href="#定常系统" class="headerlink" title="定常系统"></a>定常系统</h3></li><li>定常微分方程</li><li>时不变系统<h3 id="时变系统"><a href="#时变系统" class="headerlink" title="时变系统"></a>时变系统</h3></li><li>微分方程描述</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自动控制原理第二章</title>
      <link href="/posts/9a8d65cc.html"/>
      <url>/posts/9a8d65cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="mathjax-true"><a href="#mathjax-true" class="headerlink" title="mathjax: true"></a>mathjax: true</h1><h1 id="Date-2024-03-05"><a href="#Date-2024-03-05" class="headerlink" title="- Date:2024-03-05"></a>- Date:2024-03-05</h1><ul><li>Time:17:02</li><li>Subject: </li><li>Tags:<br>[[2024-03]]</li></ul><hr><h1 id="系统的微分方程"><a href="#系统的微分方程" class="headerlink" title="系统的微分方程"></a>系统的微分方程</h1><h2 id="物理系统微分方程"><a href="#物理系统微分方程" class="headerlink" title="物理系统微分方程"></a>物理系统微分方程</h2><blockquote><p>[!note]<br>步骤</p><ol><li>定义系统及其组成元件</li><li>确定必要的假设条件</li><li>利用系统自身的物理规律</li><li>利用各组成元件的原始方程和前面所确定的输入量、中间变量和输出量，<strong>消去中间变量</strong>，建立描述系统输入量与输出量之间关系的微分方程</li><li>若得到的是线性微分方程，通常将其列写为<strong>标准形式</strong>，即将与输出量和输入量有关的各项分别列写在等号左右两边<strong>（左出右入）</strong>，并且两边各导数项均按<strong>降幂排列</strong>。若得到的是非线性微分方程，则需要对非线性微分方程进行<strong>线性化处理</strong>才能列写为线性微分方程的标准形式</li></ol></blockquote><ul><li>线性叠加</li><li>例p24</li><li>几阶系统看最高次导数</li><li>时间常数 </li><li><script type="math/tex; mode=display">T_m=J_m R_a /\left(\beta_m R_a+C_e C_m\right)</script></li><li>电压传递常数和转矩传递常数 </li><li><script type="math/tex; mode=display">\frac  {  C_m  }    {  \beta_m R_a+C_e C_m  }   u_a(t)-\frac  {  R_a  }    {  \beta_m R_a+C_e C_m  }   M_c(t)</script><h2 id="微分方程的增量化和无因次化"><a href="#微分方程的增量化和无因次化" class="headerlink" title="微分方程的增量化和无因次化"></a>微分方程的增量化和无因次化</h2><h3 id="增量化"><a href="#增量化" class="headerlink" title="增量化"></a>增量化</h3></li><li>微分方程变量各阶导数为0，变化率0，也称为静态数学模型，例如 <code>t=0</code> 系统处于稳定工作状态，又称为平衡状态，此时各变量可视为常量，则各阶导数均为零</li><li>初步认识：微分方程=稳态+瞬态</li><li>平衡状态方程，导数等于0，解出当前t0</li><li>非增量微分方程消去常数项后，各变量前添加Δ<h3 id="无因次化"><a href="#无因次化" class="headerlink" title="无因次化"></a>无因次化</h3>考虑微分方程</li></ul><script type="math/tex; mode=display">T_  {  m  }   \frac  {  d \omega( t )  }     {  d t  }  +\omega( t )=K_  {  u  }   u_  {  a  }   ( t )-K_  {  M  }   M_  {  c  }   ( t )</script><p>平衡位置： </p><script type="math/tex; mode=display">\omega( t_  {  0  }   )=\omega_  {  0  }  , \ \ u_  {  a  }   ( t_  {  0  }   )=u_  {  a 0  }  , \ \ M_  {  c  }   ( t_  {  0  }   )=M_  {  c 0  }  ,</script><p>满足 </p><script type="math/tex; mode=display">\omega_  {  0  }  =K_  {  u  }   u_  {  a 0  }  -K_  {  M  }   M_  {  c 0  }</script><p>再令：</p><script type="math/tex; mode=display">\overline  {     {     {     {  \omega  }     }     }     }   ( t ) \!=\! \frac  {  \omega( t )  }     {  \omega_  {  0  }     }  , \ \ \overline  {     {     {     {  u  }     }     }     }  _  {  a  }   ( t ) \!=\! \frac  {  u_  {  a  }   ( t )  }     {  u_  {  a 0  }    }  , \ \ \overline  {     {     {     {  M  }    }     }     }  _  {  c  }   ( t ) \!=\! \frac  {  M_  {  c  }   ( t )  }     {  M_  {  c 0  }     }</script><script type="math/tex; mode=display">T_  {  m  }   \frac  {  d \overline   {    {    {    {  \omega  }    }     }    }   ( t )  }     {  d t  }  +\overline   {    {    {    {  \omega  }    }     }    }   ( t )=\frac  {  K_  {  u  }   u_  {  a 0  }    }     {  \omega_  {  0  }    }   \overline   {    {    {    {  u  }    }     }    }  _  {  a  }   ( t )-\frac  {  K_  {  M  }   M_  {  c 0  }    }     {  \omega_  {  0  }    }   \overline   {    {    {    {  M  }    }     }    }  _  {  c  }   ( t )</script><ul><li>时间还是绝对化描述</li><li>令 <script type="math/tex; mode=display">\tau=t / T_  {  m  }</script></li><li>时间常数，作为标称<script type="math/tex; mode=display">T_  {  m  }</script></li></ul><script type="math/tex; mode=display">\frac  {  d \overline  {     {     {     {  \omega  }     }     }     }   ( \tau T_  {  m  }   )  }     {  d \tau  }  +\overline  {     {     {     {  \omega  }     }     }     }   ( \tau T_  {  m  }   ) \!=\! \frac  {  K_  {  u  }   u_  {  a 0  }    }     {  \omega_  {  0  }    }   \overline  {     {     {     {  u  }     }     }     }  _  {  a  }   ( \tau T_  {  m  }   ) \!-\! \frac  {  K_  {  M  }   M_  {  c 0  }    }     {  \omega_  {  0  }    }   \overline  {     {     {     {  M  }     }     }     }  _  {  c  }   ( \tau T_  {  m  }   ) \!</script><h2 id="非线性方程线性化"><a href="#非线性方程线性化" class="headerlink" title="非线性方程线性化"></a>非线性方程线性化</h2><ul><li>在小范围内线性处理，且选择在<strong>平衡状态点</strong>进行增量化描述</li><li>考虑高次，低次去掉偏导</li></ul><script type="math/tex; mode=display">\begin{aligned}     {    {  y ( t )  }    }   &   {    {    }     {    {    }  =f ( x_  {  1  }   ( t ), x_  {  2  }   ( t ) )  }    }   \\   {    {    }    }   &   {    {    }     {    {    }     {    }  =f ( x_  {  1 0  }  , x_  {  2 0  }   )+\frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  1  }    }   \Bigg|_  {  \stackrel  {  x_  {  i  }  =x_  {  i 0  }    }     {  x_  {  i  }  =x_  {  i 0  }    }    }   \frac  {  \Delta x_  {  1  }    }     {  1!  }  +\frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  2  }    }   \Bigg|_  {  \stackrel  {  x_  {  i  }  =x_  {  i 0  }    }     {  x_  {  i  }  =x_  {  i 0  }    }    }   \frac  {  \Delta x_  {  2  }    }     {  1!  }    }    }   \\ \end{aligned}</script><script type="math/tex; mode=display">+ \frac  {  \partial^  {  2  }   f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  1  }  ^  {  2  }    }   \Bigg|_  {  x_  {  1  }  =x_  {  i_  {  0  }    }   \atop x_  {  2  }  =x_  {  i_  {  0  }    }    }   \frac  {  \big( \Delta x_  {  1  }   \big)^  {  2  }    }     {  2!  }  +\frac  {  \partial^  {  2  }   f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  2  }  ^  {  2  }    }   \Bigg|_  {  x_  {  1  }  =x_  {  i_  {  0  }    }   \atop x_  {  2  }  =x_  {  i_  {  0  }    }    }   \frac  {  \big( \Delta x_  {  2  }   \big)^  {  2  }    }     {  2!  }  +\cdots</script><ul><li>当增量Δx1=x1-x10 Δx2=x2=x20足够小，忽略高次方的项</li></ul><script type="math/tex; mode=display">\begin{array}     {  r  }     {    {    {  \Delta y ( t )=y ( t )-y_  {  0  }  =f ( x_  {  1  }   ( t ), x_  {  2  }   ( t ) )-f ( x_  {  1 0  }  , x_  {  2 0  }   )  }    }    }   \\   {    {    {  =\left. \frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  1  }    }   \right|_  {  x_  {  1  }  =x_  {  0  }    }   \Delta x_  {  1  }   ( t )+\left. \frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  2  }    }   \right|_  {  x_  {  1  }  =x_  {  0  }    }   \Delta x_  {  2  }   ( t )  }    }    }   \\   {    {    {  =K_  {  1  }   \Delta x_  {  1  }   ( t )+K_  {  2  }   \Delta x_  {  2  }   ( t )  }    }    }   \\ \end{array}</script><script type="math/tex; mode=display">其中K_  {  1  }  =\frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  1  }    }   \Bigg|_  {  \stackrel  {  x_  {  1  }  =x_  {  1 0  }    }     {  x_  {  2  }  =x_  {  2 0  }    }    }   \;, \; \; \; K_  {  2  }  =\frac  {  \partial f ( x_  {  1  }  , x_  {  2  }   )  }     {  \partial x_  {  2  }    }   \Bigg|_  {  \stackrel  {  x_  {  1  }  =x_  {  1 0  }    }     {  x_  {  2  }  =x_  {  2 0  }    }    }</script><h2 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h2><ul><li>引入复数将时间域问题转化为复频率域问题来研究，将解微分方程问题简化为解代数问题<h3 id="线性系统传递函数的概念和定义"><a href="#线性系统传递函数的概念和定义" class="headerlink" title="线性系统传递函数的概念和定义"></a>线性系统传递函数的概念和定义</h3></li><li>传递函数=系统输出的拉氏变换/输入的拉氏变换</li><li>输入与输出之间的关系 （固有特性）, 与输入的具体形式无关，都以相同的传递作用输出</li><li>标准线性系统的传递模型 <script type="math/tex; mode=display">G ( s ) \!=\! \frac  {  Y ( s )  }     {  U ( s )  }   \!=\! \frac  {  b_  {  m  }   s^  {  m  }  +b_  {  m-1  }   s^  {  m-1  }  +\cdots+b_  {  1  }   s+b_  {  0  }    }     {  a_  {  n  }   s^  {  n  }  +a_  {  n-1  }   s^  {  n-1  }  +\cdots+a_  {  1  }   s+a_  {  0  }    }</script></li><li>初始条件下有<script type="math/tex; mode=display">f ( 0 )=f^  {  \prime  }   ( 0 )=\cdots=f^  {  n-1  }   ( 0 )=0 \,, \ \ L \Biggl[ \frac  {  d^  {  n  }   f ( t )  }     {  d t^  {  n  }    }   \Biggr]=\Biggl( s^  {  n  }   F ( s ) \Biggr)</script></li><li>通过上式，下式两边拉氏变换</li></ul><script type="math/tex; mode=display">\begin{aligned}     {    {  a_  {  n  }     {  \frac  {  \mathrm  {  d  }  ^  {  n  }   y ( t )  }     {  \mathrm  {  d  }   t^  {  n  }    }    }    }    }   &   {    {    }     {    {    }  +a_  {  n-1  }     {  \frac  {  \mathrm  {  d  }  ^  {  n-1  }   y ( t )  }     {  \mathrm  {  d  }   t^  {  n-1  }    }    }  +\cdots+a_  {  1  }     {  \frac  {  \mathrm  {  d  }   y ( t )  }     {  \mathrm  {  d  }   t  }    }  +a_  {  0  }   y ( t )  }    }   \\   {    {    }    }   &   {    {    }     {    {    }  =b_  {  m  }     {  \frac  {  \mathrm  {  d  }  ^  {  m  }   u ( t )  }     {  \mathrm  {  d  }   t^  {  m  }    }    }  +b_  {  m-1  }     {  \frac  {  \mathrm  {  d  }  ^  {  m-1  }   u ( t )  }     {  \mathrm  {  d  }   t^  {  m-1  }    }    }  +\cdots+b_  {  1  }     {  \frac  {  \mathrm  {  d  }   u ( t )  }     {  \mathrm  {  d  }   t  }    }  +b_  {  0  }   u ( t )  }    }   \\ \end{aligned}</script><ul><li>有如下，化简最后得到标准的模型</li><li><script type="math/tex; mode=display">\begin{aligned} { {a_{n} s^{n} Y ( s )+}} & { {} { {} a_{n-1} s^{n-1} Y ( s )+\cdots+a_{1} s Y ( s )+a_{0} Y ( s )}} \\ { {} } & { {} { {} {}=b_{m} s^{m} U ( s )+b_{m-1} s^{m-1} U ( s )+\cdots+b_{1} s U ( s )+b_{0} U ( s )} } \\ \end{aligned}</script></li></ul><ul><li>对于多个输入，分析时，将另外一个输入关闭</li></ul><script type="math/tex; mode=display">\Omega( s )=G_  {  1  }   ( s ) U_  {  a  }   ( s )+G_  {  2  }   ( s ) M_  {  c  }   ( s )</script><blockquote><p>[!note] 说明</p><ul><li>传递函数是对线性定常微分方程求拉普拉斯变换得到的，因此，传递函数表达式中各项系数的值完全与微分方程中各导数项的系数相对应，取决于系统的结构和参数。</li><li>分母最高次n，n阶系统，n≥m，真有理函数</li><li>单入单出<h3 id="传递函数常用表现形式"><a href="#传递函数常用表现形式" class="headerlink" title="传递函数常用表现形式"></a>传递函数常用表现形式</h3></li></ul><ol><li>零、极点表示的形式<script type="math/tex; mode=display">G ( s )=\frac  {  b_  {  m  }    }     {  a_  {  n  }    }   \times\frac  {  s^  {  m  }  +d_  {  m-1  }   s^  {  m-1  }  +\cdots+d_  {  1  }   s+d_  {  0  }    }     {  s^  {  n  }  +c_  {  n-1  }   s^  {  n-1  }  +\cdots+c_  {  1  }   s+c_  {  0  }    }   = K_  {  g  }   \, \frac  {  ( s+z_  {  1  }   ) ( s+z_  {  2  }   ) \cdots( s+z_  {  m  }   )  }     {  ( s+p_  {  1  }   ) ( s+p_  {  2  }   ) \cdots( s+p_  {  n  }   )  }  =K_  {  g  }   \, \frac  {  \prod_  {  i=1  }  ^  {  m  }   ( s+z_  {  i  }   )  }     {  \prod_  {  l=1  }  ^  {  n  }   ( s+p_  {  l  }   )  }</script></li><li>实数极点和共轭复数极点细化形式</li></ol><ul><li>不同极点种类性质不同<script type="math/tex; mode=display">G ( s )=\frac  {  K_  {  g  }    }     {  s^  {  \nu  }    }   \times\frac  {  \prod_  {  i=1  }  ^  {  m  }   ( s+z_  {  i  }   )  }     {  \prod_  {  l=\nu+1  }  ^  {  \nu+n_  {  i  }    }   ( s+p_  {  l  }   ) \prod_  {  l=\nu+n_  {  i  }  +1  }  ^  {  \nu+n_  {  i  }  +( s-\nu-n_  {  i  }   ) / 2  }   ( s^  {  2  }  +2 \zeta_  {  l  }   \omega_  {  l  }   s+\omega_  {  l  }  ^  {  2  }   )  }</script></li><li>$K<em>  {  g  }  =\frac  {  b</em>  {  m  }    }     {  a_  {  n  }    }  $ ,称增益或传递系数</li><li>-z : 传递函数的零点，由 $G ( s )=0$ 求得，用“”表示; </li><li>$- p_  {  l  }  $ : 传递函数的极点，由 $G ( s )=\infty$ 求得，用“×”表示;</li><li>v：系统型数，决定稳态误差</li><li>共轭极点：与震荡有关</li></ul><ol><li>时间常数表示</li></ol></blockquote><script type="math/tex; mode=display">G ( s )=\frac  {  b_  {  0  }    }     {  a_  {  0  }    }   \times\frac  {  d_  {  m  }  ^  {  \prime  }   s^  {  m  }  +d_  {  m-1  }  ^  {  \prime  }   s^  {  m-1  }  +\cdots+d_  {  1  }  ^  {  \prime  }   s+1  }     {  c_  {  n  }  ^  {  \prime  }   s^  {  n  }  +c_  {  n-1  }  ^  {  \prime  }   s^  {  n-1  }  +\cdots+c_  {  1  }  ^  {  \prime  }   s+1  }  =K \frac  {  ( \tau_  {  1  }   s+1 ) ( \tau_  {  2  }  ^  {  2  }   s^  {  2  }  +\tau_  {  2  }   \zeta s+1 ) \cdots( \tau_  {  i  }   s+1 )  }     {  ( T_  {  i  }   s+1 ) ( T_  {  2  }  ^  {  2  }   s^  {  2  }  +T_  {  2  }   \zeta s+1 ) \cdots( T_  {  j  }   s+1 )  }</script><script type="math/tex; mode=display">G ( s )=\frac  {  K  }     {  s^  {  \nu  }    }   \times\frac  {  \prod_  {  i=1  }  ^  {  m  }   \left( \tau_  {  i  }   s+1 \right)  }     {  \prod_  {  l=\nu+1  }  ^  {  \nu+n_  {  i  }    }   ( T_  {  l  }   s+1 ) \prod_  {  l=\nu+n_  {  i  }  +1  }  ^  {  \nu+n_  {  i  }  +( n-\nu-n_  {  i  }   ) / 2  }   ( T_  {  l  }  ^  {  2  }   s^  {  2  }  +2 \xi_  {  l  }   T_  {  l  }   s+1 )  }</script><ul><li>$\tau<em>  {  i  }  , T</em>  {  i  }  $ : 时间常数</li><li>$K : K=G ( 0 ),$ 直流增益或静态放大系数<h3 id="典型输入信号及其拉普拉斯变换"><a href="#典型输入信号及其拉普拉斯变换" class="headerlink" title="典型输入信号及其拉普拉斯变换"></a>典型输入信号及其拉普拉斯变换</h3></li></ul><ol><li>单位阶跃信号</li></ol><script type="math/tex; mode=display">1 ( t )=\begin{cases}     {    {    {  1,  }    }    }   &   {    {    {  t \geqslant0  }    }    }   \\   {    {    {  0,  }    }    }   &   {    {    {  t < 0  }    }    }   \\ \end{cases}  .</script><script type="math/tex; mode=display">L   {  \bigl[  }   1 ( t )   {  \bigr]  }  =  {  \frac  {  1  }     {  s  }    }</script><ol><li>单位斜坡函数</li></ol><script type="math/tex; mode=display">r ( t )=\left\{\begin{array} {c c} { { {t,} } } & { { {t \geqslant0} } } \\ { { {0,} } } & { { {t < 0} } } \\ \end{array} \right.</script><script type="math/tex; mode=display">L \bigl[ r ( t ) \bigr]=\frac  {  1  }     {  s^  {  2  }    }</script><ol><li>单位抛物线</li><li>单位脉冲函数</li></ol><script type="math/tex; mode=display">\delta( t )=\operatorname*   {  l i m  }  _  {  \varepsilon\to0  }   \delta_  {  \varepsilon  }   ( t )</script><script type="math/tex; mode=display">\delta_{\varepsilon} ( t )=\left\{\begin{aligned} { { {0} } } & { { {} { {},} } } & { { { {} {} { {} t < 0} } } } \\ { { { {} } } } & { { {} { {} { {} \frac{1} {\varepsilon}},} } } & { { { {} 0 \leq{}t \leq\varepsilon} } } \\ { { { {} } } } & { { {} } } \\ { { { {0},} } } & { { { {} {} { {} t > \varepsilon} } } } \\ \end{aligned} \right.</script><ul><li>δ函数的强度，也称单位脉冲函数的冲量定义为 $S=\int_  {  -\infty  }  ^  {  +\infty  }   \delta( t ) \mathrm  {  d  }   t=1$</li></ul><script type="math/tex; mode=display">L \big[ \delta( t ) \big]=1</script><ul><li>由于理论分析而已，是理想的函数<h3 id="单位脉冲响应函数"><a href="#单位脉冲响应函数" class="headerlink" title="单位脉冲响应函数"></a>单位脉冲响应函数</h3></li><li>卷积公式</li><li><script type="math/tex; mode=display">y ( t )=L^  {  -1  }   [ Y ( s ) ]=L^  {  -1  }   [ G ( s ) R ( s ) ]=\int_  {  0  }  ^  {  +\infty  }   g ( \tau) r ( t-\tau) \mathrm  {  d  }   \tau, \; \; \; t \geq0</script><blockquote><p>[!note]<br>线性定常系统的单位脉冲响应<strong>数值上</strong>等于改系统传递函数的反拉氏变换</p></blockquote></li></ul><p>U（s）=1 （t）</p><h3 id="求解系统输出响应"><a href="#求解系统输出响应" class="headerlink" title="求解系统输出响应"></a>求解系统输出响应</h3><ul><li>输出求解为<script type="math/tex; mode=display">y ( t )=L^  {  -1  }   \bigl[ Y ( s ) \bigr]=L^  {  -1  }   \bigl[ G ( s ) U ( s ) \bigr]=L^  {  -1  }   \bigl[ F ( s ) \bigr]</script></li><li>解法<ul><li>结合留数进行求解最终大多是exp（-xxt），位移性质</li><li>重根考虑求导加那个感叹号<h3 id="典型环节及其传递函数"><a href="#典型环节及其传递函数" class="headerlink" title="典型环节及其传递函数"></a>典型环节及其传递函数</h3></li></ul></li></ul><ol><li>比例环节</li></ol><ul><li><p>输入输出成比例<br>$y ( t )=K u ( t )$</p><script type="math/tex; mode=display">G ( s )=  {  \frac  {  Y ( s )  }     {  U ( s )  }    }  =K</script></li><li><p>常见的比例环节实例有分压器、变压器、杠杆、线性放大器、无隙的传动齿轮组等</p></li></ul><ol><li>积分环节</li></ol><ul><li>输入的累积，表现为<strong>输出的变化速度和输入成正比</strong></li><li>在单位阶跃输入激励下，积分环节的输出响应Y（t） 随时间直线上升</li></ul><script type="math/tex; mode=display">微分方程:y ( t )=K \! \int u ( t ) \mathrm  {  d  }   t</script><script type="math/tex; mode=display">G ( s )=  {  \frac  {  Y ( s )  }     {  U ( s )  }    }  =  {  \frac  {  K  }     {  s  }    }  =  {  \frac  {  1  }     {  T s  }    }</script><ol><li>惯性环节</li></ol><ul><li>物体对运动状态变化的阻抗程度</li></ul><script type="math/tex; mode=display">微分方程:T   {  \frac  {  \mathrm  {  d  }   y ( t )  }     {  \mathrm  {  d  }   t  }    }  +y ( t )=u ( t )</script><script type="math/tex; mode=display">G ( s )=  {  \frac  {  Y ( s )  }     {  U ( s )  }    }  =  {  \frac  {  1  }     {  T s+1  }    }</script><ul><li>单位阶跃响应<script type="math/tex; mode=display">Y ( s ) \!=\! G ( s ) U ( s ) \!=\!   {  \frac  {  1  }     {  T s+1  }    }     {  \frac  {  1  }     {  s  }    }   \!=\!   {  \frac  {  1 / T  }     {  s ( s \!+\! 1 / T )  }    }   \!=\!   {  \frac  {  1  }     {  s  }    }   \!-\!   {  \frac  {  1  }     {  s \!+\! 1 / T  }    }</script></li><li>跟随速度由T决定</li></ul><ol><li>振荡环节（二阶振荡环节）</li></ol><script type="math/tex; mode=display">T^  {  2  }   \, \frac  {  \mathrm  {  d  }  ^  {  2  }   y ( t )  }     {  \mathrm  {  d  }   t^  {  2  }    }   \!+\! 2 \zeta T \frac  {  \mathrm  {  d  }   y ( t )  }     {  \mathrm  {  d  }   t  }   \!+\! y ( t ) \!=\! u ( t )</script><script type="math/tex; mode=display">G ( s )=\frac  {  1  }     {  T^  {  2  }   s^  {  2  }  +2 \zeta T s+1  }</script><p>$T$ : 时间常数<br>$\zeta$ : 阻尼比 $0 &lt; \zeta&lt; 1$<br>$\omega_{  n  }$ : 自然振荡角频率</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客第一文</title>
      <link href="/posts/b6ebd1b0.html"/>
      <url>/posts/b6ebd1b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="简简单单的记录一下"><a href="#简简单单的记录一下" class="headerlink" title="简简单单的记录一下"></a>简简单单的记录一下</h1><p><em>建立该博客用于记录各种事情吧~</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>hello!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;}div#menus {    font-family: "ZhuZiAYuanJWD";}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}.icon-zhongbiao::before {    color: #f7c768;}/* bilibli番剧插件 *//* #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;}a.bangumi-tab:hover {    text-decoration: none !important;}.bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;}.bangumi-button {    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size: 1.1em;}.bangumi-info-item {    border-right: 1px solid #f2b94b;}.bangumi-info-item span {    color: #f2b94b;}.bangumi-info-item em {    color: #f2b94b;} *//* 解决artitalk的图标问题 */#uploadSource>svg {    width: 1.19em;    height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {    background-color: transparent !important;}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);}/* 文章页面正文背景 */div#post {    background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page {    background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive {    background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag {    background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category {    background: rgba(255, 255, 255, 0.9);}/*夜间模式伪类遮罩层透明*/[data-theme="dark"] #recent-posts>.recent-post-item {    background: #121212;}[data-theme="dark"] .card-widget {    background: #121212 !important;}[data-theme="dark"] div#post {    background: #121212 !important;}[data-theme="dark"] div#tag {    background: #121212 !important;}[data-theme="dark"] div#archive {    background: #121212 !important;}[data-theme="dark"] div#page {    background: #121212 !important;}[data-theme="dark"] div#category {    background: #121212 !important;}[data-theme="dark"] div#category {    background: transparent !important;}/* 页脚透明 */#footer {    background: transparent !important;}/* 头图透明 */#page-header {    background: transparent !important;}#rightside>div>button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */    /* 默认情况下缩进左侧66px，只留一点箭头部分 *//* .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;} */    /* 鼠标悬停是左侧缩进归零，完全显示按钮 *//* .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;} *//* .aplayer.aplayer-fixed {    z-index: 999999 !important;} *//* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime.min.css"/>
      <url>/css/runtime.min.css</url>
      
        <content type="html"><![CDATA[div#runtime {    width: 180px;    margin: auto;    color: #fff;    padding-inline: 5px;    border-radius: 10px;    background-color: rgba(0, 0, 0, .7)}#workboard {    font-size: 12px}[data-theme=dark] div#runtime {    color: #28b4c8;    box-shadow: 0 0 5px rgba(28, 69, 218, .71);    animation: flashlight 1s linear infinite alternate}#ghbdages .github-badge img {    height: 20px}@-moz-keyframes flashlight {    from {        box-shadow: 0 0 5px #1478d2    }    to {        box-shadow: 0 0 2px #1478d2    }}@-webkit-keyframes flashlight {    from {        box-shadow: 0 0 5px #1478d2    }    to {        box-shadow: 0 0 2px #1478d2    }}@-o-keyframes flashlight {    from {        box-shadow: 0 0 5px #1478d2    }    to {        box-shadow: 0 0 2px #1478d2    }}@keyframes flashlight {    from {        box-shadow: 0 0 5px #1478d2    }    to {        box-shadow: 0 0 2px #1478d2    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.min.js"/>
      <url>/js/runtime.min.js</url>
      
        <content type="html"><![CDATA[var now = new Date();function createtime() {  var t = new Date("08/11/2023 00:00:00");  now.setTime(now.getTime() + 250);  var e = (now - t) / 1e3 / 60 / 60 / 24,    a = Math.floor(e),    n = (now - t) / 1e3 / 60 / 60 - 24 * a,    r = Math.floor(n);  1 == String(r).length && (r = "0" + r);  var s = (now - t) / 1e3 / 60 - 1440 * a - 60 * r,    i = Math.floor(s);  1 == String(i).length && (i = "0" + i);  var o = (now - t) / 1e3 - 86400 * a - 3600 * r - 60 * i,    l = Math.round(o);  1 == String(l).length && (l = "0" + l);  let g = "";  (g =    r < 18 && r >= 9      ? `<span class='textTip'> 本站勉强运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-check-square' style='color:white'></i>`      : `<span class='textTip'> 本站勉强运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-check-square' style='color:white'></i>`),    document.getElementById("workboard") &&      (document.getElementById("workboard").innerHTML = g);}setInterval(() => {  createtime();}, 250);]]></content>
      
    </entry>
    
    
  
</search>
